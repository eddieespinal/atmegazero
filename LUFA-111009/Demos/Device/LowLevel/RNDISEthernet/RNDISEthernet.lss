
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000046  00800100  00002d8e  00002e22  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002d8e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000012af  00800146  00800146  00002e68  2**0
                  ALLOC
  3 .debug_aranges 000004e0  00000000  00000000  00002e68  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000cec  00000000  00000000  00003348  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000081c7  00000000  00000000  00004034  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000025a1  00000000  00000000  0000c1fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005e80  00000000  00000000  0000e79c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000006e0  00000000  00000000  0001461c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00003089  00000000  00000000  00014cfc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000033bd  00000000  00000000  00017d85  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000558  00000000  00000000  0001b142  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	return true;
#endif
}

void Endpoint_ClearEndpoints(void)
{
       0:	1d c2       	rjmp	.+1082   	; 0x43c <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       2:	00 00       	nop

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
       4:	39 c2       	rjmp	.+1138   	; 0x478 <__bad_interrupt>

	return Serial_ReceiveByte();
}

int Serial_getchar_Blocking(FILE *Stream)
{
       6:	00 00       	nop
       8:	37 c2       	rjmp	.+1134   	; 0x478 <__bad_interrupt>
       a:	00 00       	nop
       c:	35 c2       	rjmp	.+1130   	; 0x478 <__bad_interrupt>
       e:	00 00       	nop
      10:	33 c2       	rjmp	.+1126   	; 0x478 <__bad_interrupt>
      12:	00 00       	nop
      14:	31 c2       	rjmp	.+1122   	; 0x478 <__bad_interrupt>
      16:	00 00       	nop
      18:	2f c2       	rjmp	.+1118   	; 0x478 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	2d c2       	rjmp	.+1114   	; 0x478 <__bad_interrupt>
      1e:	00 00       	nop
      20:	2b c2       	rjmp	.+1110   	; 0x478 <__bad_interrupt>
      22:	00 00       	nop
      24:	29 c2       	rjmp	.+1106   	; 0x478 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 5a 12 	jmp	0x24b4	; 0x24b4 <__vector_10>
      2c:	25 c2       	rjmp	.+1098   	; 0x478 <__bad_interrupt>
      2e:	00 00       	nop
      30:	23 c2       	rjmp	.+1094   	; 0x478 <__bad_interrupt>
      32:	00 00       	nop
      34:	21 c2       	rjmp	.+1090   	; 0x478 <__bad_interrupt>
      36:	00 00       	nop
      38:	1f c2       	rjmp	.+1086   	; 0x478 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	1d c2       	rjmp	.+1082   	; 0x478 <__bad_interrupt>
      3e:	00 00       	nop
      40:	1b c2       	rjmp	.+1078   	; 0x478 <__bad_interrupt>
      42:	00 00       	nop
      44:	19 c2       	rjmp	.+1074   	; 0x478 <__bad_interrupt>
      46:	00 00       	nop
      48:	17 c2       	rjmp	.+1070   	; 0x478 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	15 c2       	rjmp	.+1066   	; 0x478 <__bad_interrupt>
      4e:	00 00       	nop
      50:	13 c2       	rjmp	.+1062   	; 0x478 <__bad_interrupt>
      52:	00 00       	nop
      54:	11 c2       	rjmp	.+1058   	; 0x478 <__bad_interrupt>
      56:	00 00       	nop
      58:	0f c2       	rjmp	.+1054   	; 0x478 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0d c2       	rjmp	.+1050   	; 0x478 <__bad_interrupt>
      5e:	00 00       	nop
      60:	0b c2       	rjmp	.+1046   	; 0x478 <__bad_interrupt>
      62:	00 00       	nop
      64:	09 c2       	rjmp	.+1042   	; 0x478 <__bad_interrupt>
      66:	00 00       	nop
      68:	07 c2       	rjmp	.+1038   	; 0x478 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	05 c2       	rjmp	.+1034   	; 0x478 <__bad_interrupt>
      6e:	00 00       	nop
      70:	03 c2       	rjmp	.+1030   	; 0x478 <__bad_interrupt>
      72:	00 00       	nop
      74:	01 c2       	rjmp	.+1026   	; 0x478 <__bad_interrupt>
      76:	00 00       	nop
      78:	ff c1       	rjmp	.+1022   	; 0x478 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	fd c1       	rjmp	.+1018   	; 0x478 <__bad_interrupt>
      7e:	00 00       	nop
      80:	fb c1       	rjmp	.+1014   	; 0x478 <__bad_interrupt>
      82:	00 00       	nop
      84:	f9 c1       	rjmp	.+1010   	; 0x478 <__bad_interrupt>
      86:	00 00       	nop
      88:	f7 c1       	rjmp	.+1006   	; 0x478 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	f5 c1       	rjmp	.+1002   	; 0x478 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f3 c1       	rjmp	.+998    	; 0x478 <__bad_interrupt>
      92:	00 00       	nop
      94:	f1 c1       	rjmp	.+994    	; 0x478 <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
      a8:	00 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      ba:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
      ca:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
      da:	07 05 02 02 40 00 01 07 05 81 02 40 00 01           ....@......@..

000000e8 <LanguageString>:
      e8:	04 03 09 04                                         ....

000000ec <ManufacturerString>:
      ec:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      fc:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000106 <ProductString>:
     106:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
     116:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
     126:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

00000130 <HTTP200Header>:
     130:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     140:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     150:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     160:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     170:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     180:	0a 0d 0a 00                                         ....

00000184 <HTTP404Header>:
     184:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     194:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1a4:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     1b4:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     1c4:	0a 00                                               ..

000001c6 <HTTPPage>:
     1c6:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     1d6:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1e6:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1f6:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     206:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     216:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     226:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     236:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     246:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     256:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     266:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     276:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     286:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     296:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     2a6:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     2b6:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     2c6:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     2d6:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     2e6:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     2f6:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     306:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     316:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     326:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     336:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     346:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     356:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     366:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     376:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     386:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     396:	3c 2f 69 3e 31 31 31 30 30 39 09 09 3c 2f 70 3e     </i>111009..</p>
     3a6:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <AdapterVendorDescription>:
     422:	4c 55 46 41 20 52 4e 44 49 53 20 41 64 61 70 74     LUFA RNDIS Adapt
     432:	65 72 00                                            er.

00000435 <AdapterMACAddress>:
     435:	02 00 02 00 02 00 00                                .......

0000043c <__ctors_end>:
     43c:	11 24       	eor	r1, r1
     43e:	1f be       	out	0x3f, r1	; 63
     440:	cf ef       	ldi	r28, 0xFF	; 255
     442:	d0 e2       	ldi	r29, 0x20	; 32
     444:	de bf       	out	0x3e, r29	; 62
     446:	cd bf       	out	0x3d, r28	; 61

00000448 <__do_copy_data>:
     448:	11 e0       	ldi	r17, 0x01	; 1
     44a:	a0 e0       	ldi	r26, 0x00	; 0
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	ee e8       	ldi	r30, 0x8E	; 142
     450:	fd e2       	ldi	r31, 0x2D	; 45
     452:	00 e0       	ldi	r16, 0x00	; 0
     454:	0b bf       	out	0x3b, r16	; 59
     456:	02 c0       	rjmp	.+4      	; 0x45c <__do_copy_data+0x14>
     458:	07 90       	elpm	r0, Z+
     45a:	0d 92       	st	X+, r0
     45c:	a6 34       	cpi	r26, 0x46	; 70
     45e:	b1 07       	cpc	r27, r17
     460:	d9 f7       	brne	.-10     	; 0x458 <__do_copy_data+0x10>

00000462 <__do_clear_bss>:
     462:	13 e1       	ldi	r17, 0x13	; 19
     464:	a6 e4       	ldi	r26, 0x46	; 70
     466:	b1 e0       	ldi	r27, 0x01	; 1
     468:	01 c0       	rjmp	.+2      	; 0x46c <.do_clear_bss_start>

0000046a <.do_clear_bss_loop>:
     46a:	1d 92       	st	X+, r1

0000046c <.do_clear_bss_start>:
     46c:	a5 3f       	cpi	r26, 0xF5	; 245
     46e:	b1 07       	cpc	r27, r17
     470:	e1 f7       	brne	.-8      	; 0x46a <.do_clear_bss_loop>
     472:	c0 d1       	rcall	.+896    	; 0x7f4 <main>
     474:	0c 94 c5 16 	jmp	0x2d8a	; 0x2d8a <_exit>

00000478 <__bad_interrupt>:
     478:	c3 cd       	rjmp	.-1146   	; 0x0 <__vectors>

0000047a <EVENT_USB_Device_Connect>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     47a:	8b b1       	in	r24, 0x0b	; 11
     47c:	8f 70       	andi	r24, 0x0F	; 15
     47e:	80 6a       	ori	r24, 0xA0	; 160
     480:	8b b9       	out	0x0b, r24	; 11
 */
void EVENT_USB_Device_Connect(void)
{
	/* Indicate USB enumerating */
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     482:	08 95       	ret

00000484 <EVENT_USB_Device_Disconnect>:
     484:	8b b1       	in	r24, 0x0b	; 11
     486:	8f 70       	andi	r24, 0x0F	; 15
     488:	80 61       	ori	r24, 0x10	; 16
     48a:	8b b9       	out	0x0b, r24	; 11
 */
void EVENT_USB_Device_Disconnect(void)
{
	/* Indicate USB not ready */
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     48c:	08 95       	ret

0000048e <Ethernet_Task>:
	/* Task for Ethernet processing. Incoming ethernet frames are loaded into the FrameIN structure, and
	   outgoing frames should be loaded into the FrameOUT structure. Both structures can only hold a single
	   Ethernet frame at a time, so the FrameInBuffer bool is used to indicate when the buffers contain data. */

	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
     48e:	80 91 d8 13 	lds	r24, 0x13D8
     492:	84 30       	cpi	r24, 0x04	; 4
     494:	79 f4       	brne	.+30     	; 0x4b4 <Ethernet_Task+0x26>
	  return;

	/* Check if a frame has been written to the IN frame buffer */
	if (FrameIN.FrameLength)
     496:	80 91 29 07 	lds	r24, 0x0729
     49a:	90 91 2a 07 	lds	r25, 0x072A
     49e:	89 2b       	or	r24, r25
     4a0:	49 f0       	breq	.+18     	; 0x4b4 <Ethernet_Task+0x26>
     4a2:	8b b1       	in	r24, 0x0b	; 11
     4a4:	8f 70       	andi	r24, 0x0F	; 15
     4a6:	80 62       	ori	r24, 0x20	; 32
     4a8:	8b b9       	out	0x0b, r24	; 11
	{
		/* Indicate packet processing started */
		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		/* Process the ethernet frame - replace this with your own Ethernet handler code as desired */
		Ethernet_ProcessPacket();
     4aa:	13 d2       	rcall	.+1062   	; 0x8d2 <Ethernet_ProcessPacket>
     4ac:	8b b1       	in	r24, 0x0b	; 11
     4ae:	8f 70       	andi	r24, 0x0F	; 15
     4b0:	80 66       	ori	r24, 0x60	; 96
     4b2:	8b b9       	out	0x0b, r24	; 11
     4b4:	08 95       	ret

000004b6 <RNDIS_Task>:
/** Task to manage the sending and receiving of encapsulated RNDIS data and notifications. This removes the RNDIS
 *  wrapper from received Ethernet frames and places them in the FrameIN global buffer, or adds the RNDIS wrapper
 *  to a frame in the FrameOUT global before sending the buffer contents to the host.
 */
void RNDIS_Task(void)
{
     4b6:	df 93       	push	r29
     4b8:	cf 93       	push	r28
     4ba:	cd b7       	in	r28, 0x3d	; 61
     4bc:	de b7       	in	r29, 0x3e	; 62
     4be:	ac 97       	sbiw	r28, 0x2c	; 44
     4c0:	0f b6       	in	r0, 0x3f	; 63
     4c2:	f8 94       	cli
     4c4:	de bf       	out	0x3e, r29	; 62
     4c6:	0f be       	out	0x3f, r0	; 63
     4c8:	cd bf       	out	0x3d, r28	; 61
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     4ca:	83 e0       	ldi	r24, 0x03	; 3
     4cc:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     4d0:	80 91 e8 00 	lds	r24, 0x00E8
	/* Select the notification endpoint */
	Endpoint_SelectEndpoint(CDC_NOTIFICATION_EPNUM);

	/* Check if a message response is ready for the host */
	if (Endpoint_IsINReady() && ResponseReady)
     4d4:	80 ff       	sbrs	r24, 0
     4d6:	1c c0       	rjmp	.+56     	; 0x510 <RNDIS_Task+0x5a>
     4d8:	80 91 47 01 	lds	r24, 0x0147
     4dc:	88 23       	and	r24, r24
     4de:	c1 f0       	breq	.+48     	; 0x510 <RNDIS_Task+0x5a>
				.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
				.bRequest      = RNDIS_NOTIF_ResponseAvailable,
				.wValue        = 0,
				.wIndex        = 0,
				.wLength       = 0,
			};
     4e0:	de 01       	movw	r26, r28
     4e2:	11 96       	adiw	r26, 0x01	; 1
     4e4:	e0 e0       	ldi	r30, 0x00	; 0
     4e6:	f1 e0       	ldi	r31, 0x01	; 1
     4e8:	88 e0       	ldi	r24, 0x08	; 8
     4ea:	01 90       	ld	r0, Z+
     4ec:	0d 92       	st	X+, r0
     4ee:	81 50       	subi	r24, 0x01	; 1
     4f0:	e1 f7       	brne	.-8      	; 0x4ea <RNDIS_Task+0x34>

		/* Indicate that a message response is ready for the host */
		Endpoint_Write_Stream_LE(&Notification, sizeof(Notification), NULL);
     4f2:	ce 01       	movw	r24, r28
     4f4:	01 96       	adiw	r24, 0x01	; 1
     4f6:	68 e0       	ldi	r22, 0x08	; 8
     4f8:	70 e0       	ldi	r23, 0x00	; 0
     4fa:	40 e0       	ldi	r20, 0x00	; 0
     4fc:	50 e0       	ldi	r21, 0x00	; 0
     4fe:	0e 94 76 14 	call	0x28ec	; 0x28ec <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     502:	80 91 e8 00 	lds	r24, 0x00E8
     506:	8e 77       	andi	r24, 0x7E	; 126
     508:	80 93 e8 00 	sts	0x00E8, r24

		/* Finalize the stream transfer to send the last packet */
		Endpoint_ClearIN();

		/* Indicate a response is no longer ready */
		ResponseReady = false;
     50c:	10 92 47 01 	sts	0x0147, r1
	}

	/* Don't process the data endpoints until the system is in the data initialized state, and the buffer is free */
	if ((CurrRNDISState == RNDIS_Data_Initialized) && !(MessageHeader->MessageLength))
     510:	20 91 48 01 	lds	r18, 0x0148
     514:	22 30       	cpi	r18, 0x02	; 2
     516:	09 f0       	breq	.+2      	; 0x51a <RNDIS_Task+0x64>
     518:	95 c0       	rjmp	.+298    	; 0x644 <RNDIS_Task+0x18e>
     51a:	e0 91 44 01 	lds	r30, 0x0144
     51e:	f0 91 45 01 	lds	r31, 0x0145
     522:	84 81       	ldd	r24, Z+4	; 0x04
     524:	95 81       	ldd	r25, Z+5	; 0x05
     526:	a6 81       	ldd	r26, Z+6	; 0x06
     528:	b7 81       	ldd	r27, Z+7	; 0x07
     52a:	00 97       	sbiw	r24, 0x00	; 0
     52c:	a1 05       	cpc	r26, r1
     52e:	b1 05       	cpc	r27, r1
     530:	09 f0       	breq	.+2      	; 0x534 <RNDIS_Task+0x7e>
     532:	88 c0       	rjmp	.+272    	; 0x644 <RNDIS_Task+0x18e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     534:	20 93 e9 00 	sts	0x00E9, r18
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
     538:	80 91 e8 00 	lds	r24, 0x00E8

		/* Select the data OUT endpoint */
		Endpoint_SelectEndpoint(CDC_RX_EPNUM);

		/* Check if the data OUT endpoint contains data, and that the IN buffer is empty */
		if (Endpoint_IsOUTReceived() && !(FrameIN.FrameLength))
     53c:	82 ff       	sbrs	r24, 2
     53e:	32 c0       	rjmp	.+100    	; 0x5a4 <RNDIS_Task+0xee>
     540:	80 91 29 07 	lds	r24, 0x0729
     544:	90 91 2a 07 	lds	r25, 0x072A
     548:	89 2b       	or	r24, r25
     54a:	61 f5       	brne	.+88     	; 0x5a4 <RNDIS_Task+0xee>
		{
			/* Read in the packet message header */
			Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     54c:	ce 01       	movw	r24, r28
     54e:	01 96       	adiw	r24, 0x01	; 1
     550:	6c e2       	ldi	r22, 0x2C	; 44
     552:	70 e0       	ldi	r23, 0x00	; 0
     554:	40 e0       	ldi	r20, 0x00	; 0
     556:	50 e0       	ldi	r21, 0x00	; 0
     558:	0e 94 24 14 	call	0x2848	; 0x2848 <Endpoint_Read_Stream_LE>

			/* Stall the request if the data is too large */
			if (RNDISPacketHeader.DataLength > ETHERNET_FRAME_SIZE_MAX)
     55c:	2d 85       	ldd	r18, Y+13	; 0x0d
     55e:	3e 85       	ldd	r19, Y+14	; 0x0e
     560:	4f 85       	ldd	r20, Y+15	; 0x0f
     562:	58 89       	ldd	r21, Y+16	; 0x10
     564:	2d 3d       	cpi	r18, 0xDD	; 221
     566:	85 e0       	ldi	r24, 0x05	; 5
     568:	38 07       	cpc	r19, r24
     56a:	80 e0       	ldi	r24, 0x00	; 0
     56c:	48 07       	cpc	r20, r24
     56e:	80 e0       	ldi	r24, 0x00	; 0
     570:	58 07       	cpc	r21, r24
     572:	30 f0       	brcs	.+12     	; 0x580 <RNDIS_Task+0xca>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
     574:	80 91 eb 00 	lds	r24, 0x00EB
     578:	80 62       	ori	r24, 0x20	; 32
     57a:	80 93 eb 00 	sts	0x00EB, r24
     57e:	62 c0       	rjmp	.+196    	; 0x644 <RNDIS_Task+0x18e>
				Endpoint_StallTransaction();
				return;
			}

			/* Read in the Ethernet frame into the buffer */
			Endpoint_Read_Stream_LE(FrameIN.FrameData, RNDISPacketHeader.DataLength, NULL);
     580:	8d e4       	ldi	r24, 0x4D	; 77
     582:	91 e0       	ldi	r25, 0x01	; 1
     584:	b9 01       	movw	r22, r18
     586:	40 e0       	ldi	r20, 0x00	; 0
     588:	50 e0       	ldi	r21, 0x00	; 0
     58a:	0e 94 24 14 	call	0x2848	; 0x2848 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     58e:	80 91 e8 00 	lds	r24, 0x00E8
     592:	8b 77       	andi	r24, 0x7B	; 123
     594:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearOUT();

			/* Store the size of the Ethernet frame */
			FrameIN.FrameLength = RNDISPacketHeader.DataLength;
     598:	8d 85       	ldd	r24, Y+13	; 0x0d
     59a:	9e 85       	ldd	r25, Y+14	; 0x0e
     59c:	90 93 2a 07 	sts	0x072A, r25
     5a0:	80 93 29 07 	sts	0x0729, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
     5a4:	81 e0       	ldi	r24, 0x01	; 1
     5a6:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     5aa:	80 91 e8 00 	lds	r24, 0x00E8

		/* Select the data IN endpoint */
		Endpoint_SelectEndpoint(CDC_TX_EPNUM);

		/* Check if the data IN endpoint is ready for more data, and that the IN buffer is full */
		if (Endpoint_IsINReady() && FrameOUT.FrameLength)
     5ae:	80 ff       	sbrs	r24, 0
     5b0:	49 c0       	rjmp	.+146    	; 0x644 <RNDIS_Task+0x18e>
     5b2:	20 91 07 0d 	lds	r18, 0x0D07
     5b6:	30 91 08 0d 	lds	r19, 0x0D08
     5ba:	21 15       	cp	r18, r1
     5bc:	31 05       	cpc	r19, r1
     5be:	09 f4       	brne	.+2      	; 0x5c2 <RNDIS_Task+0x10c>
     5c0:	41 c0       	rjmp	.+130    	; 0x644 <RNDIS_Task+0x18e>
		{
			/* Clear the packet header with all 0s so that the relevant fields can be filled */
			memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
     5c2:	fe 01       	movw	r30, r28
     5c4:	31 96       	adiw	r30, 0x01	; 1
     5c6:	8c e2       	ldi	r24, 0x2C	; 44
     5c8:	df 01       	movw	r26, r30
     5ca:	1d 92       	st	X+, r1
     5cc:	8a 95       	dec	r24
     5ce:	e9 f7       	brne	.-6      	; 0x5ca <RNDIS_Task+0x114>

			/* Construct the required packet header fields in the buffer */
			RNDISPacketHeader.MessageType   = REMOTE_NDIS_PACKET_MSG;
     5d0:	81 e0       	ldi	r24, 0x01	; 1
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	a0 e0       	ldi	r26, 0x00	; 0
     5d6:	b0 e0       	ldi	r27, 0x00	; 0
     5d8:	89 83       	std	Y+1, r24	; 0x01
     5da:	9a 83       	std	Y+2, r25	; 0x02
     5dc:	ab 83       	std	Y+3, r26	; 0x03
     5de:	bc 83       	std	Y+4, r27	; 0x04
			RNDISPacketHeader.MessageLength = (sizeof(RNDIS_Packet_Message_t) + FrameOUT.FrameLength);
     5e0:	24 5d       	subi	r18, 0xD4	; 212
     5e2:	3f 4f       	sbci	r19, 0xFF	; 255
     5e4:	c9 01       	movw	r24, r18
     5e6:	a0 e0       	ldi	r26, 0x00	; 0
     5e8:	b0 e0       	ldi	r27, 0x00	; 0
     5ea:	2c 52       	subi	r18, 0x2C	; 44
     5ec:	30 40       	sbci	r19, 0x00	; 0
     5ee:	8d 83       	std	Y+5, r24	; 0x05
     5f0:	9e 83       	std	Y+6, r25	; 0x06
     5f2:	af 83       	std	Y+7, r26	; 0x07
     5f4:	b8 87       	std	Y+8, r27	; 0x08
			RNDISPacketHeader.DataOffset    = (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
     5f6:	84 e2       	ldi	r24, 0x24	; 36
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	a0 e0       	ldi	r26, 0x00	; 0
     5fc:	b0 e0       	ldi	r27, 0x00	; 0
     5fe:	89 87       	std	Y+9, r24	; 0x09
     600:	9a 87       	std	Y+10, r25	; 0x0a
     602:	ab 87       	std	Y+11, r26	; 0x0b
     604:	bc 87       	std	Y+12, r27	; 0x0c
			RNDISPacketHeader.DataLength    = FrameOUT.FrameLength;
     606:	c9 01       	movw	r24, r18
     608:	a0 e0       	ldi	r26, 0x00	; 0
     60a:	b0 e0       	ldi	r27, 0x00	; 0
     60c:	8d 87       	std	Y+13, r24	; 0x0d
     60e:	9e 87       	std	Y+14, r25	; 0x0e
     610:	af 87       	std	Y+15, r26	; 0x0f
     612:	b8 8b       	std	Y+16, r27	; 0x10

			/* Send the packet header to the host */
			Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
     614:	cf 01       	movw	r24, r30
     616:	6c e2       	ldi	r22, 0x2C	; 44
     618:	70 e0       	ldi	r23, 0x00	; 0
     61a:	40 e0       	ldi	r20, 0x00	; 0
     61c:	50 e0       	ldi	r21, 0x00	; 0
     61e:	0e 94 76 14 	call	0x28ec	; 0x28ec <Endpoint_Write_Stream_LE>

			/* Send the Ethernet frame data to the host */
			Endpoint_Write_Stream_LE(FrameOUT.FrameData, RNDISPacketHeader.DataLength, NULL);
     622:	6d 85       	ldd	r22, Y+13	; 0x0d
     624:	7e 85       	ldd	r23, Y+14	; 0x0e
     626:	8b e2       	ldi	r24, 0x2B	; 43
     628:	97 e0       	ldi	r25, 0x07	; 7
     62a:	40 e0       	ldi	r20, 0x00	; 0
     62c:	50 e0       	ldi	r21, 0x00	; 0
     62e:	0e 94 76 14 	call	0x28ec	; 0x28ec <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     632:	80 91 e8 00 	lds	r24, 0x00E8
     636:	8e 77       	andi	r24, 0x7E	; 126
     638:	80 93 e8 00 	sts	0x00E8, r24

			/* Finalize the stream transfer to send the last packet */
			Endpoint_ClearIN();

			/* Indicate Ethernet OUT buffer no longer full */
			FrameOUT.FrameLength = 0;
     63c:	10 92 08 0d 	sts	0x0D08, r1
     640:	10 92 07 0d 	sts	0x0D07, r1
		}
	}
}
     644:	ac 96       	adiw	r28, 0x2c	; 44
     646:	0f b6       	in	r0, 0x3f	; 63
     648:	f8 94       	cli
     64a:	de bf       	out	0x3e, r29	; 62
     64c:	0f be       	out	0x3f, r0	; 63
     64e:	cd bf       	out	0x3d, r28	; 61
     650:	cf 91       	pop	r28
     652:	df 91       	pop	r29
     654:	08 95       	ret

00000656 <EVENT_USB_Device_ControlRequest>:
 *  internally.
 */
void EVENT_USB_Device_ControlRequest(void)
{
	/* Process RNDIS class commands */
	switch (USB_ControlRequest.bRequest)
     656:	80 91 da 13 	lds	r24, 0x13DA
     65a:	88 23       	and	r24, r24
     65c:	21 f0       	breq	.+8      	; 0x666 <EVENT_USB_Device_ControlRequest+0x10>
     65e:	81 30       	cpi	r24, 0x01	; 1
     660:	09 f0       	breq	.+2      	; 0x664 <EVENT_USB_Device_ControlRequest+0xe>
     662:	50 c0       	rjmp	.+160    	; 0x704 <EVENT_USB_Device_ControlRequest+0xae>
     664:	19 c0       	rjmp	.+50     	; 0x698 <EVENT_USB_Device_ControlRequest+0x42>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
     666:	80 91 d9 13 	lds	r24, 0x13D9
     66a:	81 32       	cpi	r24, 0x21	; 33
     66c:	09 f0       	breq	.+2      	; 0x670 <EVENT_USB_Device_ControlRequest+0x1a>
     66e:	4a c0       	rjmp	.+148    	; 0x704 <EVENT_USB_Device_ControlRequest+0xae>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     670:	80 91 e8 00 	lds	r24, 0x00E8
     674:	87 7f       	andi	r24, 0xF7	; 247
     676:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();

				/* Read in the RNDIS message into the message buffer */
				Endpoint_Read_Control_Stream_LE(RNDISMessageBuffer, USB_ControlRequest.wLength);
     67a:	60 91 df 13 	lds	r22, 0x13DF
     67e:	70 91 e0 13 	lds	r23, 0x13E0
     682:	80 e5       	ldi	r24, 0x50	; 80
     684:	93 e1       	ldi	r25, 0x13	; 19
     686:	0e 94 82 13 	call	0x2704	; 0x2704 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     68a:	80 91 e8 00 	lds	r24, 0x00E8
     68e:	8e 77       	andi	r24, 0x7E	; 126
     690:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();

				/* Process the RNDIS message */
				ProcessRNDISControlMessage();
     694:	0c 94 a0 0e 	jmp	0x1d40	; 0x1d40 <ProcessRNDISControlMessage>
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
     698:	80 91 d9 13 	lds	r24, 0x13D9
     69c:	81 3a       	cpi	r24, 0xA1	; 161
     69e:	91 f5       	brne	.+100    	; 0x704 <EVENT_USB_Device_ControlRequest+0xae>
			{
				/* Check if a response to the last message is ready */
				if (!(MessageHeader->MessageLength))
     6a0:	e0 91 44 01 	lds	r30, 0x0144
     6a4:	f0 91 45 01 	lds	r31, 0x0145
     6a8:	84 81       	ldd	r24, Z+4	; 0x04
     6aa:	95 81       	ldd	r25, Z+5	; 0x05
     6ac:	a6 81       	ldd	r26, Z+6	; 0x06
     6ae:	b7 81       	ldd	r27, Z+7	; 0x07
     6b0:	00 97       	sbiw	r24, 0x00	; 0
     6b2:	a1 05       	cpc	r26, r1
     6b4:	b1 05       	cpc	r27, r1
     6b6:	51 f4       	brne	.+20     	; 0x6cc <EVENT_USB_Device_ControlRequest+0x76>
				{
					/* Set the response to a single 0x00 byte to indicate that no response is ready */
					RNDISMessageBuffer[0] = 0;
     6b8:	10 92 50 13 	sts	0x1350, r1
					MessageHeader->MessageLength = 1;
     6bc:	81 e0       	ldi	r24, 0x01	; 1
     6be:	90 e0       	ldi	r25, 0x00	; 0
     6c0:	a0 e0       	ldi	r26, 0x00	; 0
     6c2:	b0 e0       	ldi	r27, 0x00	; 0
     6c4:	84 83       	std	Z+4, r24	; 0x04
     6c6:	95 83       	std	Z+5, r25	; 0x05
     6c8:	a6 83       	std	Z+6, r26	; 0x06
     6ca:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     6cc:	80 91 e8 00 	lds	r24, 0x00E8
     6d0:	87 7f       	andi	r24, 0xF7	; 247
     6d2:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();

				/* Write the message response data to the endpoint */
				Endpoint_Write_Control_Stream_LE(RNDISMessageBuffer, MessageHeader->MessageLength);
     6d6:	e0 91 44 01 	lds	r30, 0x0144
     6da:	f0 91 45 01 	lds	r31, 0x0145
     6de:	64 81       	ldd	r22, Z+4	; 0x04
     6e0:	75 81       	ldd	r23, Z+5	; 0x05
     6e2:	80 e5       	ldi	r24, 0x50	; 80
     6e4:	93 e1       	ldi	r25, 0x13	; 19
     6e6:	0e 94 24 13 	call	0x2648	; 0x2648 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     6ea:	80 91 e8 00 	lds	r24, 0x00E8
     6ee:	8b 77       	andi	r24, 0x7B	; 123
     6f0:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				/* Reset the message header once again after transmission */
				MessageHeader->MessageLength = 0;
     6f4:	e0 91 44 01 	lds	r30, 0x0144
     6f8:	f0 91 45 01 	lds	r31, 0x0145
     6fc:	14 82       	std	Z+4, r1	; 0x04
     6fe:	15 82       	std	Z+5, r1	; 0x05
     700:	16 82       	std	Z+6, r1	; 0x06
     702:	17 82       	std	Z+7, r1	; 0x07
     704:	08 95       	ret

00000706 <EVENT_USB_Device_ConfigurationChanged>:

/** Event handler for the USB_ConfigurationChanged event. This is fired when the host sets the current configuration
 *  of the USB device after enumeration, and configures the RNDIS device endpoints and starts the relevant tasks.
 */
void EVENT_USB_Device_ConfigurationChanged(void)
{
     706:	ef 92       	push	r14
     708:	ff 92       	push	r15
     70a:	0f 93       	push	r16
     70c:	1f 93       	push	r17
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
     70e:	81 e0       	ldi	r24, 0x01	; 1
     710:	61 e8       	ldi	r22, 0x81	; 129
     712:	42 e3       	ldi	r20, 0x32	; 50
     714:	0e 94 73 11 	call	0x22e6	; 0x22e6 <Endpoint_ConfigureEndpoint_Prv>
     718:	08 2f       	mov	r16, r24
	                                            CDC_TXRX_EPSIZE, ENDPOINT_BANK_SINGLE);
	ConfigSuccess &= Endpoint_ConfigureEndpoint(CDC_NOTIFICATION_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,
	                                            CDC_NOTIFICATION_EPSIZE, ENDPOINT_BANK_SINGLE);

	/* Indicate endpoint configuration success or failure */
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     71a:	82 e0       	ldi	r24, 0x02	; 2
     71c:	60 e8       	ldi	r22, 0x80	; 128
     71e:	42 e3       	ldi	r20, 0x32	; 50
     720:	0e 94 73 11 	call	0x22e6	; 0x22e6 <Endpoint_ConfigureEndpoint_Prv>
     724:	e8 2e       	mov	r14, r24
     726:	83 e0       	ldi	r24, 0x03	; 3
     728:	61 ec       	ldi	r22, 0xC1	; 193
     72a:	42 e0       	ldi	r20, 0x02	; 2
     72c:	0e 94 73 11 	call	0x22e6	; 0x22e6 <Endpoint_ConfigureEndpoint_Prv>
     730:	10 e0       	ldi	r17, 0x00	; 0
     732:	ff 24       	eor	r15, r15
     734:	0e 21       	and	r16, r14
     736:	1f 21       	and	r17, r15
     738:	01 70       	andi	r16, 0x01	; 1
     73a:	10 70       	andi	r17, 0x00	; 0
     73c:	90 e0       	ldi	r25, 0x00	; 0
     73e:	08 23       	and	r16, r24
     740:	19 23       	and	r17, r25
     742:	01 2b       	or	r16, r17
     744:	11 f4       	brne	.+4      	; 0x74a <EVENT_USB_Device_ConfigurationChanged+0x44>
     746:	90 e9       	ldi	r25, 0x90	; 144
     748:	01 c0       	rjmp	.+2      	; 0x74c <EVENT_USB_Device_ConfigurationChanged+0x46>
     74a:	90 e6       	ldi	r25, 0x60	; 96
     74c:	8b b1       	in	r24, 0x0b	; 11
     74e:	8f 70       	andi	r24, 0x0F	; 15
     750:	98 2b       	or	r25, r24
     752:	9b b9       	out	0x0b, r25	; 11
}
     754:	1f 91       	pop	r17
     756:	0f 91       	pop	r16
     758:	ff 90       	pop	r15
     75a:	ef 90       	pop	r14
     75c:	08 95       	ret

0000075e <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     75e:	84 b7       	in	r24, 0x34	; 52
     760:	87 7f       	andi	r24, 0xF7	; 247
     762:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     764:	38 e1       	ldi	r19, 0x18	; 24
     766:	0f b6       	in	r0, 0x3f	; 63
     768:	f8 94       	cli
     76a:	30 93 60 00 	sts	0x0060, r19
     76e:	10 92 60 00 	sts	0x0060, r1
     772:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
     774:	80 e0       	ldi	r24, 0x00	; 0
     776:	90 e0       	ldi	r25, 0x00	; 0
     778:	20 e8       	ldi	r18, 0x80	; 128
     77a:	0f b6       	in	r0, 0x3f	; 63
     77c:	f8 94       	cli
     77e:	20 93 61 00 	sts	0x0061, r18
     782:	80 93 61 00 	sts	0x0061, r24
     786:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     788:	8a b1       	in	r24, 0x0a	; 10
     78a:	80 6f       	ori	r24, 0xF0	; 240
     78c:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     78e:	8b b1       	in	r24, 0x0b	; 11
     790:	8f 70       	andi	r24, 0x0F	; 15
     792:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     794:	83 e3       	ldi	r24, 0x33	; 51
     796:	90 e0       	ldi	r25, 0x00	; 0
     798:	90 93 cd 00 	sts	0x00CD, r25
     79c:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     7a0:	86 e0       	ldi	r24, 0x06	; 6
     7a2:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     7a6:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     7aa:	30 93 c9 00 	sts	0x00C9, r19

				DDRD  |= (1 << 3);
     7ae:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     7b0:	5a 9a       	sbi	0x0b, 2	; 11

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     7b2:	0e 94 44 12 	call	0x2488	; 0x2488 <USB_Init>
			static inline void Serial_CreateStream(FILE* Stream)
			{
				if (!(Stream))
				{
					Stream = &USARTSerialStream;
					stdin  = Stream;
     7b6:	e1 ee       	ldi	r30, 0xE1	; 225
     7b8:	f3 e1       	ldi	r31, 0x13	; 19
     7ba:	f0 93 f0 13 	sts	0x13F0, r31
     7be:	e0 93 ef 13 	sts	0x13EF, r30
					stdout = Stream;
     7c2:	f0 93 f2 13 	sts	0x13F2, r31
     7c6:	e0 93 f1 13 	sts	0x13F1, r30
				}
			
				*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
     7ca:	8e e0       	ldi	r24, 0x0E	; 14
     7cc:	df 01       	movw	r26, r30
     7ce:	1d 92       	st	X+, r1
     7d0:	8a 95       	dec	r24
     7d2:	e9 f7       	brne	.-6      	; 0x7ce <SetupHardware+0x70>
     7d4:	83 e0       	ldi	r24, 0x03	; 3
     7d6:	80 93 e4 13 	sts	0x13E4, r24
     7da:	8a e4       	ldi	r24, 0x4A	; 74
     7dc:	96 e1       	ldi	r25, 0x16	; 22
     7de:	90 93 ea 13 	sts	0x13EA, r25
     7e2:	80 93 e9 13 	sts	0x13E9, r24
     7e6:	84 e5       	ldi	r24, 0x54	; 84
     7e8:	96 e1       	ldi	r25, 0x16	; 22
     7ea:	90 93 ec 13 	sts	0x13EC, r25
     7ee:	80 93 eb 13 	sts	0x13EB, r24
	
	/* Create a stdio stream for the serial port for stdin and stdout */
	Serial_CreateStream(NULL);	
}
     7f2:	08 95       	ret

000007f4 <main>:
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
	SetupHardware();
     7f4:	b4 df       	rcall	.-152    	; 0x75e <SetupHardware>

	/* Webserver Initialization */
	TCP_Init();
     7f6:	1b d1       	rcall	.+566    	; 0xa2e <TCP_Init>
	Webserver_Init();
     7f8:	0e 94 99 0e 	call	0x1d32	; 0x1d32 <Webserver_Init>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     7fc:	8b b1       	in	r24, 0x0b	; 11
     7fe:	8f 70       	andi	r24, 0x0F	; 15
     800:	80 61       	ori	r24, 0x10	; 16
     802:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     804:	78 94       	sei

	for (;;)
	{
		Ethernet_Task();
     806:	43 de       	rcall	.-890    	; 0x48e <Ethernet_Task>
		TCP_Task();
     808:	12 d6       	rcall	.+3108   	; 0x142e <TCP_Task>
		RNDIS_Task();
     80a:	55 de       	rcall	.-854    	; 0x4b6 <RNDIS_Task>
		USB_USBTask();
     80c:	0e 94 37 16 	call	0x2c6e	; 0x2c6e <USB_USBTask>
     810:	fa cf       	rjmp	.-12     	; 0x806 <main+0x12>

00000812 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     812:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     814:	92 30       	cpi	r25, 0x02	; 2
     816:	49 f0       	breq	.+18     	; 0x82a <CALLBACK_USB_GetDescriptor+0x18>
     818:	93 30       	cpi	r25, 0x03	; 3
     81a:	61 f0       	breq	.+24     	; 0x834 <CALLBACK_USB_GetDescriptor+0x22>
     81c:	91 30       	cpi	r25, 0x01	; 1
     81e:	f9 f4       	brne	.+62     	; 0x85e <CALLBACK_USB_GetDescriptor+0x4c>
     820:	e8 e9       	ldi	r30, 0x98	; 152
     822:	f0 e0       	ldi	r31, 0x00	; 0
     824:	22 e1       	ldi	r18, 0x12	; 18
     826:	30 e0       	ldi	r19, 0x00	; 0
     828:	1e c0       	rjmp	.+60     	; 0x866 <CALLBACK_USB_GetDescriptor+0x54>
     82a:	ea ea       	ldi	r30, 0xAA	; 170
     82c:	f0 e0       	ldi	r31, 0x00	; 0
     82e:	2e e3       	ldi	r18, 0x3E	; 62
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	19 c0       	rjmp	.+50     	; 0x866 <CALLBACK_USB_GetDescriptor+0x54>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
     834:	81 30       	cpi	r24, 0x01	; 1
     836:	49 f0       	breq	.+18     	; 0x84a <CALLBACK_USB_GetDescriptor+0x38>
     838:	81 30       	cpi	r24, 0x01	; 1
     83a:	18 f0       	brcs	.+6      	; 0x842 <CALLBACK_USB_GetDescriptor+0x30>
     83c:	82 30       	cpi	r24, 0x02	; 2
     83e:	79 f4       	brne	.+30     	; 0x85e <CALLBACK_USB_GetDescriptor+0x4c>
     840:	08 c0       	rjmp	.+16     	; 0x852 <CALLBACK_USB_GetDescriptor+0x40>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     842:	e8 ee       	ldi	r30, 0xE8	; 232
     844:	f0 e0       	ldi	r31, 0x00	; 0
     846:	84 91       	lpm	r24, Z+
     848:	07 c0       	rjmp	.+14     	; 0x858 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     84a:	ec ee       	ldi	r30, 0xEC	; 236
     84c:	f0 e0       	ldi	r31, 0x00	; 0
     84e:	84 91       	lpm	r24, Z+
     850:	03 c0       	rjmp	.+6      	; 0x858 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     852:	e6 e0       	ldi	r30, 0x06	; 6
     854:	f1 e0       	ldi	r31, 0x01	; 1
     856:	84 91       	lpm	r24, Z+
     858:	28 2f       	mov	r18, r24
     85a:	30 e0       	ldi	r19, 0x00	; 0
     85c:	04 c0       	rjmp	.+8      	; 0x866 <CALLBACK_USB_GetDescriptor+0x54>
     85e:	e0 e0       	ldi	r30, 0x00	; 0
     860:	f0 e0       	ldi	r31, 0x00	; 0
     862:	20 e0       	ldi	r18, 0x00	; 0
     864:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     866:	ed 93       	st	X+, r30
     868:	fc 93       	st	X, r31
	return Size;
}
     86a:	c9 01       	movw	r24, r18
     86c:	08 95       	ret

0000086e <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     86e:	cf 93       	push	r28
     870:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     872:	76 95       	lsr	r23
     874:	67 95       	ror	r22
     876:	ec 01       	movw	r28, r24
     878:	e0 e0       	ldi	r30, 0x00	; 0
     87a:	f0 e0       	ldi	r31, 0x00	; 0
     87c:	20 e0       	ldi	r18, 0x00	; 0
     87e:	30 e0       	ldi	r19, 0x00	; 0
     880:	40 e0       	ldi	r20, 0x00	; 0
     882:	50 e0       	ldi	r21, 0x00	; 0
     884:	09 c0       	rjmp	.+18     	; 0x898 <Ethernet_Checksum16+0x2a>
	  Checksum += Words[CurrWord];
     886:	89 91       	ld	r24, Y+
     888:	99 91       	ld	r25, Y+
     88a:	a0 e0       	ldi	r26, 0x00	; 0
     88c:	b0 e0       	ldi	r27, 0x00	; 0
     88e:	28 0f       	add	r18, r24
     890:	39 1f       	adc	r19, r25
     892:	4a 1f       	adc	r20, r26
     894:	5b 1f       	adc	r21, r27
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     896:	31 96       	adiw	r30, 0x01	; 1
     898:	e6 17       	cp	r30, r22
     89a:	f7 07       	cpc	r31, r23
     89c:	a0 f3       	brcs	.-24     	; 0x886 <Ethernet_Checksum16+0x18>
     89e:	0b c0       	rjmp	.+22     	; 0x8b6 <Ethernet_Checksum16+0x48>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     8a0:	da 01       	movw	r26, r20
     8a2:	c9 01       	movw	r24, r18
     8a4:	a0 70       	andi	r26, 0x00	; 0
     8a6:	b0 70       	andi	r27, 0x00	; 0
     8a8:	9a 01       	movw	r18, r20
     8aa:	44 27       	eor	r20, r20
     8ac:	55 27       	eor	r21, r21
     8ae:	28 0f       	add	r18, r24
     8b0:	39 1f       	adc	r19, r25
     8b2:	4a 1f       	adc	r20, r26
     8b4:	5b 1f       	adc	r21, r27
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     8b6:	da 01       	movw	r26, r20
     8b8:	c9 01       	movw	r24, r18
     8ba:	80 70       	andi	r24, 0x00	; 0
     8bc:	90 70       	andi	r25, 0x00	; 0
     8be:	00 97       	sbiw	r24, 0x00	; 0
     8c0:	a1 05       	cpc	r26, r1
     8c2:	b1 05       	cpc	r27, r1
     8c4:	69 f7       	brne	.-38     	; 0x8a0 <Ethernet_Checksum16+0x32>
     8c6:	20 95       	com	r18
     8c8:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     8ca:	c9 01       	movw	r24, r18
     8cc:	df 91       	pop	r29
     8ce:	cf 91       	pop	r28
     8d0:	08 95       	ret

000008d2 <Ethernet_ProcessPacket>:

/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(void)
{
     8d2:	cf 93       	push	r28
     8d4:	df 93       	push	r29
	DecodeEthernetFrameHeader(FrameIN.FrameData);
     8d6:	cd e4       	ldi	r28, 0x4D	; 77
     8d8:	d1 e0       	ldi	r29, 0x01	; 1
     8da:	ce 01       	movw	r24, r28
     8dc:	68 d0       	rcall	.+208    	; 0x9ae <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     8de:	ce 01       	movw	r24, r28
     8e0:	68 e0       	ldi	r22, 0x08	; 8
     8e2:	71 e0       	ldi	r23, 0x01	; 1
     8e4:	46 e0       	ldi	r20, 0x06	; 6
     8e6:	50 e0       	ldi	r21, 0x00	; 0
     8e8:	0e 94 90 16 	call	0x2d20	; 0x2d20 <memcmp>
     8ec:	00 97       	sbiw	r24, 0x00	; 0
     8ee:	51 f0       	breq	.+20     	; 0x904 <Ethernet_ProcessPacket+0x32>
     8f0:	ce 01       	movw	r24, r28
     8f2:	62 e1       	ldi	r22, 0x12	; 18
     8f4:	71 e0       	ldi	r23, 0x01	; 1
     8f6:	46 e0       	ldi	r20, 0x06	; 6
     8f8:	50 e0       	ldi	r21, 0x00	; 0
     8fa:	0e 94 90 16 	call	0x2d20	; 0x2d20 <memcmp>
     8fe:	00 97       	sbiw	r24, 0x00	; 0
     900:	09 f0       	breq	.+2      	; 0x904 <Ethernet_ProcessPacket+0x32>
     902:	4e c0       	rjmp	.+156    	; 0x9a0 <Ethernet_ProcessPacket+0xce>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     904:	80 91 29 07 	lds	r24, 0x0729
     908:	90 91 2a 07 	lds	r25, 0x072A

				Temp = Data.Bytes[0];
     90c:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
     90e:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
     910:	92 2f       	mov	r25, r18
     912:	81 50       	subi	r24, 0x01	; 1
     914:	96 40       	sbci	r25, 0x06	; 6
     916:	08 f4       	brcc	.+2      	; 0x91a <Ethernet_ProcessPacket+0x48>
     918:	43 c0       	rjmp	.+134    	; 0x9a0 <Ethernet_ProcessPacket+0xce>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     91a:	20 91 59 01 	lds	r18, 0x0159
     91e:	30 91 5a 01 	lds	r19, 0x015A

				Temp = Data.Bytes[0];
     922:	82 2f       	mov	r24, r18
				Data.Bytes[0] = Data.Bytes[1];
     924:	23 2f       	mov	r18, r19
				Data.Bytes[1] = Temp;
     926:	38 2f       	mov	r19, r24
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		(SwapEndian_16(FrameIN.FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     928:	88 e0       	ldi	r24, 0x08	; 8
     92a:	20 30       	cpi	r18, 0x00	; 0
     92c:	38 07       	cpc	r19, r24
     92e:	51 f0       	breq	.+20     	; 0x944 <Ethernet_ProcessPacket+0x72>
     930:	26 50       	subi	r18, 0x06	; 6
     932:	38 40       	sbci	r19, 0x08	; 8
     934:	a9 f5       	brne	.+106    	; 0x9a0 <Ethernet_ProcessPacket+0xce>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     936:	8b e5       	ldi	r24, 0x5B	; 91
     938:	91 e0       	ldi	r25, 0x01	; 1
     93a:	69 e3       	ldi	r22, 0x39	; 57
     93c:	77 e0       	ldi	r23, 0x07	; 7
     93e:	0e 94 ae 0c 	call	0x195c	; 0x195c <ARP_ProcessARPPacket>
     942:	06 c0       	rjmp	.+12     	; 0x950 <Ethernet_ProcessPacket+0x7e>
				                               &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(&FrameIN.FrameData[sizeof(Ethernet_Frame_Header_t)],
     944:	8b e5       	ldi	r24, 0x5B	; 91
     946:	91 e0       	ldi	r25, 0x01	; 1
     948:	69 e3       	ldi	r22, 0x39	; 57
     94a:	77 e0       	ldi	r23, 0x07	; 7
     94c:	0e 94 2c 0d 	call	0x1a58	; 0x1a58 <IP_ProcessIPPacket>
     950:	9c 01       	movw	r18, r24
				                             &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     952:	18 16       	cp	r1, r24
     954:	19 06       	cpc	r1, r25
     956:	0c f5       	brge	.+66     	; 0x99a <Ethernet_ProcessPacket+0xc8>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     958:	a1 e3       	ldi	r26, 0x31	; 49
     95a:	b7 e0       	ldi	r27, 0x07	; 7
     95c:	e8 e0       	ldi	r30, 0x08	; 8
     95e:	f1 e0       	ldi	r31, 0x01	; 1
     960:	86 e0       	ldi	r24, 0x06	; 6
     962:	01 90       	ld	r0, Z+
     964:	0d 92       	st	X+, r0
     966:	81 50       	subi	r24, 0x01	; 1
     968:	e1 f7       	brne	.-8      	; 0x962 <Ethernet_ProcessPacket+0x90>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     96a:	ab e2       	ldi	r26, 0x2B	; 43
     96c:	b7 e0       	ldi	r27, 0x07	; 7
     96e:	e3 e5       	ldi	r30, 0x53	; 83
     970:	f1 e0       	ldi	r31, 0x01	; 1
     972:	86 e0       	ldi	r24, 0x06	; 6
     974:	01 90       	ld	r0, Z+
     976:	0d 92       	st	X+, r0
     978:	81 50       	subi	r24, 0x01	; 1
     97a:	e1 f7       	brne	.-8      	; 0x974 <Ethernet_ProcessPacket+0xa2>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     97c:	80 91 59 01 	lds	r24, 0x0159
     980:	90 91 5a 01 	lds	r25, 0x015A
     984:	90 93 38 07 	sts	0x0738, r25
     988:	80 93 37 07 	sts	0x0737, r24

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     98c:	22 5f       	subi	r18, 0xF2	; 242
     98e:	3f 4f       	sbci	r19, 0xFF	; 255
     990:	30 93 08 0d 	sts	0x0D08, r19
     994:	20 93 07 0d 	sts	0x0D07, r18
     998:	03 c0       	rjmp	.+6      	; 0x9a0 <Ethernet_ProcessPacket+0xce>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     99a:	2f 5f       	subi	r18, 0xFF	; 255
     99c:	3f 4f       	sbci	r19, 0xFF	; 255
     99e:	21 f0       	breq	.+8      	; 0x9a8 <Ethernet_ProcessPacket+0xd6>
	{
		/* Clear the frame buffer */
		FrameIN.FrameLength = 0;
     9a0:	10 92 2a 07 	sts	0x072A, r1
     9a4:	10 92 29 07 	sts	0x0729, r1
	}
}
     9a8:	df 91       	pop	r29
     9aa:	cf 91       	pop	r28
     9ac:	08 95       	ret

000009ae <DecodeEthernetFrameHeader>:
	                                                                     FrameHeader->Destination.Octets[4],
	                                                                     FrameHeader->Destination.Octets[5]);

	printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	#endif
}
     9ae:	08 95       	ret

000009b0 <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     9b0:	08 95       	ret

000009b2 <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     9b2:	08 95       	ret

000009b4 <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     9b4:	08 95       	ret

000009b6 <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     9b6:	08 95       	ret

000009b8 <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     9b8:	08 95       	ret

000009ba <DecodeDHCPHeader>:
		}

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}
	#endif
}
     9ba:	08 95       	ret

000009bc <ICMP_ProcessICMPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(void* InDataStart,
                               void* OutDataStart)
{
     9bc:	0f 93       	push	r16
     9be:	1f 93       	push	r17
     9c0:	cf 93       	push	r28
     9c2:	df 93       	push	r29
     9c4:	8c 01       	movw	r16, r24
     9c6:	eb 01       	movw	r28, r22
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     9c8:	f5 df       	rcall	.-22     	; 0x9b4 <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     9ca:	f8 01       	movw	r30, r16
     9cc:	80 81       	ld	r24, Z
     9ce:	88 30       	cpi	r24, 0x08	; 8
     9d0:	19 f0       	breq	.+6      	; 0x9d8 <ICMP_ProcessICMPPacket+0x1c>
     9d2:	20 e0       	ldi	r18, 0x00	; 0
     9d4:	30 e0       	ldi	r19, 0x00	; 0
     9d6:	25 c0       	rjmp	.+74     	; 0xa22 <ICMP_ProcessICMPPacket+0x66>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     9d8:	18 82       	st	Y, r1
		ICMPHeaderOUT->Code     = 0;
     9da:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     9dc:	1b 82       	std	Y+3, r1	; 0x03
     9de:	1a 82       	std	Y+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     9e0:	f8 01       	movw	r30, r16
     9e2:	84 81       	ldd	r24, Z+4	; 0x04
     9e4:	95 81       	ldd	r25, Z+5	; 0x05
     9e6:	9d 83       	std	Y+5, r25	; 0x05
     9e8:	8c 83       	std	Y+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     9ea:	86 81       	ldd	r24, Z+6	; 0x06
     9ec:	97 81       	ldd	r25, Z+7	; 0x07
     9ee:	9f 83       	std	Y+7, r25	; 0x07
     9f0:	8e 83       	std	Y+6, r24	; 0x06

		intptr_t DataSize = FrameIN.FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN.FrameData));
     9f2:	b8 01       	movw	r22, r16
     9f4:	68 5f       	subi	r22, 0xF8	; 248
     9f6:	7f 4f       	sbci	r23, 0xFF	; 255
     9f8:	00 91 29 07 	lds	r16, 0x0729
     9fc:	10 91 2a 07 	lds	r17, 0x072A
     a00:	03 5b       	subi	r16, 0xB3	; 179
     a02:	1e 4f       	sbci	r17, 0xFE	; 254
     a04:	06 1b       	sub	r16, r22
     a06:	17 0b       	sbc	r17, r23

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     a08:	ce 01       	movw	r24, r28
     a0a:	08 96       	adiw	r24, 0x08	; 8
     a0c:	a8 01       	movw	r20, r16
     a0e:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     a12:	08 5f       	subi	r16, 0xF8	; 248
     a14:	1f 4f       	sbci	r17, 0xFF	; 255
     a16:	ce 01       	movw	r24, r28
     a18:	b8 01       	movw	r22, r16
     a1a:	29 df       	rcall	.-430    	; 0x86e <Ethernet_Checksum16>
     a1c:	9b 83       	std	Y+3, r25	; 0x03
     a1e:	8a 83       	std	Y+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     a20:	98 01       	movw	r18, r16
	}

	return NO_RESPONSE;
}
     a22:	c9 01       	movw	r24, r18
     a24:	df 91       	pop	r29
     a26:	cf 91       	pop	r28
     a28:	1f 91       	pop	r17
     a2a:	0f 91       	pop	r16
     a2c:	08 95       	ret

00000a2e <TCP_Init>:
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
     a2e:	10 92 4d 13 	sts	0x134D, r1

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     a32:	8a e0       	ldi	r24, 0x0A	; 10
     a34:	80 93 1e 0f 	sts	0x0F1E, r24
     a38:	80 93 34 11 	sts	0x1134, r24
     a3c:	80 93 4a 13 	sts	0x134A, r24
}
     a40:	08 95       	ret

00000a42 <TCP_SetPortState>:
 *  \return Boolean true if the port state was set, false otherwise (no more space in the port state table)
 */
bool TCP_SetPortState(const uint16_t Port,
                      const uint8_t State,
                      void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
{
     a42:	9c 01       	movw	r18, r24

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     a44:	80 91 4b 13 	lds	r24, 0x134B
     a48:	90 91 4c 13 	lds	r25, 0x134C
     a4c:	82 17       	cp	r24, r18
     a4e:	93 07       	cpc	r25, r19
     a50:	39 f4       	brne	.+14     	; 0xa60 <TCP_SetPortState+0x1e>
		{
			PortStateTable[PTableEntry].State = State;
     a52:	60 93 4d 13 	sts	0x134D, r22
			PortStateTable[PTableEntry].ApplicationHandler = Handler;
     a56:	50 93 4f 13 	sts	0x134F, r21
     a5a:	40 93 4e 13 	sts	0x134E, r20
     a5e:	02 c0       	rjmp	.+4      	; 0xa64 <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     a60:	61 30       	cpi	r22, 0x01	; 1
     a62:	11 f0       	breq	.+4      	; 0xa68 <TCP_SetPortState+0x26>
     a64:	81 e0       	ldi	r24, 0x01	; 1
     a66:	08 95       	ret
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     a68:	80 91 4d 13 	lds	r24, 0x134D
     a6c:	88 23       	and	r24, r24
     a6e:	11 f0       	breq	.+4      	; 0xa74 <TCP_SetPortState+0x32>
     a70:	80 e0       	ldi	r24, 0x00	; 0
     a72:	08 95       	ret
			{
				PortStateTable[PTableEntry].Port  = Port;
     a74:	30 93 4c 13 	sts	0x134C, r19
     a78:	20 93 4b 13 	sts	0x134B, r18
				PortStateTable[PTableEntry].State = State;
     a7c:	60 93 4d 13 	sts	0x134D, r22
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     a80:	50 93 4f 13 	sts	0x134F, r21
     a84:	40 93 4e 13 	sts	0x134E, r20
     a88:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     a8a:	08 95       	ret

00000a8c <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     a8c:	20 91 4b 13 	lds	r18, 0x134B
     a90:	30 91 4c 13 	lds	r19, 0x134C
     a94:	28 17       	cp	r18, r24
     a96:	39 07       	cpc	r19, r25
     a98:	11 f0       	breq	.+4      	; 0xa9e <TCP_GetPortState+0x12>
     a9a:	80 e0       	ldi	r24, 0x00	; 0
     a9c:	08 95       	ret
		  return PortStateTable[PTableEntry].State;
     a9e:	80 91 4d 13 	lds	r24, 0x134D
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
}
     aa2:	08 95       	ret

00000aa4 <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     aa4:	36 2f       	mov	r19, r22
     aa6:	27 2f       	mov	r18, r23
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     aa8:	69 2f       	mov	r22, r25
     aaa:	78 2f       	mov	r23, r24
     aac:	c9 01       	movw	r24, r18
     aae:	08 95       	ret

00000ab0 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t SourceAddress,
                               const IP_Address_t DestinationAddress,
                               uint16_t TCPOutSize)
{
     ab0:	4f 92       	push	r4
     ab2:	5f 92       	push	r5
     ab4:	6f 92       	push	r6
     ab6:	7f 92       	push	r7
     ab8:	8f 92       	push	r8
     aba:	9f 92       	push	r9
     abc:	af 92       	push	r10
     abe:	bf 92       	push	r11
     ac0:	cf 92       	push	r12
     ac2:	df 92       	push	r13
     ac4:	ef 92       	push	r14
     ac6:	ff 92       	push	r15
     ac8:	0f 93       	push	r16
     aca:	1f 93       	push	r17
     acc:	df 93       	push	r29
     ace:	cf 93       	push	r28
     ad0:	cd b7       	in	r28, 0x3d	; 61
     ad2:	de b7       	in	r29, 0x3e	; 62
     ad4:	28 97       	sbiw	r28, 0x08	; 8
     ad6:	0f b6       	in	r0, 0x3f	; 63
     ad8:	f8 94       	cli
     ada:	de bf       	out	0x3e, r29	; 62
     adc:	0f be       	out	0x3f, r0	; 63
     ade:	cd bf       	out	0x3d, r28	; 61
     ae0:	2c 01       	movw	r4, r24
     ae2:	fa 01       	movw	r30, r20
     ae4:	49 83       	std	Y+1, r20	; 0x01
     ae6:	5a 83       	std	Y+2, r21	; 0x02
     ae8:	6b 83       	std	Y+3, r22	; 0x03
     aea:	7c 83       	std	Y+4, r23	; 0x04
     aec:	a8 01       	movw	r20, r16
     aee:	0d 83       	std	Y+5, r16	; 0x05
     af0:	1e 83       	std	Y+6, r17	; 0x06
     af2:	2f 83       	std	Y+7, r18	; 0x07
     af4:	38 87       	std	Y+8, r19	; 0x08
     af6:	37 01       	movw	r6, r14

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     af8:	0b 81       	ldd	r16, Y+3	; 0x03
     afa:	1c 81       	ldd	r17, Y+4	; 0x04
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     afc:	cf 80       	ldd	r12, Y+7	; 0x07
     afe:	d8 84       	ldd	r13, Y+8	; 0x08
				} Data;

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
     b00:	87 2d       	mov	r24, r7
				Data.Bytes[1] = Temp;
     b02:	9e 2d       	mov	r25, r14

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     b04:	4f 01       	movw	r8, r30
     b06:	aa 24       	eor	r10, r10
     b08:	bb 24       	eor	r11, r11
     b0a:	60 e0       	ldi	r22, 0x00	; 0
     b0c:	70 e0       	ldi	r23, 0x00	; 0
     b0e:	84 0e       	add	r8, r20
     b10:	95 1e       	adc	r9, r21
     b12:	a6 1e       	adc	r10, r22
     b14:	b7 1e       	adc	r11, r23
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     b16:	20 e0       	ldi	r18, 0x00	; 0
     b18:	36 e0       	ldi	r19, 0x06	; 6
     b1a:	40 e0       	ldi	r20, 0x00	; 0
     b1c:	50 e0       	ldi	r21, 0x00	; 0
     b1e:	82 0e       	add	r8, r18
     b20:	93 1e       	adc	r9, r19
     b22:	a4 1e       	adc	r10, r20
     b24:	b5 1e       	adc	r11, r21
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     b26:	20 e0       	ldi	r18, 0x00	; 0
     b28:	30 e0       	ldi	r19, 0x00	; 0
     b2a:	80 0e       	add	r8, r16
     b2c:	91 1e       	adc	r9, r17
     b2e:	a2 1e       	adc	r10, r18
     b30:	b3 1e       	adc	r11, r19
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     b32:	ee 24       	eor	r14, r14
     b34:	ff 24       	eor	r15, r15
     b36:	8c 0c       	add	r8, r12
     b38:	9d 1c       	adc	r9, r13
     b3a:	ae 1c       	adc	r10, r14
     b3c:	bf 1c       	adc	r11, r15
	Checksum += SwapEndian_16(TCPOutSize);
     b3e:	a0 e0       	ldi	r26, 0x00	; 0
     b40:	b0 e0       	ldi	r27, 0x00	; 0
     b42:	88 0e       	add	r8, r24
     b44:	99 1e       	adc	r9, r25
     b46:	aa 1e       	adc	r10, r26
     b48:	bb 1e       	adc	r11, r27

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     b4a:	f3 01       	movw	r30, r6
     b4c:	f6 95       	lsr	r31
     b4e:	e7 95       	ror	r30
     b50:	a2 01       	movw	r20, r4
     b52:	20 e0       	ldi	r18, 0x00	; 0
     b54:	30 e0       	ldi	r19, 0x00	; 0
     b56:	0c c0       	rjmp	.+24     	; 0xb70 <TCP_Checksum16+0xc0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     b58:	da 01       	movw	r26, r20
     b5a:	8d 91       	ld	r24, X+
     b5c:	9d 91       	ld	r25, X+
     b5e:	ad 01       	movw	r20, r26
     b60:	a0 e0       	ldi	r26, 0x00	; 0
     b62:	b0 e0       	ldi	r27, 0x00	; 0
     b64:	88 0e       	add	r8, r24
     b66:	99 1e       	adc	r9, r25
     b68:	aa 1e       	adc	r10, r26
     b6a:	bb 1e       	adc	r11, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     b6c:	2f 5f       	subi	r18, 0xFF	; 255
     b6e:	3f 4f       	sbci	r19, 0xFF	; 255
     b70:	2e 17       	cp	r18, r30
     b72:	3f 07       	cpc	r19, r31
     b74:	88 f3       	brcs	.-30     	; 0xb58 <TCP_Checksum16+0xa8>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     b76:	60 fe       	sbrs	r6, 0
     b78:	15 c0       	rjmp	.+42     	; 0xba4 <TCP_Checksum16+0xf4>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     b7a:	ee 0f       	add	r30, r30
     b7c:	ff 1f       	adc	r31, r31
     b7e:	e4 0d       	add	r30, r4
     b80:	f5 1d       	adc	r31, r5
     b82:	80 81       	ld	r24, Z
     b84:	88 0e       	add	r8, r24
     b86:	91 1c       	adc	r9, r1
     b88:	a1 1c       	adc	r10, r1
     b8a:	b1 1c       	adc	r11, r1
     b8c:	0b c0       	rjmp	.+22     	; 0xba4 <TCP_Checksum16+0xf4>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     b8e:	d5 01       	movw	r26, r10
     b90:	c4 01       	movw	r24, r8
     b92:	a0 70       	andi	r26, 0x00	; 0
     b94:	b0 70       	andi	r27, 0x00	; 0
     b96:	45 01       	movw	r8, r10
     b98:	aa 24       	eor	r10, r10
     b9a:	bb 24       	eor	r11, r11
     b9c:	88 0e       	add	r8, r24
     b9e:	99 1e       	adc	r9, r25
     ba0:	aa 1e       	adc	r10, r26
     ba2:	bb 1e       	adc	r11, r27
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     ba4:	d5 01       	movw	r26, r10
     ba6:	c4 01       	movw	r24, r8
     ba8:	80 70       	andi	r24, 0x00	; 0
     baa:	90 70       	andi	r25, 0x00	; 0
     bac:	00 97       	sbiw	r24, 0x00	; 0
     bae:	a1 05       	cpc	r26, r1
     bb0:	b1 05       	cpc	r27, r1
     bb2:	69 f7       	brne	.-38     	; 0xb8e <TCP_Checksum16+0xde>
     bb4:	94 01       	movw	r18, r8
     bb6:	20 95       	com	r18
     bb8:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     bba:	c9 01       	movw	r24, r18
     bbc:	28 96       	adiw	r28, 0x08	; 8
     bbe:	0f b6       	in	r0, 0x3f	; 63
     bc0:	f8 94       	cli
     bc2:	de bf       	out	0x3e, r29	; 62
     bc4:	0f be       	out	0x3f, r0	; 63
     bc6:	cd bf       	out	0x3d, r28	; 61
     bc8:	cf 91       	pop	r28
     bca:	df 91       	pop	r29
     bcc:	1f 91       	pop	r17
     bce:	0f 91       	pop	r16
     bd0:	ff 90       	pop	r15
     bd2:	ef 90       	pop	r14
     bd4:	df 90       	pop	r13
     bd6:	cf 90       	pop	r12
     bd8:	bf 90       	pop	r11
     bda:	af 90       	pop	r10
     bdc:	9f 90       	pop	r9
     bde:	8f 90       	pop	r8
     be0:	7f 90       	pop	r7
     be2:	6f 90       	pop	r6
     be4:	5f 90       	pop	r5
     be6:	4f 90       	pop	r4
     be8:	08 95       	ret

00000bea <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
     bea:	4f 92       	push	r4
     bec:	5f 92       	push	r5
     bee:	6f 92       	push	r6
     bf0:	7f 92       	push	r7
     bf2:	8f 92       	push	r8
     bf4:	9f 92       	push	r9
     bf6:	af 92       	push	r10
     bf8:	bf 92       	push	r11
     bfa:	cf 92       	push	r12
     bfc:	df 92       	push	r13
     bfe:	ef 92       	push	r14
     c00:	ff 92       	push	r15
     c02:	0f 93       	push	r16
     c04:	1f 93       	push	r17
     c06:	df 93       	push	r29
     c08:	cf 93       	push	r28
     c0a:	00 d0       	rcall	.+0      	; 0xc0c <TCP_GetConnectionInfo+0x22>
     c0c:	00 d0       	rcall	.+0      	; 0xc0e <TCP_GetConnectionInfo+0x24>
     c0e:	cd b7       	in	r28, 0x3d	; 61
     c10:	de b7       	in	r29, 0x3e	; 62
     c12:	4c 01       	movw	r8, r24
     c14:	49 83       	std	Y+1, r20	; 0x01
     c16:	5a 83       	std	Y+2, r21	; 0x02
     c18:	6b 83       	std	Y+3, r22	; 0x03
     c1a:	7c 83       	std	Y+4, r23	; 0x04
     c1c:	59 01       	movw	r10, r18
     c1e:	69 e0       	ldi	r22, 0x09	; 9
     c20:	e6 2e       	mov	r14, r22
     c22:	6d e0       	ldi	r22, 0x0D	; 13
     c24:	f6 2e       	mov	r15, r22
     c26:	00 e0       	ldi	r16, 0x00	; 0
     c28:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     c2a:	56 e1       	ldi	r21, 0x16	; 22
     c2c:	45 2e       	mov	r4, r21
     c2e:	52 e0       	ldi	r21, 0x02	; 2
     c30:	55 2e       	mov	r5, r21
     c32:	3e 01       	movw	r6, r28
     c34:	08 94       	sec
     c36:	61 1c       	adc	r6, r1
     c38:	71 1c       	adc	r7, r1
     c3a:	f7 01       	movw	r30, r14
     c3c:	80 81       	ld	r24, Z
     c3e:	91 81       	ldd	r25, Z+1	; 0x01
     c40:	88 15       	cp	r24, r8
     c42:	99 05       	cpc	r25, r9
     c44:	d9 f4       	brne	.+54     	; 0xc7c <TCP_GetConnectionInfo+0x92>
     c46:	04 9d       	mul	r16, r4
     c48:	60 01       	movw	r12, r0
     c4a:	05 9d       	mul	r16, r5
     c4c:	d0 0c       	add	r13, r0
     c4e:	14 9d       	mul	r17, r4
     c50:	d0 0c       	add	r13, r0
     c52:	11 24       	eor	r1, r1
     c54:	c6 01       	movw	r24, r12
     c56:	83 5f       	subi	r24, 0xF3	; 243
     c58:	92 4f       	sbci	r25, 0xF2	; 242
     c5a:	b3 01       	movw	r22, r6
     c5c:	44 e0       	ldi	r20, 0x04	; 4
     c5e:	50 e0       	ldi	r21, 0x00	; 0
     c60:	0e 94 90 16 	call	0x2d20	; 0x2d20 <memcmp>
     c64:	00 97       	sbiw	r24, 0x00	; 0
     c66:	51 f4       	brne	.+20     	; 0xc7c <TCP_GetConnectionInfo+0x92>
     c68:	f7 01       	movw	r30, r14
     c6a:	82 81       	ldd	r24, Z+2	; 0x02
     c6c:	93 81       	ldd	r25, Z+3	; 0x03
     c6e:	8a 15       	cp	r24, r10
     c70:	9b 05       	cpc	r25, r11
     c72:	21 f4       	brne	.+8      	; 0xc7c <TCP_GetConnectionInfo+0x92>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     c74:	96 01       	movw	r18, r12
     c76:	2f 5e       	subi	r18, 0xEF	; 239
     c78:	32 4f       	sbci	r19, 0xF2	; 242
     c7a:	0b c0       	rjmp	.+22     	; 0xc92 <TCP_GetConnectionInfo+0xa8>
     c7c:	0f 5f       	subi	r16, 0xFF	; 255
     c7e:	1f 4f       	sbci	r17, 0xFF	; 255
     c80:	86 e1       	ldi	r24, 0x16	; 22
     c82:	92 e0       	ldi	r25, 0x02	; 2
     c84:	e8 0e       	add	r14, r24
     c86:	f9 1e       	adc	r15, r25
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     c88:	03 30       	cpi	r16, 0x03	; 3
     c8a:	11 05       	cpc	r17, r1
     c8c:	b1 f6       	brne	.-84     	; 0xc3a <TCP_GetConnectionInfo+0x50>
     c8e:	20 e0       	ldi	r18, 0x00	; 0
     c90:	30 e0       	ldi	r19, 0x00	; 0
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
}
     c92:	c9 01       	movw	r24, r18
     c94:	0f 90       	pop	r0
     c96:	0f 90       	pop	r0
     c98:	0f 90       	pop	r0
     c9a:	0f 90       	pop	r0
     c9c:	cf 91       	pop	r28
     c9e:	df 91       	pop	r29
     ca0:	1f 91       	pop	r17
     ca2:	0f 91       	pop	r16
     ca4:	ff 90       	pop	r15
     ca6:	ef 90       	pop	r14
     ca8:	df 90       	pop	r13
     caa:	cf 90       	pop	r12
     cac:	bf 90       	pop	r11
     cae:	af 90       	pop	r10
     cb0:	9f 90       	pop	r9
     cb2:	8f 90       	pop	r8
     cb4:	7f 90       	pop	r7
     cb6:	6f 90       	pop	r6
     cb8:	5f 90       	pop	r5
     cba:	4f 90       	pop	r4
     cbc:	08 95       	ret

00000cbe <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
     cbe:	4f 92       	push	r4
     cc0:	5f 92       	push	r5
     cc2:	6f 92       	push	r6
     cc4:	7f 92       	push	r7
     cc6:	8f 92       	push	r8
     cc8:	9f 92       	push	r9
     cca:	af 92       	push	r10
     ccc:	bf 92       	push	r11
     cce:	cf 92       	push	r12
     cd0:	df 92       	push	r13
     cd2:	ef 92       	push	r14
     cd4:	ff 92       	push	r15
     cd6:	0f 93       	push	r16
     cd8:	1f 93       	push	r17
     cda:	df 93       	push	r29
     cdc:	cf 93       	push	r28
     cde:	00 d0       	rcall	.+0      	; 0xce0 <TCP_GetConnectionState+0x22>
     ce0:	00 d0       	rcall	.+0      	; 0xce2 <TCP_GetConnectionState+0x24>
     ce2:	cd b7       	in	r28, 0x3d	; 61
     ce4:	de b7       	in	r29, 0x3e	; 62
     ce6:	4c 01       	movw	r8, r24
     ce8:	49 83       	std	Y+1, r20	; 0x01
     cea:	5a 83       	std	Y+2, r21	; 0x02
     cec:	6b 83       	std	Y+3, r22	; 0x03
     cee:	7c 83       	std	Y+4, r23	; 0x04
     cf0:	59 01       	movw	r10, r18
     cf2:	e9 e0       	ldi	r30, 0x09	; 9
     cf4:	ee 2e       	mov	r14, r30
     cf6:	ed e0       	ldi	r30, 0x0D	; 13
     cf8:	fe 2e       	mov	r15, r30
     cfa:	00 e0       	ldi	r16, 0x00	; 0
     cfc:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     cfe:	76 e1       	ldi	r23, 0x16	; 22
     d00:	47 2e       	mov	r4, r23
     d02:	72 e0       	ldi	r23, 0x02	; 2
     d04:	57 2e       	mov	r5, r23
     d06:	3e 01       	movw	r6, r28
     d08:	08 94       	sec
     d0a:	61 1c       	adc	r6, r1
     d0c:	71 1c       	adc	r7, r1
     d0e:	f7 01       	movw	r30, r14
     d10:	80 81       	ld	r24, Z
     d12:	91 81       	ldd	r25, Z+1	; 0x01
     d14:	88 15       	cp	r24, r8
     d16:	99 05       	cpc	r25, r9
     d18:	e1 f4       	brne	.+56     	; 0xd52 <TCP_GetConnectionState+0x94>
     d1a:	04 9d       	mul	r16, r4
     d1c:	60 01       	movw	r12, r0
     d1e:	05 9d       	mul	r16, r5
     d20:	d0 0c       	add	r13, r0
     d22:	14 9d       	mul	r17, r4
     d24:	d0 0c       	add	r13, r0
     d26:	11 24       	eor	r1, r1
     d28:	c6 01       	movw	r24, r12
     d2a:	83 5f       	subi	r24, 0xF3	; 243
     d2c:	92 4f       	sbci	r25, 0xF2	; 242
     d2e:	b3 01       	movw	r22, r6
     d30:	44 e0       	ldi	r20, 0x04	; 4
     d32:	50 e0       	ldi	r21, 0x00	; 0
     d34:	0e 94 90 16 	call	0x2d20	; 0x2d20 <memcmp>
     d38:	00 97       	sbiw	r24, 0x00	; 0
     d3a:	59 f4       	brne	.+22     	; 0xd52 <TCP_GetConnectionState+0x94>
     d3c:	f7 01       	movw	r30, r14
     d3e:	82 81       	ldd	r24, Z+2	; 0x02
     d40:	93 81       	ldd	r25, Z+3	; 0x03
     d42:	8a 15       	cp	r24, r10
     d44:	9b 05       	cpc	r25, r11
     d46:	29 f4       	brne	.+10     	; 0xd52 <TCP_GetConnectionState+0x94>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     d48:	f6 01       	movw	r30, r12
     d4a:	e2 5e       	subi	r30, 0xE2	; 226
     d4c:	f0 4f       	sbci	r31, 0xF0	; 240
     d4e:	80 81       	ld	r24, Z
     d50:	0a c0       	rjmp	.+20     	; 0xd66 <TCP_GetConnectionState+0xa8>
     d52:	0f 5f       	subi	r16, 0xFF	; 255
     d54:	1f 4f       	sbci	r17, 0xFF	; 255
     d56:	86 e1       	ldi	r24, 0x16	; 22
     d58:	92 e0       	ldi	r25, 0x02	; 2
     d5a:	e8 0e       	add	r14, r24
     d5c:	f9 1e       	adc	r15, r25
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     d5e:	03 30       	cpi	r16, 0x03	; 3
     d60:	11 05       	cpc	r17, r1
     d62:	a9 f6       	brne	.-86     	; 0xd0e <TCP_GetConnectionState+0x50>
     d64:	8a e0       	ldi	r24, 0x0A	; 10
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
}
     d66:	0f 90       	pop	r0
     d68:	0f 90       	pop	r0
     d6a:	0f 90       	pop	r0
     d6c:	0f 90       	pop	r0
     d6e:	cf 91       	pop	r28
     d70:	df 91       	pop	r29
     d72:	1f 91       	pop	r17
     d74:	0f 91       	pop	r16
     d76:	ff 90       	pop	r15
     d78:	ef 90       	pop	r14
     d7a:	df 90       	pop	r13
     d7c:	cf 90       	pop	r12
     d7e:	bf 90       	pop	r11
     d80:	af 90       	pop	r10
     d82:	9f 90       	pop	r9
     d84:	8f 90       	pop	r8
     d86:	7f 90       	pop	r7
     d88:	6f 90       	pop	r6
     d8a:	5f 90       	pop	r5
     d8c:	4f 90       	pop	r4
     d8e:	08 95       	ret

00000d90 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     d90:	3f 92       	push	r3
     d92:	4f 92       	push	r4
     d94:	5f 92       	push	r5
     d96:	6f 92       	push	r6
     d98:	7f 92       	push	r7
     d9a:	8f 92       	push	r8
     d9c:	9f 92       	push	r9
     d9e:	af 92       	push	r10
     da0:	bf 92       	push	r11
     da2:	cf 92       	push	r12
     da4:	df 92       	push	r13
     da6:	ef 92       	push	r14
     da8:	ff 92       	push	r15
     daa:	0f 93       	push	r16
     dac:	1f 93       	push	r17
     dae:	df 93       	push	r29
     db0:	cf 93       	push	r28
     db2:	00 d0       	rcall	.+0      	; 0xdb4 <TCP_SetConnectionState+0x24>
     db4:	00 d0       	rcall	.+0      	; 0xdb6 <TCP_SetConnectionState+0x26>
     db6:	cd b7       	in	r28, 0x3d	; 61
     db8:	de b7       	in	r29, 0x3e	; 62
     dba:	5c 01       	movw	r10, r24
     dbc:	49 83       	std	Y+1, r20	; 0x01
     dbe:	5a 83       	std	Y+2, r21	; 0x02
     dc0:	6b 83       	std	Y+3, r22	; 0x03
     dc2:	7c 83       	std	Y+4, r23	; 0x04
     dc4:	49 01       	movw	r8, r18
     dc6:	30 2e       	mov	r3, r16
     dc8:	19 e0       	ldi	r17, 0x09	; 9
     dca:	e1 2e       	mov	r14, r17
     dcc:	1d e0       	ldi	r17, 0x0D	; 13
     dce:	f1 2e       	mov	r15, r17
     dd0:	00 e0       	ldi	r16, 0x00	; 0
     dd2:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     dd4:	b6 e1       	ldi	r27, 0x16	; 22
     dd6:	4b 2e       	mov	r4, r27
     dd8:	b2 e0       	ldi	r27, 0x02	; 2
     dda:	5b 2e       	mov	r5, r27
     ddc:	3e 01       	movw	r6, r28
     dde:	08 94       	sec
     de0:	61 1c       	adc	r6, r1
     de2:	71 1c       	adc	r7, r1
     de4:	f7 01       	movw	r30, r14
     de6:	80 81       	ld	r24, Z
     de8:	91 81       	ldd	r25, Z+1	; 0x01
     dea:	8a 15       	cp	r24, r10
     dec:	9b 05       	cpc	r25, r11
     dee:	d9 f4       	brne	.+54     	; 0xe26 <TCP_SetConnectionState+0x96>
     df0:	04 9d       	mul	r16, r4
     df2:	60 01       	movw	r12, r0
     df4:	05 9d       	mul	r16, r5
     df6:	d0 0c       	add	r13, r0
     df8:	14 9d       	mul	r17, r4
     dfa:	d0 0c       	add	r13, r0
     dfc:	11 24       	eor	r1, r1
     dfe:	c6 01       	movw	r24, r12
     e00:	83 5f       	subi	r24, 0xF3	; 243
     e02:	92 4f       	sbci	r25, 0xF2	; 242
     e04:	b3 01       	movw	r22, r6
     e06:	44 e0       	ldi	r20, 0x04	; 4
     e08:	50 e0       	ldi	r21, 0x00	; 0
     e0a:	0e 94 90 16 	call	0x2d20	; 0x2d20 <memcmp>
     e0e:	00 97       	sbiw	r24, 0x00	; 0
     e10:	51 f4       	brne	.+20     	; 0xe26 <TCP_SetConnectionState+0x96>
     e12:	f7 01       	movw	r30, r14
     e14:	82 81       	ldd	r24, Z+2	; 0x02
     e16:	93 81       	ldd	r25, Z+3	; 0x03
     e18:	88 15       	cp	r24, r8
     e1a:	99 05       	cpc	r25, r9
     e1c:	21 f4       	brne	.+8      	; 0xe26 <TCP_SetConnectionState+0x96>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     e1e:	f6 01       	movw	r30, r12
     e20:	e2 5e       	subi	r30, 0xE2	; 226
     e22:	f0 4f       	sbci	r31, 0xF0	; 240
     e24:	47 c0       	rjmp	.+142    	; 0xeb4 <TCP_SetConnectionState+0x124>
			return true;
     e26:	0f 5f       	subi	r16, 0xFF	; 255
     e28:	1f 4f       	sbci	r17, 0xFF	; 255
     e2a:	86 e1       	ldi	r24, 0x16	; 22
     e2c:	92 e0       	ldi	r25, 0x02	; 2
     e2e:	e8 0e       	add	r14, r24
     e30:	f9 1e       	adc	r15, r25
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     e32:	03 30       	cpi	r16, 0x03	; 3
     e34:	11 05       	cpc	r17, r1
     e36:	b1 f6       	brne	.-84     	; 0xde4 <TCP_SetConnectionState+0x54>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     e38:	80 91 1e 0f 	lds	r24, 0x0F1E
     e3c:	8a 30       	cpi	r24, 0x0A	; 10
     e3e:	19 f4       	brne	.+6      	; 0xe46 <TCP_SetConnectionState+0xb6>
     e40:	40 e0       	ldi	r20, 0x00	; 0
     e42:	50 e0       	ldi	r21, 0x00	; 0
     e44:	0f c0       	rjmp	.+30     	; 0xe64 <TCP_SetConnectionState+0xd4>
     e46:	80 91 34 11 	lds	r24, 0x1134
     e4a:	8a 30       	cpi	r24, 0x0A	; 10
     e4c:	19 f4       	brne	.+6      	; 0xe54 <TCP_SetConnectionState+0xc4>
     e4e:	41 e0       	ldi	r20, 0x01	; 1
     e50:	50 e0       	ldi	r21, 0x00	; 0
     e52:	08 c0       	rjmp	.+16     	; 0xe64 <TCP_SetConnectionState+0xd4>
     e54:	80 91 4a 13 	lds	r24, 0x134A
     e58:	8a 30       	cpi	r24, 0x0A	; 10
     e5a:	11 f0       	breq	.+4      	; 0xe60 <TCP_SetConnectionState+0xd0>
     e5c:	80 e0       	ldi	r24, 0x00	; 0
     e5e:	2c c0       	rjmp	.+88     	; 0xeb8 <TCP_SetConnectionState+0x128>
     e60:	42 e0       	ldi	r20, 0x02	; 2
     e62:	50 e0       	ldi	r21, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     e64:	86 e1       	ldi	r24, 0x16	; 22
     e66:	92 e0       	ldi	r25, 0x02	; 2
     e68:	48 9f       	mul	r20, r24
     e6a:	90 01       	movw	r18, r0
     e6c:	49 9f       	mul	r20, r25
     e6e:	30 0d       	add	r19, r0
     e70:	58 9f       	mul	r21, r24
     e72:	30 0d       	add	r19, r0
     e74:	11 24       	eor	r1, r1
     e76:	27 5f       	subi	r18, 0xF7	; 247
     e78:	32 4f       	sbci	r19, 0xF2	; 242
     e7a:	f9 01       	movw	r30, r18
     e7c:	b1 82       	std	Z+1, r11	; 0x01
     e7e:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
     e80:	89 81       	ldd	r24, Y+1	; 0x01
     e82:	9a 81       	ldd	r25, Y+2	; 0x02
     e84:	ab 81       	ldd	r26, Y+3	; 0x03
     e86:	bc 81       	ldd	r27, Y+4	; 0x04
     e88:	84 83       	std	Z+4, r24	; 0x04
     e8a:	95 83       	std	Z+5, r25	; 0x05
     e8c:	a6 83       	std	Z+6, r26	; 0x06
     e8e:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     e90:	8b e0       	ldi	r24, 0x0B	; 11
     e92:	91 e0       	ldi	r25, 0x01	; 1
     e94:	48 9f       	mul	r20, r24
     e96:	f0 01       	movw	r30, r0
     e98:	49 9f       	mul	r20, r25
     e9a:	f0 0d       	add	r31, r0
     e9c:	58 9f       	mul	r21, r24
     e9e:	f0 0d       	add	r31, r0
     ea0:	11 24       	eor	r1, r1
     ea2:	ee 0f       	add	r30, r30
     ea4:	ff 1f       	adc	r31, r31
     ea6:	e5 5f       	subi	r30, 0xF5	; 245
     ea8:	f2 4f       	sbci	r31, 0xF2	; 242
     eaa:	91 82       	std	Z+1, r9	; 0x01
     eac:	80 82       	st	Z, r8
			ConnectionStateTable[CSTableEntry].State         = State;
     eae:	2b 5e       	subi	r18, 0xEB	; 235
     eb0:	3d 4f       	sbci	r19, 0xFD	; 253
     eb2:	f9 01       	movw	r30, r18
     eb4:	30 82       	st	Z, r3
     eb6:	81 e0       	ldi	r24, 0x01	; 1
			return true;
		}
	}

	return false;
}
     eb8:	0f 90       	pop	r0
     eba:	0f 90       	pop	r0
     ebc:	0f 90       	pop	r0
     ebe:	0f 90       	pop	r0
     ec0:	cf 91       	pop	r28
     ec2:	df 91       	pop	r29
     ec4:	1f 91       	pop	r17
     ec6:	0f 91       	pop	r16
     ec8:	ff 90       	pop	r15
     eca:	ef 90       	pop	r14
     ecc:	df 90       	pop	r13
     ece:	cf 90       	pop	r12
     ed0:	bf 90       	pop	r11
     ed2:	af 90       	pop	r10
     ed4:	9f 90       	pop	r9
     ed6:	8f 90       	pop	r8
     ed8:	7f 90       	pop	r7
     eda:	6f 90       	pop	r6
     edc:	5f 90       	pop	r5
     ede:	4f 90       	pop	r4
     ee0:	3f 90       	pop	r3
     ee2:	08 95       	ret

00000ee4 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     ee4:	af 92       	push	r10
     ee6:	bf 92       	push	r11
     ee8:	cf 92       	push	r12
     eea:	df 92       	push	r13
     eec:	ef 92       	push	r14
     eee:	ff 92       	push	r15
     ef0:	0f 93       	push	r16
     ef2:	1f 93       	push	r17
     ef4:	cf 93       	push	r28
     ef6:	df 93       	push	r29
     ef8:	7b 01       	movw	r14, r22
	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
     efa:	5c 01       	movw	r10, r24
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
     efc:	6a 01       	movw	r12, r20

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     efe:	cb 01       	movw	r24, r22
     f00:	5a dd       	rcall	.-1356   	; 0x9b6 <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     f02:	d7 01       	movw	r26, r14
     f04:	12 96       	adiw	r26, 0x02	; 2
     f06:	8d 91       	ld	r24, X+
     f08:	9c 91       	ld	r25, X
     f0a:	13 97       	sbiw	r26, 0x03	; 3
     f0c:	bf dd       	rcall	.-1154   	; 0xa8c <TCP_GetPortState>
     f0e:	81 30       	cpi	r24, 0x01	; 1
     f10:	09 f0       	breq	.+2      	; 0xf14 <TCP_ProcessTCPPacket+0x30>
     f12:	02 c2       	rjmp	.+1028   	; 0x1318 <TCP_ProcessTCPPacket+0x434>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     f14:	f7 01       	movw	r30, r14
     f16:	85 85       	ldd	r24, Z+13	; 0x0d
     f18:	81 ff       	sbrs	r24, 1
     f1a:	0d c0       	rjmp	.+26     	; 0xf36 <TCP_ProcessTCPPacket+0x52>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     f1c:	d5 01       	movw	r26, r10
     f1e:	1c 96       	adiw	r26, 0x0c	; 12
     f20:	4d 91       	ld	r20, X+
     f22:	5d 91       	ld	r21, X+
     f24:	6d 91       	ld	r22, X+
     f26:	7c 91       	ld	r23, X
     f28:	1f 97       	sbiw	r26, 0x0f	; 15
     f2a:	20 81       	ld	r18, Z
     f2c:	31 81       	ldd	r19, Z+1	; 0x01
     f2e:	82 81       	ldd	r24, Z+2	; 0x02
     f30:	93 81       	ldd	r25, Z+3	; 0x03
     f32:	00 e0       	ldi	r16, 0x00	; 0
     f34:	2d df       	rcall	.-422    	; 0xd90 <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     f36:	f7 01       	movw	r30, r14
     f38:	85 85       	ldd	r24, Z+13	; 0x0d
     f3a:	02 80       	ldd	r0, Z+2	; 0x02
     f3c:	f3 81       	ldd	r31, Z+3	; 0x03
     f3e:	e0 2d       	mov	r30, r0
     f40:	d5 01       	movw	r26, r10
     f42:	1c 96       	adiw	r26, 0x0c	; 12
     f44:	4d 91       	ld	r20, X+
     f46:	5d 91       	ld	r21, X+
     f48:	6d 91       	ld	r22, X+
     f4a:	7c 91       	ld	r23, X
     f4c:	1f 97       	sbiw	r26, 0x0f	; 15
     f4e:	d7 01       	movw	r26, r14
     f50:	2d 91       	ld	r18, X+
     f52:	3c 91       	ld	r19, X
     f54:	82 ff       	sbrs	r24, 2
     f56:	07 c0       	rjmp	.+14     	; 0xf66 <TCP_ProcessTCPPacket+0x82>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     f58:	cf 01       	movw	r24, r30
     f5a:	0a e0       	ldi	r16, 0x0A	; 10
     f5c:	19 df       	rcall	.-462    	; 0xd90 <TCP_SetConnectionState>
     f5e:	88 23       	and	r24, r24
     f60:	09 f4       	brne	.+2      	; 0xf64 <TCP_ProcessTCPPacket+0x80>
     f62:	15 c2       	rjmp	.+1066   	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
     f64:	d9 c1       	rjmp	.+946    	; 0x1318 <TCP_ProcessTCPPacket+0x434>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     f66:	cf 01       	movw	r24, r30
     f68:	aa de       	rcall	.-684    	; 0xcbe <TCP_GetConnectionState>
     f6a:	84 30       	cpi	r24, 0x04	; 4
     f6c:	09 f4       	brne	.+2      	; 0xf70 <TCP_ProcessTCPPacket+0x8c>
     f6e:	6f c1       	rjmp	.+734    	; 0x124e <TCP_ProcessTCPPacket+0x36a>
     f70:	85 30       	cpi	r24, 0x05	; 5
     f72:	48 f4       	brcc	.+18     	; 0xf86 <TCP_ProcessTCPPacket+0xa2>
     f74:	82 30       	cpi	r24, 0x02	; 2
     f76:	09 f4       	brne	.+2      	; 0xf7a <TCP_ProcessTCPPacket+0x96>
     f78:	56 c0       	rjmp	.+172    	; 0x1026 <TCP_ProcessTCPPacket+0x142>
     f7a:	83 30       	cpi	r24, 0x03	; 3
     f7c:	08 f0       	brcs	.+2      	; 0xf80 <TCP_ProcessTCPPacket+0x9c>
     f7e:	82 c0       	rjmp	.+260    	; 0x1084 <TCP_ProcessTCPPacket+0x1a0>
     f80:	88 23       	and	r24, r24
     f82:	59 f0       	breq	.+22     	; 0xf9a <TCP_ProcessTCPPacket+0xb6>
     f84:	04 c2       	rjmp	.+1032   	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
     f86:	86 30       	cpi	r24, 0x06	; 6
     f88:	09 f4       	brne	.+2      	; 0xf8c <TCP_ProcessTCPPacket+0xa8>
     f8a:	b3 c1       	rjmp	.+870    	; 0x12f2 <TCP_ProcessTCPPacket+0x40e>
     f8c:	86 30       	cpi	r24, 0x06	; 6
     f8e:	08 f4       	brcc	.+2      	; 0xf92 <TCP_ProcessTCPPacket+0xae>
     f90:	74 c1       	rjmp	.+744    	; 0x127a <TCP_ProcessTCPPacket+0x396>
     f92:	87 30       	cpi	r24, 0x07	; 7
     f94:	09 f0       	breq	.+2      	; 0xf98 <TCP_ProcessTCPPacket+0xb4>
     f96:	fb c1       	rjmp	.+1014   	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
     f98:	36 c1       	rjmp	.+620    	; 0x1206 <TCP_ProcessTCPPacket+0x322>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     f9a:	d7 01       	movw	r26, r14
     f9c:	1d 96       	adiw	r26, 0x0d	; 13
     f9e:	8c 91       	ld	r24, X
     fa0:	1d 97       	sbiw	r26, 0x0d	; 13
     fa2:	82 30       	cpi	r24, 0x02	; 2
     fa4:	09 f0       	breq	.+2      	; 0xfa8 <TCP_ProcessTCPPacket+0xc4>
     fa6:	f3 c1       	rjmp	.+998    	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     fa8:	f5 01       	movw	r30, r10
     faa:	44 85       	ldd	r20, Z+12	; 0x0c
     fac:	55 85       	ldd	r21, Z+13	; 0x0d
     fae:	66 85       	ldd	r22, Z+14	; 0x0e
     fb0:	77 85       	ldd	r23, Z+15	; 0x0f
     fb2:	2d 91       	ld	r18, X+
     fb4:	3c 91       	ld	r19, X
     fb6:	11 97       	sbiw	r26, 0x01	; 1
     fb8:	12 96       	adiw	r26, 0x02	; 2
     fba:	8d 91       	ld	r24, X+
     fbc:	9c 91       	ld	r25, X
     fbe:	13 97       	sbiw	r26, 0x03	; 3
     fc0:	02 e0       	ldi	r16, 0x02	; 2
     fc2:	e6 de       	rcall	.-564    	; 0xd90 <TCP_SetConnectionState>
     fc4:	88 23       	and	r24, r24
     fc6:	69 f1       	breq	.+90     	; 0x1022 <TCP_ProcessTCPPacket+0x13e>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
     fc8:	82 e1       	ldi	r24, 0x12	; 18
     fca:	d6 01       	movw	r26, r12
     fcc:	1d 96       	adiw	r26, 0x0d	; 13
     fce:	8c 93       	st	X, r24

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
     fd0:	f5 01       	movw	r30, r10
     fd2:	44 85       	ldd	r20, Z+12	; 0x0c
     fd4:	55 85       	ldd	r21, Z+13	; 0x0d
     fd6:	66 85       	ldd	r22, Z+14	; 0x0e
     fd8:	77 85       	ldd	r23, Z+15	; 0x0f
     fda:	d7 01       	movw	r26, r14
     fdc:	2d 91       	ld	r18, X+
     fde:	3c 91       	ld	r19, X
     fe0:	11 97       	sbiw	r26, 0x01	; 1
     fe2:	12 96       	adiw	r26, 0x02	; 2
     fe4:	8d 91       	ld	r24, X+
     fe6:	9c 91       	ld	r25, X
     fe8:	13 97       	sbiw	r26, 0x03	; 3
     fea:	ff dd       	rcall	.-1026   	; 0xbea <TCP_GetConnectionInfo>
     fec:	8c 01       	movw	r16, r24

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
     fee:	f7 01       	movw	r30, r14
     ff0:	64 81       	ldd	r22, Z+4	; 0x04
     ff2:	75 81       	ldd	r23, Z+5	; 0x05
     ff4:	86 81       	ldd	r24, Z+6	; 0x06
     ff6:	97 81       	ldd	r25, Z+7	; 0x07
     ff8:	55 dd       	rcall	.-1366   	; 0xaa4 <SwapEndian_32>
     ffa:	6f 5f       	subi	r22, 0xFF	; 255
     ffc:	7f 4f       	sbci	r23, 0xFF	; 255
     ffe:	8f 4f       	sbci	r24, 0xFF	; 255
    1000:	9f 4f       	sbci	r25, 0xFF	; 255
    1002:	d8 01       	movw	r26, r16
    1004:	6d 93       	st	X+, r22
    1006:	7d 93       	st	X+, r23
    1008:	8d 93       	st	X+, r24
    100a:	9c 93       	st	X, r25
    100c:	13 97       	sbiw	r26, 0x03	; 3
							ConnectionInfo->SequenceNumberOut = 0;
    100e:	f8 01       	movw	r30, r16
    1010:	14 82       	std	Z+4, r1	; 0x04
    1012:	15 82       	std	Z+5, r1	; 0x05
    1014:	16 82       	std	Z+6, r1	; 0x06
    1016:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
    1018:	04 5f       	subi	r16, 0xF4	; 244
    101a:	1d 4f       	sbci	r17, 0xFD	; 253
    101c:	d8 01       	movw	r26, r16
    101e:	1c 92       	st	X, r1
    1020:	c4 c1       	rjmp	.+904    	; 0x13aa <TCP_ProcessTCPPacket+0x4c6>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
    1022:	84 e0       	ldi	r24, 0x04	; 4
    1024:	ed c0       	rjmp	.+474    	; 0x1200 <TCP_ProcessTCPPacket+0x31c>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1026:	d7 01       	movw	r26, r14
    1028:	1d 96       	adiw	r26, 0x0d	; 13
    102a:	8c 91       	ld	r24, X
    102c:	1d 97       	sbiw	r26, 0x0d	; 13
    102e:	80 31       	cpi	r24, 0x10	; 16
    1030:	09 f0       	breq	.+2      	; 0x1034 <TCP_ProcessTCPPacket+0x150>
    1032:	ad c1       	rjmp	.+858    	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1034:	f5 01       	movw	r30, r10
    1036:	44 85       	ldd	r20, Z+12	; 0x0c
    1038:	55 85       	ldd	r21, Z+13	; 0x0d
    103a:	66 85       	ldd	r22, Z+14	; 0x0e
    103c:	77 85       	ldd	r23, Z+15	; 0x0f
    103e:	2d 91       	ld	r18, X+
    1040:	3c 91       	ld	r19, X
    1042:	11 97       	sbiw	r26, 0x01	; 1
    1044:	12 96       	adiw	r26, 0x02	; 2
    1046:	8d 91       	ld	r24, X+
    1048:	9c 91       	ld	r25, X
    104a:	13 97       	sbiw	r26, 0x03	; 3
    104c:	03 e0       	ldi	r16, 0x03	; 3
    104e:	a0 de       	rcall	.-704    	; 0xd90 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1050:	d5 01       	movw	r26, r10
    1052:	1c 96       	adiw	r26, 0x0c	; 12
    1054:	4d 91       	ld	r20, X+
    1056:	5d 91       	ld	r21, X+
    1058:	6d 91       	ld	r22, X+
    105a:	7c 91       	ld	r23, X
    105c:	1f 97       	sbiw	r26, 0x0f	; 15
    105e:	f7 01       	movw	r30, r14
    1060:	20 81       	ld	r18, Z
    1062:	31 81       	ldd	r19, Z+1	; 0x01
    1064:	82 81       	ldd	r24, Z+2	; 0x02
    1066:	93 81       	ldd	r25, Z+3	; 0x03
    1068:	c0 dd       	rcall	.-1152   	; 0xbea <TCP_GetConnectionInfo>
    106a:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
    106c:	84 81       	ldd	r24, Z+4	; 0x04
    106e:	95 81       	ldd	r25, Z+5	; 0x05
    1070:	a6 81       	ldd	r26, Z+6	; 0x06
    1072:	b7 81       	ldd	r27, Z+7	; 0x07
    1074:	01 96       	adiw	r24, 0x01	; 1
    1076:	a1 1d       	adc	r26, r1
    1078:	b1 1d       	adc	r27, r1
    107a:	84 83       	std	Z+4, r24	; 0x04
    107c:	95 83       	std	Z+5, r25	; 0x05
    107e:	a6 83       	std	Z+6, r26	; 0x06
    1080:	b7 83       	std	Z+7, r27	; 0x07
    1082:	85 c1       	rjmp	.+778    	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    1084:	d7 01       	movw	r26, r14
    1086:	1d 96       	adiw	r26, 0x0d	; 13
    1088:	8c 91       	ld	r24, X
    108a:	81 31       	cpi	r24, 0x11	; 17
    108c:	a9 f5       	brne	.+106    	; 0x10f8 <TCP_ProcessTCPPacket+0x214>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
    108e:	f6 01       	movw	r30, r12
    1090:	85 87       	std	Z+13, r24	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1092:	d5 01       	movw	r26, r10
    1094:	1c 96       	adiw	r26, 0x0c	; 12
    1096:	4d 91       	ld	r20, X+
    1098:	5d 91       	ld	r21, X+
    109a:	6d 91       	ld	r22, X+
    109c:	7c 91       	ld	r23, X
    109e:	1f 97       	sbiw	r26, 0x0f	; 15
    10a0:	f7 01       	movw	r30, r14
    10a2:	20 81       	ld	r18, Z
    10a4:	31 81       	ldd	r19, Z+1	; 0x01
    10a6:	82 81       	ldd	r24, Z+2	; 0x02
    10a8:	93 81       	ldd	r25, Z+3	; 0x03
    10aa:	06 e0       	ldi	r16, 0x06	; 6
    10ac:	71 de       	rcall	.-798    	; 0xd90 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10ae:	d5 01       	movw	r26, r10
    10b0:	1c 96       	adiw	r26, 0x0c	; 12
    10b2:	4d 91       	ld	r20, X+
    10b4:	5d 91       	ld	r21, X+
    10b6:	6d 91       	ld	r22, X+
    10b8:	7c 91       	ld	r23, X
    10ba:	1f 97       	sbiw	r26, 0x0f	; 15
    10bc:	f7 01       	movw	r30, r14
    10be:	20 81       	ld	r18, Z
    10c0:	31 81       	ldd	r19, Z+1	; 0x01
    10c2:	82 81       	ldd	r24, Z+2	; 0x02
    10c4:	93 81       	ldd	r25, Z+3	; 0x03
    10c6:	91 dd       	rcall	.-1246   	; 0xbea <TCP_GetConnectionInfo>
    10c8:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
    10ca:	80 81       	ld	r24, Z
    10cc:	91 81       	ldd	r25, Z+1	; 0x01
    10ce:	a2 81       	ldd	r26, Z+2	; 0x02
    10d0:	b3 81       	ldd	r27, Z+3	; 0x03
    10d2:	01 96       	adiw	r24, 0x01	; 1
    10d4:	a1 1d       	adc	r26, r1
    10d6:	b1 1d       	adc	r27, r1
    10d8:	80 83       	st	Z, r24
    10da:	91 83       	std	Z+1, r25	; 0x01
    10dc:	a2 83       	std	Z+2, r26	; 0x02
    10de:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    10e0:	84 81       	ldd	r24, Z+4	; 0x04
    10e2:	95 81       	ldd	r25, Z+5	; 0x05
    10e4:	a6 81       	ldd	r26, Z+6	; 0x06
    10e6:	b7 81       	ldd	r27, Z+7	; 0x07
    10e8:	01 96       	adiw	r24, 0x01	; 1
    10ea:	a1 1d       	adc	r26, r1
    10ec:	b1 1d       	adc	r27, r1
    10ee:	84 83       	std	Z+4, r24	; 0x04
    10f0:	95 83       	std	Z+5, r25	; 0x05
    10f2:	a6 83       	std	Z+6, r26	; 0x06
    10f4:	b7 83       	std	Z+7, r27	; 0x07
    10f6:	59 c1       	rjmp	.+690    	; 0x13aa <TCP_ProcessTCPPacket+0x4c6>
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
    10f8:	80 31       	cpi	r24, 0x10	; 16
    10fa:	19 f0       	breq	.+6      	; 0x1102 <TCP_ProcessTCPPacket+0x21e>
    10fc:	88 31       	cpi	r24, 0x18	; 24
    10fe:	09 f0       	breq	.+2      	; 0x1102 <TCP_ProcessTCPPacket+0x21e>
    1100:	46 c1       	rjmp	.+652    	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1102:	d5 01       	movw	r26, r10
    1104:	1c 96       	adiw	r26, 0x0c	; 12
    1106:	4d 91       	ld	r20, X+
    1108:	5d 91       	ld	r21, X+
    110a:	6d 91       	ld	r22, X+
    110c:	7c 91       	ld	r23, X
    110e:	1f 97       	sbiw	r26, 0x0f	; 15
    1110:	f7 01       	movw	r30, r14
    1112:	20 81       	ld	r18, Z
    1114:	31 81       	ldd	r19, Z+1	; 0x01
    1116:	82 81       	ldd	r24, Z+2	; 0x02
    1118:	93 81       	ldd	r25, Z+3	; 0x03
    111a:	67 dd       	rcall	.-1330   	; 0xbea <TCP_GetConnectionInfo>
    111c:	ec 01       	movw	r28, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
    111e:	fc 01       	movw	r30, r24
    1120:	e4 5f       	subi	r30, 0xF4	; 244
    1122:	fd 4f       	sbci	r31, 0xFD	; 253
    1124:	80 81       	ld	r24, Z
    1126:	88 23       	and	r24, r24
    1128:	81 f4       	brne	.+32     	; 0x114a <TCP_ProcessTCPPacket+0x266>
    112a:	c5 5f       	subi	r28, 0xF5	; 245
    112c:	dd 4f       	sbci	r29, 0xFD	; 253
    112e:	88 81       	ld	r24, Y
    1130:	cb 50       	subi	r28, 0x0B	; 11
    1132:	d2 40       	sbci	r29, 0x02	; 2
    1134:	88 23       	and	r24, r24
    1136:	49 f4       	brne	.+18     	; 0x114a <TCP_ProcessTCPPacket+0x266>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
    1138:	c6 5f       	subi	r28, 0xF6	; 246
    113a:	dd 4f       	sbci	r29, 0xFD	; 253
    113c:	18 82       	st	Y, r1
    113e:	ca 50       	subi	r28, 0x0A	; 10
    1140:	d2 40       	sbci	r29, 0x02	; 2
							ConnectionInfo->Buffer.InUse     = true;
    1142:	81 e0       	ldi	r24, 0x01	; 1
    1144:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
    1146:	19 86       	std	Y+9, r1	; 0x09
    1148:	18 86       	std	Y+8, r1	; 0x08
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
    114a:	c6 5f       	subi	r28, 0xF6	; 246
    114c:	dd 4f       	sbci	r29, 0xFD	; 253
    114e:	88 81       	ld	r24, Y
    1150:	ca 50       	subi	r28, 0x0A	; 10
    1152:	d2 40       	sbci	r29, 0x02	; 2
    1154:	88 23       	and	r24, r24
    1156:	09 f0       	breq	.+2      	; 0x115a <TCP_ProcessTCPPacket+0x276>
    1158:	17 c1       	rjmp	.+558    	; 0x1388 <TCP_ProcessTCPPacket+0x4a4>
    115a:	68 85       	ldd	r22, Y+8	; 0x08
    115c:	79 85       	ldd	r23, Y+9	; 0x09
    115e:	f2 e0       	ldi	r31, 0x02	; 2
    1160:	60 30       	cpi	r22, 0x00	; 0
    1162:	7f 07       	cpc	r23, r31
    1164:	09 f4       	brne	.+2      	; 0x1168 <TCP_ProcessTCPPacket+0x284>
    1166:	10 c1       	rjmp	.+544    	; 0x1388 <TCP_ProcessTCPPacket+0x4a4>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1168:	d5 01       	movw	r26, r10
    116a:	8c 91       	ld	r24, X
    116c:	8f 70       	andi	r24, 0x0F	; 15
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
    116e:	f7 01       	movw	r30, r14
    1170:	44 85       	ldd	r20, Z+12	; 0x0c
    1172:	42 95       	swap	r20
    1174:	4f 70       	andi	r20, 0x0F	; 15
    1176:	50 e0       	ldi	r21, 0x00	; 0
    1178:	44 0f       	add	r20, r20
    117a:	55 1f       	adc	r21, r21
    117c:	44 0f       	add	r20, r20
    117e:	55 1f       	adc	r21, r21
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1180:	12 96       	adiw	r26, 0x02	; 2
    1182:	0d 91       	ld	r16, X+
    1184:	1c 91       	ld	r17, X
    1186:	13 97       	sbiw	r26, 0x03	; 3

				Temp = Data.Bytes[0];
    1188:	20 2f       	mov	r18, r16
				Data.Bytes[0] = Data.Bytes[1];
    118a:	01 2f       	mov	r16, r17
				Data.Bytes[1] = Temp;
    118c:	12 2f       	mov	r17, r18
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
    118e:	90 e0       	ldi	r25, 0x00	; 0
    1190:	88 0f       	add	r24, r24
    1192:	99 1f       	adc	r25, r25
    1194:	88 0f       	add	r24, r24
    1196:	99 1f       	adc	r25, r25
    1198:	08 1b       	sub	r16, r24
    119a:	19 0b       	sbc	r17, r25
    119c:	04 1b       	sub	r16, r20
    119e:	15 0b       	sbc	r17, r21

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
    11a0:	9b 01       	movw	r18, r22
    11a2:	26 5f       	subi	r18, 0xF6	; 246
    11a4:	3f 4f       	sbci	r19, 0xFF	; 255
    11a6:	2c 0f       	add	r18, r28
    11a8:	3d 1f       	adc	r19, r29
    11aa:	4e 0d       	add	r20, r14
    11ac:	5f 1d       	adc	r21, r15
    11ae:	c9 01       	movw	r24, r18
    11b0:	ba 01       	movw	r22, r20
    11b2:	a8 01       	movw	r20, r16
    11b4:	0e 94 9d 16 	call	0x2d3a	; 0x2d3a <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
    11b8:	98 01       	movw	r18, r16
    11ba:	40 e0       	ldi	r20, 0x00	; 0
    11bc:	50 e0       	ldi	r21, 0x00	; 0
    11be:	88 81       	ld	r24, Y
    11c0:	99 81       	ldd	r25, Y+1	; 0x01
    11c2:	aa 81       	ldd	r26, Y+2	; 0x02
    11c4:	bb 81       	ldd	r27, Y+3	; 0x03
    11c6:	82 0f       	add	r24, r18
    11c8:	93 1f       	adc	r25, r19
    11ca:	a4 1f       	adc	r26, r20
    11cc:	b5 1f       	adc	r27, r21
    11ce:	88 83       	st	Y, r24
    11d0:	99 83       	std	Y+1, r25	; 0x01
    11d2:	aa 83       	std	Y+2, r26	; 0x02
    11d4:	bb 83       	std	Y+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
    11d6:	88 85       	ldd	r24, Y+8	; 0x08
    11d8:	99 85       	ldd	r25, Y+9	; 0x09
    11da:	80 0f       	add	r24, r16
    11dc:	91 1f       	adc	r25, r17
    11de:	99 87       	std	Y+9, r25	; 0x09
    11e0:	88 87       	std	Y+8, r24	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
    11e2:	80 50       	subi	r24, 0x00	; 0
    11e4:	92 40       	sbci	r25, 0x02	; 2
    11e6:	29 f0       	breq	.+10     	; 0x11f2 <TCP_ProcessTCPPacket+0x30e>
    11e8:	d7 01       	movw	r26, r14
    11ea:	1d 96       	adiw	r26, 0x0d	; 13
    11ec:	8c 91       	ld	r24, X
    11ee:	83 ff       	sbrs	r24, 3
    11f0:	ce c0       	rjmp	.+412    	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
							{
								ConnectionInfo->Buffer.InUse = false;
    11f2:	c4 5f       	subi	r28, 0xF4	; 244
    11f4:	dd 4f       	sbci	r29, 0xFD	; 253
    11f6:	18 82       	st	Y, r1
								ConnectionInfo->Buffer.Ready = true;
    11f8:	fe 01       	movw	r30, r28
    11fa:	81 e0       	ldi	r24, 0x01	; 1
    11fc:	82 93       	st	-Z, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    11fe:	80 e1       	ldi	r24, 0x10	; 16
    1200:	f6 01       	movw	r30, r12
    1202:	85 87       	std	Z+13, r24	; 0x0d
    1204:	d2 c0       	rjmp	.+420    	; 0x13aa <TCP_ProcessTCPPacket+0x4c6>
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1206:	d5 01       	movw	r26, r10
    1208:	1c 96       	adiw	r26, 0x0c	; 12
    120a:	4d 91       	ld	r20, X+
    120c:	5d 91       	ld	r21, X+
    120e:	6d 91       	ld	r22, X+
    1210:	7c 91       	ld	r23, X
    1212:	1f 97       	sbiw	r26, 0x0f	; 15
    1214:	f7 01       	movw	r30, r14
    1216:	20 81       	ld	r18, Z
    1218:	31 81       	ldd	r19, Z+1	; 0x01
    121a:	82 81       	ldd	r24, Z+2	; 0x02
    121c:	93 81       	ldd	r25, Z+3	; 0x03
    121e:	e5 dc       	rcall	.-1590   	; 0xbea <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
    1220:	21 e1       	ldi	r18, 0x11	; 17
    1222:	d6 01       	movw	r26, r12
    1224:	1d 96       	adiw	r26, 0x0d	; 13
    1226:	2c 93       	st	X, r18
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
    1228:	fc 01       	movw	r30, r24
    122a:	e4 5f       	subi	r30, 0xF4	; 244
    122c:	fd 4f       	sbci	r31, 0xFD	; 253
    122e:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1230:	f5 01       	movw	r30, r10
    1232:	44 85       	ldd	r20, Z+12	; 0x0c
    1234:	55 85       	ldd	r21, Z+13	; 0x0d
    1236:	66 85       	ldd	r22, Z+14	; 0x0e
    1238:	77 85       	ldd	r23, Z+15	; 0x0f
    123a:	d7 01       	movw	r26, r14
    123c:	2d 91       	ld	r18, X+
    123e:	3c 91       	ld	r19, X
    1240:	11 97       	sbiw	r26, 0x01	; 1
    1242:	12 96       	adiw	r26, 0x02	; 2
    1244:	8d 91       	ld	r24, X+
    1246:	9c 91       	ld	r25, X
    1248:	13 97       	sbiw	r26, 0x03	; 3
    124a:	04 e0       	ldi	r16, 0x04	; 4
    124c:	50 c0       	rjmp	.+160    	; 0x12ee <TCP_ProcessTCPPacket+0x40a>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    124e:	f7 01       	movw	r30, r14
    1250:	85 85       	ldd	r24, Z+13	; 0x0d
    1252:	81 31       	cpi	r24, 0x11	; 17
    1254:	b9 f0       	breq	.+46     	; 0x1284 <TCP_ProcessTCPPacket+0x3a0>
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1256:	80 31       	cpi	r24, 0x10	; 16
    1258:	09 f0       	breq	.+2      	; 0x125c <TCP_ProcessTCPPacket+0x378>
    125a:	99 c0       	rjmp	.+306    	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    125c:	f5 01       	movw	r30, r10
    125e:	44 85       	ldd	r20, Z+12	; 0x0c
    1260:	55 85       	ldd	r21, Z+13	; 0x0d
    1262:	66 85       	ldd	r22, Z+14	; 0x0e
    1264:	77 85       	ldd	r23, Z+15	; 0x0f
    1266:	d7 01       	movw	r26, r14
    1268:	2d 91       	ld	r18, X+
    126a:	3c 91       	ld	r19, X
    126c:	11 97       	sbiw	r26, 0x01	; 1
    126e:	12 96       	adiw	r26, 0x02	; 2
    1270:	8d 91       	ld	r24, X+
    1272:	9c 91       	ld	r25, X
    1274:	13 97       	sbiw	r26, 0x03	; 3
    1276:	05 e0       	ldi	r16, 0x05	; 5
    1278:	4d c0       	rjmp	.+154    	; 0x1314 <TCP_ProcessTCPPacket+0x430>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    127a:	f7 01       	movw	r30, r14
    127c:	85 85       	ldd	r24, Z+13	; 0x0d
    127e:	81 31       	cpi	r24, 0x11	; 17
    1280:	09 f0       	breq	.+2      	; 0x1284 <TCP_ProcessTCPPacket+0x3a0>
    1282:	85 c0       	rjmp	.+266    	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1284:	d5 01       	movw	r26, r10
    1286:	1c 96       	adiw	r26, 0x0c	; 12
    1288:	4d 91       	ld	r20, X+
    128a:	5d 91       	ld	r21, X+
    128c:	6d 91       	ld	r22, X+
    128e:	7c 91       	ld	r23, X
    1290:	1f 97       	sbiw	r26, 0x0f	; 15
    1292:	20 81       	ld	r18, Z
    1294:	31 81       	ldd	r19, Z+1	; 0x01
    1296:	82 81       	ldd	r24, Z+2	; 0x02
    1298:	93 81       	ldd	r25, Z+3	; 0x03
    129a:	a7 dc       	rcall	.-1714   	; 0xbea <TCP_GetConnectionInfo>
    129c:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    129e:	80 e1       	ldi	r24, 0x10	; 16
    12a0:	d6 01       	movw	r26, r12
    12a2:	1d 96       	adiw	r26, 0x0d	; 13
    12a4:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    12a6:	80 81       	ld	r24, Z
    12a8:	91 81       	ldd	r25, Z+1	; 0x01
    12aa:	a2 81       	ldd	r26, Z+2	; 0x02
    12ac:	b3 81       	ldd	r27, Z+3	; 0x03
    12ae:	01 96       	adiw	r24, 0x01	; 1
    12b0:	a1 1d       	adc	r26, r1
    12b2:	b1 1d       	adc	r27, r1
    12b4:	80 83       	st	Z, r24
    12b6:	91 83       	std	Z+1, r25	; 0x01
    12b8:	a2 83       	std	Z+2, r26	; 0x02
    12ba:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    12bc:	84 81       	ldd	r24, Z+4	; 0x04
    12be:	95 81       	ldd	r25, Z+5	; 0x05
    12c0:	a6 81       	ldd	r26, Z+6	; 0x06
    12c2:	b7 81       	ldd	r27, Z+7	; 0x07
    12c4:	01 96       	adiw	r24, 0x01	; 1
    12c6:	a1 1d       	adc	r26, r1
    12c8:	b1 1d       	adc	r27, r1
    12ca:	84 83       	std	Z+4, r24	; 0x04
    12cc:	95 83       	std	Z+5, r25	; 0x05
    12ce:	a6 83       	std	Z+6, r26	; 0x06
    12d0:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12d2:	f5 01       	movw	r30, r10
    12d4:	44 85       	ldd	r20, Z+12	; 0x0c
    12d6:	55 85       	ldd	r21, Z+13	; 0x0d
    12d8:	66 85       	ldd	r22, Z+14	; 0x0e
    12da:	77 85       	ldd	r23, Z+15	; 0x0f
    12dc:	d7 01       	movw	r26, r14
    12de:	2d 91       	ld	r18, X+
    12e0:	3c 91       	ld	r19, X
    12e2:	11 97       	sbiw	r26, 0x01	; 1
    12e4:	12 96       	adiw	r26, 0x02	; 2
    12e6:	8d 91       	ld	r24, X+
    12e8:	9c 91       	ld	r25, X
    12ea:	13 97       	sbiw	r26, 0x03	; 3
    12ec:	0a e0       	ldi	r16, 0x0A	; 10
    12ee:	50 dd       	rcall	.-1376   	; 0xd90 <TCP_SetConnectionState>
    12f0:	5c c0       	rjmp	.+184    	; 0x13aa <TCP_ProcessTCPPacket+0x4c6>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    12f2:	f7 01       	movw	r30, r14
    12f4:	85 85       	ldd	r24, Z+13	; 0x0d
    12f6:	80 31       	cpi	r24, 0x10	; 16
    12f8:	09 f0       	breq	.+2      	; 0x12fc <TCP_ProcessTCPPacket+0x418>
    12fa:	49 c0       	rjmp	.+146    	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    12fc:	d5 01       	movw	r26, r10
    12fe:	1c 96       	adiw	r26, 0x0c	; 12
    1300:	4d 91       	ld	r20, X+
    1302:	5d 91       	ld	r21, X+
    1304:	6d 91       	ld	r22, X+
    1306:	7c 91       	ld	r23, X
    1308:	1f 97       	sbiw	r26, 0x0f	; 15
    130a:	20 81       	ld	r18, Z
    130c:	31 81       	ldd	r19, Z+1	; 0x01
    130e:	82 81       	ldd	r24, Z+2	; 0x02
    1310:	93 81       	ldd	r25, Z+3	; 0x03
    1312:	0a e0       	ldi	r16, 0x0A	; 10
    1314:	3d dd       	rcall	.-1414   	; 0xd90 <TCP_SetConnectionState>
    1316:	3b c0       	rjmp	.+118    	; 0x138e <TCP_ProcessTCPPacket+0x4aa>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    1318:	84 e1       	ldi	r24, 0x14	; 20
    131a:	72 cf       	rjmp	.-284    	; 0x1200 <TCP_ProcessTCPPacket+0x31c>
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    131c:	82 e0       	ldi	r24, 0x02	; 2
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	d6 01       	movw	r26, r12
    1322:	1f 96       	adiw	r26, 0x0f	; 15
    1324:	9c 93       	st	X, r25
    1326:	8e 93       	st	-X, r24
    1328:	1e 97       	sbiw	r26, 0x0e	; 14
    132a:	09 c0       	rjmp	.+18     	; 0x133e <TCP_ProcessTCPPacket+0x45a>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    132c:	80 e0       	ldi	r24, 0x00	; 0
    132e:	92 e0       	ldi	r25, 0x02	; 2
    1330:	28 85       	ldd	r18, Y+8	; 0x08
    1332:	39 85       	ldd	r19, Y+9	; 0x09
    1334:	82 1b       	sub	r24, r18
    1336:	93 0b       	sbc	r25, r19
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    1338:	f6 01       	movw	r30, r12
    133a:	96 87       	std	Z+14, r25	; 0x0e
    133c:	87 87       	std	Z+15, r24	; 0x0f

		TCPHeaderOUT->UrgentPointer        = 0;
    133e:	d6 01       	movw	r26, r12
    1340:	53 96       	adiw	r26, 0x13	; 19
    1342:	1c 92       	st	X, r1
    1344:	1e 92       	st	-X, r1
    1346:	52 97       	sbiw	r26, 0x12	; 18
		TCPHeaderOUT->Checksum             = 0;
    1348:	51 96       	adiw	r26, 0x11	; 17
    134a:	1c 92       	st	X, r1
    134c:	1e 92       	st	-X, r1
    134e:	50 97       	sbiw	r26, 0x10	; 16
		TCPHeaderOUT->Reserved             = 0;
    1350:	1c 96       	adiw	r26, 0x0c	; 12
    1352:	8c 91       	ld	r24, X
    1354:	1c 97       	sbiw	r26, 0x0c	; 12
    1356:	80 7f       	andi	r24, 0xF0	; 240
    1358:	1c 96       	adiw	r26, 0x0c	; 12
    135a:	8c 93       	st	X, r24

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
    135c:	f5 01       	movw	r30, r10
    135e:	40 89       	ldd	r20, Z+16	; 0x10
    1360:	51 89       	ldd	r21, Z+17	; 0x11
    1362:	62 89       	ldd	r22, Z+18	; 0x12
    1364:	73 89       	ldd	r23, Z+19	; 0x13
    1366:	04 85       	ldd	r16, Z+12	; 0x0c
    1368:	15 85       	ldd	r17, Z+13	; 0x0d
    136a:	26 85       	ldd	r18, Z+14	; 0x0e
    136c:	37 85       	ldd	r19, Z+15	; 0x0f
    136e:	c6 01       	movw	r24, r12
    1370:	e4 e1       	ldi	r30, 0x14	; 20
    1372:	ee 2e       	mov	r14, r30
    1374:	f1 2c       	mov	r15, r1
    1376:	9c db       	rcall	.-2248   	; 0xab0 <TCP_Checksum16>
    1378:	d6 01       	movw	r26, r12
    137a:	51 96       	adiw	r26, 0x11	; 17
    137c:	9c 93       	st	X, r25
    137e:	8e 93       	st	-X, r24
    1380:	50 97       	sbiw	r26, 0x10	; 16
    1382:	24 e1       	ldi	r18, 0x14	; 20
    1384:	30 e0       	ldi	r19, 0x00	; 0
    1386:	05 c0       	rjmp	.+10     	; 0x1392 <TCP_ProcessTCPPacket+0x4ae>
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    1388:	2f ef       	ldi	r18, 0xFF	; 255
    138a:	3f ef       	ldi	r19, 0xFF	; 255
    138c:	02 c0       	rjmp	.+4      	; 0x1392 <TCP_ProcessTCPPacket+0x4ae>
    138e:	20 e0       	ldi	r18, 0x00	; 0
    1390:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    1392:	c9 01       	movw	r24, r18
    1394:	df 91       	pop	r29
    1396:	cf 91       	pop	r28
    1398:	1f 91       	pop	r17
    139a:	0f 91       	pop	r16
    139c:	ff 90       	pop	r15
    139e:	ef 90       	pop	r14
    13a0:	df 90       	pop	r13
    13a2:	cf 90       	pop	r12
    13a4:	bf 90       	pop	r11
    13a6:	af 90       	pop	r10
    13a8:	08 95       	ret
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    13aa:	f5 01       	movw	r30, r10
    13ac:	44 85       	ldd	r20, Z+12	; 0x0c
    13ae:	55 85       	ldd	r21, Z+13	; 0x0d
    13b0:	66 85       	ldd	r22, Z+14	; 0x0e
    13b2:	77 85       	ldd	r23, Z+15	; 0x0f
    13b4:	d7 01       	movw	r26, r14
    13b6:	2d 91       	ld	r18, X+
    13b8:	3c 91       	ld	r19, X
    13ba:	11 97       	sbiw	r26, 0x01	; 1
    13bc:	12 96       	adiw	r26, 0x02	; 2
    13be:	8d 91       	ld	r24, X+
    13c0:	9c 91       	ld	r25, X
    13c2:	13 97       	sbiw	r26, 0x03	; 3
    13c4:	12 dc       	rcall	.-2012   	; 0xbea <TCP_GetConnectionInfo>
    13c6:	ec 01       	movw	r28, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    13c8:	f7 01       	movw	r30, r14
    13ca:	82 81       	ldd	r24, Z+2	; 0x02
    13cc:	93 81       	ldd	r25, Z+3	; 0x03
    13ce:	d6 01       	movw	r26, r12
    13d0:	11 96       	adiw	r26, 0x01	; 1
    13d2:	9c 93       	st	X, r25
    13d4:	8e 93       	st	-X, r24
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    13d6:	80 81       	ld	r24, Z
    13d8:	91 81       	ldd	r25, Z+1	; 0x01
    13da:	13 96       	adiw	r26, 0x03	; 3
    13dc:	9c 93       	st	X, r25
    13de:	8e 93       	st	-X, r24
    13e0:	12 97       	sbiw	r26, 0x02	; 2
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    13e2:	6c 81       	ldd	r22, Y+4	; 0x04
    13e4:	7d 81       	ldd	r23, Y+5	; 0x05
    13e6:	8e 81       	ldd	r24, Y+6	; 0x06
    13e8:	9f 81       	ldd	r25, Y+7	; 0x07
    13ea:	5c db       	rcall	.-2376   	; 0xaa4 <SwapEndian_32>
    13ec:	f6 01       	movw	r30, r12
    13ee:	64 83       	std	Z+4, r22	; 0x04
    13f0:	75 83       	std	Z+5, r23	; 0x05
    13f2:	86 83       	std	Z+6, r24	; 0x06
    13f4:	97 83       	std	Z+7, r25	; 0x07
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    13f6:	68 81       	ld	r22, Y
    13f8:	79 81       	ldd	r23, Y+1	; 0x01
    13fa:	8a 81       	ldd	r24, Y+2	; 0x02
    13fc:	9b 81       	ldd	r25, Y+3	; 0x03
    13fe:	52 db       	rcall	.-2396   	; 0xaa4 <SwapEndian_32>
    1400:	d6 01       	movw	r26, r12
    1402:	18 96       	adiw	r26, 0x08	; 8
    1404:	6d 93       	st	X+, r22
    1406:	7d 93       	st	X+, r23
    1408:	8d 93       	st	X+, r24
    140a:	9c 93       	st	X, r25
    140c:	1b 97       	sbiw	r26, 0x0b	; 11
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    140e:	1c 96       	adiw	r26, 0x0c	; 12
    1410:	8c 91       	ld	r24, X
    1412:	1c 97       	sbiw	r26, 0x0c	; 12
    1414:	8f 70       	andi	r24, 0x0F	; 15
    1416:	80 65       	ori	r24, 0x50	; 80
    1418:	1c 96       	adiw	r26, 0x0c	; 12
    141a:	8c 93       	st	X, r24

		if (!(ConnectionInfo->Buffer.InUse))
    141c:	c4 5f       	subi	r28, 0xF4	; 244
    141e:	dd 4f       	sbci	r29, 0xFD	; 253
    1420:	88 81       	ld	r24, Y
    1422:	cc 50       	subi	r28, 0x0C	; 12
    1424:	d2 40       	sbci	r29, 0x02	; 2
    1426:	88 23       	and	r24, r24
    1428:	09 f4       	brne	.+2      	; 0x142c <TCP_ProcessTCPPacket+0x548>
    142a:	78 cf       	rjmp	.-272    	; 0x131c <TCP_ProcessTCPPacket+0x438>
    142c:	7f cf       	rjmp	.-258    	; 0x132c <TCP_ProcessTCPPacket+0x448>

0000142e <TCP_Task>:
/** Task to handle the calling of each registered application's callback function, to process and generate TCP packets at the application
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
    142e:	2f 92       	push	r2
    1430:	3f 92       	push	r3
    1432:	4f 92       	push	r4
    1434:	5f 92       	push	r5
    1436:	6f 92       	push	r6
    1438:	7f 92       	push	r7
    143a:	8f 92       	push	r8
    143c:	9f 92       	push	r9
    143e:	af 92       	push	r10
    1440:	bf 92       	push	r11
    1442:	cf 92       	push	r12
    1444:	df 92       	push	r13
    1446:	ef 92       	push	r14
    1448:	ff 92       	push	r15
    144a:	0f 93       	push	r16
    144c:	1f 93       	push	r17
    144e:	df 93       	push	r29
    1450:	cf 93       	push	r28
    1452:	00 d0       	rcall	.+0      	; 0x1454 <TCP_Task+0x26>
    1454:	cd b7       	in	r28, 0x3d	; 61
    1456:	de b7       	in	r29, 0x3e	; 62
    1458:	59 e0       	ldi	r21, 0x09	; 9
    145a:	c5 2e       	mov	r12, r21
    145c:	5d e0       	ldi	r21, 0x0D	; 13
    145e:	d5 2e       	mov	r13, r21
    1460:	00 e0       	ldi	r16, 0x00	; 0
    1462:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    1464:	46 e1       	ldi	r20, 0x16	; 22
    1466:	e4 2e       	mov	r14, r20
    1468:	42 e0       	ldi	r20, 0x02	; 2
    146a:	f4 2e       	mov	r15, r20
    146c:	1c c0       	rjmp	.+56     	; 0x14a6 <TCP_Task+0x78>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    146e:	80 91 4d 13 	lds	r24, 0x134D
    1472:	81 30       	cpi	r24, 0x01	; 1
    1474:	79 f4       	brne	.+30     	; 0x1494 <TCP_Task+0x66>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    1476:	0e 9d       	mul	r16, r14
    1478:	b0 01       	movw	r22, r0
    147a:	0f 9d       	mul	r16, r15
    147c:	70 0d       	add	r23, r0
    147e:	1e 9d       	mul	r17, r14
    1480:	70 0d       	add	r23, r0
    1482:	11 24       	eor	r1, r1
    1484:	67 5e       	subi	r22, 0xE7	; 231
    1486:	72 4f       	sbci	r23, 0xF2	; 242
    1488:	e0 91 4e 13 	lds	r30, 0x134E
    148c:	f0 91 4f 13 	lds	r31, 0x134F
    1490:	c6 01       	movw	r24, r12
    1492:	09 95       	icall
    1494:	0f 5f       	subi	r16, 0xFF	; 255
    1496:	1f 4f       	sbci	r17, 0xFF	; 255
    1498:	26 e1       	ldi	r18, 0x16	; 22
    149a:	32 e0       	ldi	r19, 0x02	; 2
    149c:	c2 0e       	add	r12, r18
    149e:	d3 1e       	adc	r13, r19
 *  buffer for later transmission.
 */
void TCP_Task(void)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    14a0:	03 30       	cpi	r16, 0x03	; 3
    14a2:	11 05       	cpc	r17, r1
    14a4:	59 f0       	breq	.+22     	; 0x14bc <TCP_Task+0x8e>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    14a6:	20 91 4b 13 	lds	r18, 0x134B
    14aa:	30 91 4c 13 	lds	r19, 0x134C
    14ae:	d6 01       	movw	r26, r12
    14b0:	8d 91       	ld	r24, X+
    14b2:	9c 91       	ld	r25, X
    14b4:	28 17       	cp	r18, r24
    14b6:	39 07       	cpc	r19, r25
    14b8:	69 f7       	brne	.-38     	; 0x1494 <TCP_Task+0x66>
    14ba:	d9 cf       	rjmp	.-78     	; 0x146e <TCP_Task+0x40>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT.FrameLength)
    14bc:	80 91 07 0d 	lds	r24, 0x0D07
    14c0:	90 91 08 0d 	lds	r25, 0x0D08
    14c4:	89 2b       	or	r24, r25
    14c6:	09 f0       	breq	.+2      	; 0x14ca <TCP_Task+0x9c>
    14c8:	26 c1       	rjmp	.+588    	; 0x1716 <TCP_Task+0x2e8>

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    14ca:	80 91 1b 0f 	lds	r24, 0x0F1B
    14ce:	88 23       	and	r24, r24
    14d0:	39 f0       	breq	.+14     	; 0x14e0 <TCP_Task+0xb2>
    14d2:	80 91 1c 0f 	lds	r24, 0x0F1C
    14d6:	88 23       	and	r24, r24
    14d8:	19 f0       	breq	.+6      	; 0x14e0 <TCP_Task+0xb2>
    14da:	1a 82       	std	Y+2, r1	; 0x02
    14dc:	19 82       	std	Y+1, r1	; 0x01
    14de:	1b c0       	rjmp	.+54     	; 0x1516 <TCP_Task+0xe8>
    14e0:	80 91 31 11 	lds	r24, 0x1131
    14e4:	88 23       	and	r24, r24
    14e6:	49 f0       	breq	.+18     	; 0x14fa <TCP_Task+0xcc>
    14e8:	80 91 32 11 	lds	r24, 0x1132
    14ec:	88 23       	and	r24, r24
    14ee:	29 f0       	breq	.+10     	; 0x14fa <TCP_Task+0xcc>
    14f0:	e1 e0       	ldi	r30, 0x01	; 1
    14f2:	f0 e0       	ldi	r31, 0x00	; 0
    14f4:	fa 83       	std	Y+2, r31	; 0x02
    14f6:	e9 83       	std	Y+1, r30	; 0x01
    14f8:	0e c0       	rjmp	.+28     	; 0x1516 <TCP_Task+0xe8>
    14fa:	80 91 47 13 	lds	r24, 0x1347
    14fe:	88 23       	and	r24, r24
    1500:	09 f4       	brne	.+2      	; 0x1504 <TCP_Task+0xd6>
    1502:	09 c1       	rjmp	.+530    	; 0x1716 <TCP_Task+0x2e8>
    1504:	80 91 48 13 	lds	r24, 0x1348
    1508:	88 23       	and	r24, r24
    150a:	09 f4       	brne	.+2      	; 0x150e <TCP_Task+0xe0>
    150c:	04 c1       	rjmp	.+520    	; 0x1716 <TCP_Task+0x2e8>
    150e:	22 e0       	ldi	r18, 0x02	; 2
    1510:	30 e0       	ldi	r19, 0x00	; 0
    1512:	3a 83       	std	Y+2, r19	; 0x02
    1514:	29 83       	std	Y+1, r18	; 0x01
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT.FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t)];
    1516:	3b e2       	ldi	r19, 0x2B	; 43
    1518:	a3 2e       	mov	r10, r19
    151a:	37 e0       	ldi	r19, 0x07	; 7
    151c:	b3 2e       	mov	r11, r19
    151e:	8e e0       	ldi	r24, 0x0E	; 14
    1520:	90 e0       	ldi	r25, 0x00	; 0
    1522:	a8 0e       	add	r10, r24
    1524:	b9 1e       	adc	r11, r25
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                                             sizeof(IP_Header_t)];
    1526:	2b e2       	ldi	r18, 0x2B	; 43
    1528:	c2 2e       	mov	r12, r18
    152a:	27 e0       	ldi	r18, 0x07	; 7
    152c:	d2 2e       	mov	r13, r18
    152e:	a2 e2       	ldi	r26, 0x22	; 34
    1530:	b0 e0       	ldi	r27, 0x00	; 0
    1532:	ca 0e       	add	r12, r26
    1534:	db 1e       	adc	r13, r27
			void*                    TCPDataOUT     = &FrameOUT.FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                              sizeof(IP_Header_t) +
			                                                              sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    1536:	86 e1       	ldi	r24, 0x16	; 22
    1538:	92 e0       	ldi	r25, 0x02	; 2
    153a:	e9 81       	ldd	r30, Y+1	; 0x01
    153c:	fa 81       	ldd	r31, Y+2	; 0x02
    153e:	e8 9f       	mul	r30, r24
    1540:	80 01       	movw	r16, r0
    1542:	e9 9f       	mul	r30, r25
    1544:	10 0d       	add	r17, r0
    1546:	f8 9f       	mul	r31, r24
    1548:	10 0d       	add	r17, r0
    154a:	11 24       	eor	r1, r1
    154c:	99 e0       	ldi	r25, 0x09	; 9
    154e:	69 2e       	mov	r6, r25
    1550:	9d e0       	ldi	r25, 0x0D	; 13
    1552:	79 2e       	mov	r7, r25
    1554:	60 0e       	add	r6, r16
    1556:	71 1e       	adc	r7, r17
    1558:	d3 01       	movw	r26, r6
    155a:	50 96       	adiw	r26, 0x10	; 16
    155c:	8d 90       	ld	r8, X+
    155e:	9c 90       	ld	r9, X
    1560:	51 97       	sbiw	r26, 0x11	; 17

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    1562:	8d 91       	ld	r24, X+
    1564:	9c 91       	ld	r25, X
    1566:	90 93 4e 07 	sts	0x074E, r25
    156a:	80 93 4d 07 	sts	0x074D, r24
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    156e:	8b e0       	ldi	r24, 0x0B	; 11
    1570:	91 e0       	ldi	r25, 0x01	; 1
    1572:	9f 01       	movw	r18, r30
    1574:	28 9f       	mul	r18, r24
    1576:	f0 01       	movw	r30, r0
    1578:	29 9f       	mul	r18, r25
    157a:	f0 0d       	add	r31, r0
    157c:	38 9f       	mul	r19, r24
    157e:	f0 0d       	add	r31, r0
    1580:	11 24       	eor	r1, r1
    1582:	ee 0f       	add	r30, r30
    1584:	ff 1f       	adc	r31, r31
    1586:	e5 5f       	subi	r30, 0xF5	; 245
    1588:	f2 4f       	sbci	r31, 0xF2	; 242
    158a:	80 81       	ld	r24, Z
    158c:	91 81       	ldd	r25, Z+1	; 0x01
    158e:	d6 01       	movw	r26, r12
    1590:	13 96       	adiw	r26, 0x03	; 3
    1592:	9c 93       	st	X, r25
    1594:	8e 93       	st	-X, r24
    1596:	12 97       	sbiw	r26, 0x02	; 2
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    1598:	f3 01       	movw	r30, r6
    159a:	64 85       	ldd	r22, Z+12	; 0x0c
    159c:	75 85       	ldd	r23, Z+13	; 0x0d
    159e:	86 85       	ldd	r24, Z+14	; 0x0e
    15a0:	97 85       	ldd	r25, Z+15	; 0x0f
    15a2:	80 da       	rcall	.-2816   	; 0xaa4 <SwapEndian_32>
    15a4:	d6 01       	movw	r26, r12
    15a6:	14 96       	adiw	r26, 0x04	; 4
    15a8:	6d 93       	st	X+, r22
    15aa:	7d 93       	st	X+, r23
    15ac:	8d 93       	st	X+, r24
    15ae:	9c 93       	st	X, r25
    15b0:	17 97       	sbiw	r26, 0x07	; 7
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    15b2:	f3 01       	movw	r30, r6
    15b4:	60 85       	ldd	r22, Z+8	; 0x08
    15b6:	71 85       	ldd	r23, Z+9	; 0x09
    15b8:	82 85       	ldd	r24, Z+10	; 0x0a
    15ba:	93 85       	ldd	r25, Z+11	; 0x0b
    15bc:	73 da       	rcall	.-2842   	; 0xaa4 <SwapEndian_32>
    15be:	d6 01       	movw	r26, r12
    15c0:	18 96       	adiw	r26, 0x08	; 8
    15c2:	6d 93       	st	X+, r22
    15c4:	7d 93       	st	X+, r23
    15c6:	8d 93       	st	X+, r24
    15c8:	9c 93       	st	X, r25
    15ca:	1b 97       	sbiw	r26, 0x0b	; 11
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    15cc:	82 e0       	ldi	r24, 0x02	; 2
    15ce:	90 e0       	ldi	r25, 0x00	; 0
    15d0:	1f 96       	adiw	r26, 0x0f	; 15
    15d2:	9c 93       	st	X, r25
    15d4:	8e 93       	st	-X, r24
    15d6:	1e 97       	sbiw	r26, 0x0e	; 14

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    15d8:	80 e1       	ldi	r24, 0x10	; 16
    15da:	1d 96       	adiw	r26, 0x0d	; 13
    15dc:	8c 93       	st	X, r24
    15de:	1d 97       	sbiw	r26, 0x0d	; 13
			TCPHeaderOUT->UrgentPointer        = 0;
    15e0:	53 96       	adiw	r26, 0x13	; 19
    15e2:	1c 92       	st	X, r1
    15e4:	1e 92       	st	-X, r1
    15e6:	52 97       	sbiw	r26, 0x12	; 18
			TCPHeaderOUT->Checksum             = 0;
    15e8:	51 96       	adiw	r26, 0x11	; 17
    15ea:	1c 92       	st	X, r1
    15ec:	1e 92       	st	-X, r1
    15ee:	50 97       	sbiw	r26, 0x10	; 16
			TCPHeaderOUT->Reserved             = 0;
    15f0:	80 e5       	ldi	r24, 0x50	; 80
    15f2:	1c 96       	adiw	r26, 0x0c	; 12
    15f4:	8c 93       	st	X, r24

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    15f6:	2b e2       	ldi	r18, 0x2B	; 43
    15f8:	37 e0       	ldi	r19, 0x07	; 7
    15fa:	2a 5c       	subi	r18, 0xCA	; 202
    15fc:	3f 4f       	sbci	r19, 0xFF	; 255
    15fe:	05 5e       	subi	r16, 0xE5	; 229
    1600:	12 4f       	sbci	r17, 0xF2	; 242
    1602:	c9 01       	movw	r24, r18
    1604:	b8 01       	movw	r22, r16
    1606:	a4 01       	movw	r20, r8
    1608:	0e 94 9d 16 	call	0x2d3a	; 0x2d3a <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    160c:	c4 01       	movw	r24, r8
    160e:	a0 e0       	ldi	r26, 0x00	; 0
    1610:	b0 e0       	ldi	r27, 0x00	; 0
    1612:	f3 01       	movw	r30, r6
    1614:	24 85       	ldd	r18, Z+12	; 0x0c
    1616:	35 85       	ldd	r19, Z+13	; 0x0d
    1618:	46 85       	ldd	r20, Z+14	; 0x0e
    161a:	57 85       	ldd	r21, Z+15	; 0x0f
    161c:	82 0f       	add	r24, r18
    161e:	93 1f       	adc	r25, r19
    1620:	a4 1f       	adc	r26, r20
    1622:	b5 1f       	adc	r27, r21
    1624:	84 87       	std	Z+12, r24	; 0x0c
    1626:	95 87       	std	Z+13, r25	; 0x0d
    1628:	a6 87       	std	Z+14, r26	; 0x0e
    162a:	b7 87       	std	Z+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
    162c:	24 e1       	ldi	r18, 0x14	; 20
    162e:	30 e0       	ldi	r19, 0x00	; 0
    1630:	82 0e       	add	r8, r18
    1632:	93 1e       	adc	r9, r19
    1634:	20 90 0e 01 	lds	r2, 0x010E
    1638:	30 90 0f 01 	lds	r3, 0x010F
    163c:	40 90 10 01 	lds	r4, 0x0110
    1640:	50 90 11 01 	lds	r5, 0x0111
    1644:	04 81       	ldd	r16, Z+4	; 0x04
    1646:	15 81       	ldd	r17, Z+5	; 0x05
    1648:	26 81       	ldd	r18, Z+6	; 0x06
    164a:	37 81       	ldd	r19, Z+7	; 0x07
    164c:	c6 01       	movw	r24, r12
    164e:	b2 01       	movw	r22, r4
    1650:	a1 01       	movw	r20, r2
    1652:	74 01       	movw	r14, r8
    1654:	2d da       	rcall	.-2982   	; 0xab0 <TCP_Checksum16>
    1656:	d6 01       	movw	r26, r12
    1658:	51 96       	adiw	r26, 0x11	; 17
    165a:	9c 93       	st	X, r25
    165c:	8e 93       	st	-X, r24
    165e:	50 97       	sbiw	r26, 0x10	; 16
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    1660:	84 01       	movw	r16, r8
    1662:	0c 5e       	subi	r16, 0xEC	; 236
    1664:	1f 4f       	sbci	r17, 0xFF	; 255
    1666:	f5 01       	movw	r30, r10
    1668:	12 83       	std	Z+2, r17	; 0x02
    166a:	03 83       	std	Z+3, r16	; 0x03
			IPHeaderOUT->TypeOfService      = 0;
    166c:	11 82       	std	Z+1, r1	; 0x01
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    166e:	85 e4       	ldi	r24, 0x45	; 69
    1670:	80 93 39 07 	sts	0x0739, r24
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    1674:	16 82       	std	Z+6, r1	; 0x06
    1676:	17 82       	std	Z+7, r1	; 0x07
			IPHeaderOUT->Identification     = 0;
    1678:	15 82       	std	Z+5, r1	; 0x05
    167a:	14 82       	std	Z+4, r1	; 0x04
			IPHeaderOUT->HeaderChecksum     = 0;
    167c:	13 86       	std	Z+11, r1	; 0x0b
    167e:	12 86       	std	Z+10, r1	; 0x0a
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    1680:	86 e0       	ldi	r24, 0x06	; 6
    1682:	81 87       	std	Z+9, r24	; 0x09
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    1684:	80 e8       	ldi	r24, 0x80	; 128
    1686:	80 87       	std	Z+8, r24	; 0x08
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    1688:	d5 01       	movw	r26, r10
    168a:	1c 96       	adiw	r26, 0x0c	; 12
    168c:	2d 92       	st	X+, r2
    168e:	3d 92       	st	X+, r3
    1690:	4d 92       	st	X+, r4
    1692:	5c 92       	st	X, r5
    1694:	1f 97       	sbiw	r26, 0x0f	; 15
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    1696:	f3 01       	movw	r30, r6
    1698:	84 81       	ldd	r24, Z+4	; 0x04
    169a:	95 81       	ldd	r25, Z+5	; 0x05
    169c:	a6 81       	ldd	r26, Z+6	; 0x06
    169e:	b7 81       	ldd	r27, Z+7	; 0x07
    16a0:	f5 01       	movw	r30, r10
    16a2:	80 8b       	std	Z+16, r24	; 0x10
    16a4:	91 8b       	std	Z+17, r25	; 0x11
    16a6:	a2 8b       	std	Z+18, r26	; 0x12
    16a8:	b3 8b       	std	Z+19, r27	; 0x13

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    16aa:	c5 01       	movw	r24, r10
    16ac:	64 e1       	ldi	r22, 0x14	; 20
    16ae:	70 e0       	ldi	r23, 0x00	; 0
    16b0:	de d8       	rcall	.-3652   	; 0x86e <Ethernet_Checksum16>
    16b2:	d5 01       	movw	r26, r10
    16b4:	1b 96       	adiw	r26, 0x0b	; 11
    16b6:	9c 93       	st	X, r25
    16b8:	8e 93       	st	-X, r24
    16ba:	1a 97       	sbiw	r26, 0x0a	; 10

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    16bc:	ab e2       	ldi	r26, 0x2B	; 43
    16be:	b7 e0       	ldi	r27, 0x07	; 7
    16c0:	16 96       	adiw	r26, 0x06	; 6
    16c2:	e8 e0       	ldi	r30, 0x08	; 8
    16c4:	f1 e0       	ldi	r31, 0x01	; 1
    16c6:	86 e0       	ldi	r24, 0x06	; 6
    16c8:	01 90       	ld	r0, Z+
    16ca:	0d 92       	st	X+, r0
    16cc:	81 50       	subi	r24, 0x01	; 1
    16ce:	e1 f7       	brne	.-8      	; 0x16c8 <TCP_Task+0x29a>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    16d0:	ab e2       	ldi	r26, 0x2B	; 43
    16d2:	b7 e0       	ldi	r27, 0x07	; 7
    16d4:	e0 e2       	ldi	r30, 0x20	; 32
    16d6:	f1 e0       	ldi	r31, 0x01	; 1
    16d8:	86 e0       	ldi	r24, 0x06	; 6
    16da:	01 90       	ld	r0, Z+
    16dc:	0d 92       	st	X+, r0
    16de:	81 50       	subi	r24, 0x01	; 1
    16e0:	e1 f7       	brne	.-8      	; 0x16da <TCP_Task+0x2ac>
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    16e2:	88 e0       	ldi	r24, 0x08	; 8
    16e4:	90 e0       	ldi	r25, 0x00	; 0
    16e6:	90 93 38 07 	sts	0x0738, r25
    16ea:	80 93 37 07 	sts	0x0737, r24

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT.FrameLength            = PacketSize;
    16ee:	02 5f       	subi	r16, 0xF2	; 242
    16f0:	1f 4f       	sbci	r17, 0xFF	; 255
    16f2:	10 93 08 0d 	sts	0x0D08, r17
    16f6:	00 93 07 0d 	sts	0x0D07, r16

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    16fa:	86 e1       	ldi	r24, 0x16	; 22
    16fc:	92 e0       	ldi	r25, 0x02	; 2
    16fe:	29 81       	ldd	r18, Y+1	; 0x01
    1700:	3a 81       	ldd	r19, Y+2	; 0x02
    1702:	28 9f       	mul	r18, r24
    1704:	f0 01       	movw	r30, r0
    1706:	29 9f       	mul	r18, r25
    1708:	f0 0d       	add	r31, r0
    170a:	38 9f       	mul	r19, r24
    170c:	f0 0d       	add	r31, r0
    170e:	11 24       	eor	r1, r1
    1710:	e4 5e       	subi	r30, 0xE4	; 228
    1712:	f0 4f       	sbci	r31, 0xF0	; 240
    1714:	10 82       	st	Z, r1

			break;
		}
	}
}
    1716:	0f 90       	pop	r0
    1718:	0f 90       	pop	r0
    171a:	cf 91       	pop	r28
    171c:	df 91       	pop	r29
    171e:	1f 91       	pop	r17
    1720:	0f 91       	pop	r16
    1722:	ff 90       	pop	r15
    1724:	ef 90       	pop	r14
    1726:	df 90       	pop	r13
    1728:	cf 90       	pop	r12
    172a:	bf 90       	pop	r11
    172c:	af 90       	pop	r10
    172e:	9f 90       	pop	r9
    1730:	8f 90       	pop	r8
    1732:	7f 90       	pop	r7
    1734:	6f 90       	pop	r6
    1736:	5f 90       	pop	r5
    1738:	4f 90       	pop	r4
    173a:	3f 90       	pop	r3
    173c:	2f 90       	pop	r2
    173e:	08 95       	ret

00001740 <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    1740:	ef 92       	push	r14
    1742:	ff 92       	push	r15
    1744:	0f 93       	push	r16
    1746:	1f 93       	push	r17
    1748:	cf 93       	push	r28
    174a:	df 93       	push	r29
    174c:	7c 01       	movw	r14, r24
    174e:	eb 01       	movw	r28, r22
    1750:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    1752:	cb 01       	movw	r24, r22
    1754:	31 d9       	rcall	.-3486   	; 0x9b8 <DecodeUDPHeader>
    1756:	8a 81       	ldd	r24, Y+2	; 0x02
    1758:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    175a:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    175c:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    175e:	92 2f       	mov	r25, r18

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    1760:	83 34       	cpi	r24, 0x43	; 67
    1762:	91 05       	cpc	r25, r1
    1764:	e9 f4       	brne	.+58     	; 0x17a0 <UDP_ProcessUDPPacket+0x60>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1766:	be 01       	movw	r22, r28
    1768:	68 5f       	subi	r22, 0xF8	; 248
    176a:	7f 4f       	sbci	r23, 0xFF	; 255
    176c:	a8 01       	movw	r20, r16
    176e:	48 5f       	subi	r20, 0xF8	; 248
    1770:	5f 4f       	sbci	r21, 0xFF	; 255
    1772:	c7 01       	movw	r24, r14
    1774:	1f d0       	rcall	.+62     	; 0x17b4 <DHCP_ProcessDHCPPacket>
    1776:	9c 01       	movw	r18, r24
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1778:	18 16       	cp	r1, r24
    177a:	19 06       	cpc	r1, r25
    177c:	8c f4       	brge	.+34     	; 0x17a0 <UDP_ProcessUDPPacket+0x60>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    177e:	8a 81       	ldd	r24, Y+2	; 0x02
    1780:	9b 81       	ldd	r25, Y+3	; 0x03
    1782:	f8 01       	movw	r30, r16
    1784:	91 83       	std	Z+1, r25	; 0x01
    1786:	80 83       	st	Z, r24
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1788:	88 81       	ld	r24, Y
    178a:	99 81       	ldd	r25, Y+1	; 0x01
    178c:	93 83       	std	Z+3, r25	; 0x03
    178e:	82 83       	std	Z+2, r24	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    1790:	17 82       	std	Z+7, r1	; 0x07
    1792:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    1794:	c9 01       	movw	r24, r18
    1796:	08 96       	adiw	r24, 0x08	; 8
    1798:	94 83       	std	Z+4, r25	; 0x04
    179a:	85 83       	std	Z+5, r24	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    179c:	9c 01       	movw	r18, r24
    179e:	02 c0       	rjmp	.+4      	; 0x17a4 <UDP_ProcessUDPPacket+0x64>
    17a0:	20 e0       	ldi	r18, 0x00	; 0
    17a2:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    17a4:	c9 01       	movw	r24, r18
    17a6:	df 91       	pop	r29
    17a8:	cf 91       	pop	r28
    17aa:	1f 91       	pop	r17
    17ac:	0f 91       	pop	r16
    17ae:	ff 90       	pop	r15
    17b0:	ef 90       	pop	r14
    17b2:	08 95       	ret

000017b4 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    17b4:	8f 92       	push	r8
    17b6:	9f 92       	push	r9
    17b8:	af 92       	push	r10
    17ba:	bf 92       	push	r11
    17bc:	cf 92       	push	r12
    17be:	df 92       	push	r13
    17c0:	ef 92       	push	r14
    17c2:	ff 92       	push	r15
    17c4:	0f 93       	push	r16
    17c6:	1f 93       	push	r17
    17c8:	cf 93       	push	r28
    17ca:	df 93       	push	r29
    17cc:	8b 01       	movw	r16, r22
    17ce:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
    17d0:	5c 01       	movw	r10, r24
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    17d2:	80 ef       	ldi	r24, 0xF0	; 240
    17d4:	88 2e       	mov	r8, r24
    17d6:	91 2c       	mov	r9, r1
    17d8:	86 0e       	add	r8, r22
    17da:	97 1e       	adc	r9, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    17dc:	cb 01       	movw	r24, r22
    17de:	ed d8       	rcall	.-3622   	; 0x9ba <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    17e0:	80 ef       	ldi	r24, 0xF0	; 240
    17e2:	fe 01       	movw	r30, r28
    17e4:	11 92       	st	Z+, r1
    17e6:	8a 95       	dec	r24
    17e8:	e9 f7       	brne	.-6      	; 0x17e4 <DHCP_ProcessDHCPPacket+0x30>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    17ea:	f8 01       	movw	r30, r16
    17ec:	81 81       	ldd	r24, Z+1	; 0x01
    17ee:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    17f0:	82 e0       	ldi	r24, 0x02	; 2
    17f2:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    17f4:	82 81       	ldd	r24, Z+2	; 0x02
    17f6:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    17f8:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    17fa:	84 81       	ldd	r24, Z+4	; 0x04
    17fc:	95 81       	ldd	r25, Z+5	; 0x05
    17fe:	a6 81       	ldd	r26, Z+6	; 0x06
    1800:	b7 81       	ldd	r27, Z+7	; 0x07
    1802:	8c 83       	std	Y+4, r24	; 0x04
    1804:	9d 83       	std	Y+5, r25	; 0x05
    1806:	ae 83       	std	Y+6, r26	; 0x06
    1808:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    180a:	19 86       	std	Y+9, r1	; 0x09
    180c:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    180e:	82 85       	ldd	r24, Z+10	; 0x0a
    1810:	93 85       	ldd	r25, Z+11	; 0x0b
    1812:	9b 87       	std	Y+11, r25	; 0x0b
    1814:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    1816:	c0 90 1c 01 	lds	r12, 0x011C
    181a:	d0 90 1d 01 	lds	r13, 0x011D
    181e:	e0 90 1e 01 	lds	r14, 0x011E
    1822:	f0 90 1f 01 	lds	r15, 0x011F
    1826:	c8 8a       	std	Y+16, r12	; 0x10
    1828:	d9 8a       	std	Y+17, r13	; 0x11
    182a:	ea 8a       	std	Y+18, r14	; 0x12
    182c:	fb 8a       	std	Y+19, r15	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    182e:	04 5e       	subi	r16, 0xE4	; 228
    1830:	1f 4f       	sbci	r17, 0xFF	; 255
    1832:	ce 01       	movw	r24, r28
    1834:	4c 96       	adiw	r24, 0x1c	; 28
    1836:	b8 01       	movw	r22, r16
    1838:	46 e0       	ldi	r20, 0x06	; 6
    183a:	50 e0       	ldi	r21, 0x00	; 0
    183c:	0e 94 a6 16 	call	0x2d4c	; 0x2d4c <memmove>
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    1840:	c4 51       	subi	r28, 0x14	; 20
    1842:	df 4f       	sbci	r29, 0xFF	; 255
    1844:	83 e6       	ldi	r24, 0x63	; 99
    1846:	92 e8       	ldi	r25, 0x82	; 130
    1848:	a3 e5       	ldi	r26, 0x53	; 83
    184a:	b3 e6       	ldi	r27, 0x63	; 99
    184c:	88 83       	st	Y, r24
    184e:	99 83       	std	Y+1, r25	; 0x01
    1850:	aa 83       	std	Y+2, r26	; 0x02
    1852:	bb 83       	std	Y+3, r27	; 0x03
    1854:	cc 5e       	subi	r28, 0xEC	; 236
    1856:	d0 40       	sbci	r29, 0x00	; 0

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    1858:	f5 01       	movw	r30, r10
    185a:	c4 86       	std	Z+12, r12	; 0x0c
    185c:	d5 86       	std	Z+13, r13	; 0x0d
    185e:	e6 86       	std	Z+14, r14	; 0x0e
    1860:	f7 86       	std	Z+15, r15	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1862:	80 91 0e 01 	lds	r24, 0x010E
    1866:	90 91 0f 01 	lds	r25, 0x010F
    186a:	a0 91 10 01 	lds	r26, 0x0110
    186e:	b0 91 11 01 	lds	r27, 0x0111
    1872:	80 8b       	std	Z+16, r24	; 0x10
    1874:	91 8b       	std	Z+17, r25	; 0x11
    1876:	a2 8b       	std	Z+18, r26	; 0x12
    1878:	b3 8b       	std	Z+19, r27	; 0x13
    187a:	5b c0       	rjmp	.+182    	; 0x1932 <DHCP_ProcessDHCPPacket+0x17e>

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    187c:	85 33       	cpi	r24, 0x35	; 53
    187e:	09 f0       	breq	.+2      	; 0x1882 <DHCP_ProcessDHCPPacket+0xce>
    1880:	4d c0       	rjmp	.+154    	; 0x191c <DHCP_ProcessDHCPPacket+0x168>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    1882:	94 01       	movw	r18, r8
    1884:	2e 5f       	subi	r18, 0xFE	; 254
    1886:	3f 4f       	sbci	r19, 0xFF	; 255
    1888:	f4 01       	movw	r30, r8
    188a:	82 81       	ldd	r24, Z+2	; 0x02
    188c:	81 30       	cpi	r24, 0x01	; 1
    188e:	19 f0       	breq	.+6      	; 0x1896 <DHCP_ProcessDHCPPacket+0xe2>
    1890:	83 30       	cpi	r24, 0x03	; 3
    1892:	09 f0       	breq	.+2      	; 0x1896 <DHCP_ProcessDHCPPacket+0xe2>
    1894:	48 c0       	rjmp	.+144    	; 0x1926 <DHCP_ProcessDHCPPacket+0x172>
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));
    1896:	fe 01       	movw	r30, r28
    1898:	e0 51       	subi	r30, 0x10	; 16
    189a:	ff 4f       	sbci	r31, 0xFF	; 255
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    189c:	df 01       	movw	r26, r30
    189e:	85 e3       	ldi	r24, 0x35	; 53
    18a0:	8d 93       	st	X+, r24
				*(DHCPOptionsOUTStart++) = 1;
    18a2:	81 e0       	ldi	r24, 0x01	; 1
    18a4:	81 83       	std	Z+1, r24	; 0x01
    18a6:	ed 01       	movw	r28, r26
    18a8:	21 96       	adiw	r28, 0x01	; 1
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    18aa:	f9 01       	movw	r30, r18
    18ac:	80 81       	ld	r24, Z
    18ae:	81 30       	cpi	r24, 0x01	; 1
    18b0:	11 f0       	breq	.+4      	; 0x18b6 <DHCP_ProcessDHCPPacket+0x102>
    18b2:	85 e0       	ldi	r24, 0x05	; 5
    18b4:	01 c0       	rjmp	.+2      	; 0x18b8 <DHCP_ProcessDHCPPacket+0x104>
    18b6:	82 e0       	ldi	r24, 0x02	; 2
    18b8:	11 96       	adiw	r26, 0x01	; 1
    18ba:	8c 93       	st	X, r24
    18bc:	fe 01       	movw	r30, r28
    18be:	31 96       	adiw	r30, 0x01	; 1
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    18c0:	81 e0       	ldi	r24, 0x01	; 1
    18c2:	89 83       	std	Y+1, r24	; 0x01
    18c4:	cf 01       	movw	r24, r30
    18c6:	01 96       	adiw	r24, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 4;
    18c8:	34 e0       	ldi	r19, 0x04	; 4
    18ca:	31 83       	std	Z+1, r19	; 0x01
    18cc:	dc 01       	movw	r26, r24
    18ce:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    18d0:	2f ef       	ldi	r18, 0xFF	; 255
    18d2:	fc 01       	movw	r30, r24
    18d4:	21 83       	std	Z+1, r18	; 0x01
    18d6:	fd 01       	movw	r30, r26
    18d8:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    18da:	11 96       	adiw	r26, 0x01	; 1
    18dc:	2c 93       	st	X, r18
    18de:	df 01       	movw	r26, r30
    18e0:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    18e2:	21 83       	std	Z+1, r18	; 0x01
    18e4:	fd 01       	movw	r30, r26
    18e6:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0x00;
    18e8:	11 96       	adiw	r26, 0x01	; 1
    18ea:	1c 92       	st	X, r1
    18ec:	df 01       	movw	r26, r30
    18ee:	11 96       	adiw	r26, 0x01	; 1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    18f0:	86 e3       	ldi	r24, 0x36	; 54
    18f2:	81 83       	std	Z+1, r24	; 0x01
    18f4:	fd 01       	movw	r30, r26
    18f6:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    18f8:	11 96       	adiw	r26, 0x01	; 1
    18fa:	3c 93       	st	X, r19
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    18fc:	80 91 0e 01 	lds	r24, 0x010E
    1900:	90 91 0f 01 	lds	r25, 0x010F
    1904:	a0 91 10 01 	lds	r26, 0x0110
    1908:	b0 91 11 01 	lds	r27, 0x0111
    190c:	81 83       	std	Z+1, r24	; 0x01
    190e:	92 83       	std	Z+2, r25	; 0x02
    1910:	a3 83       	std	Z+3, r26	; 0x03
    1912:	b4 83       	std	Z+4, r27	; 0x04
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    1914:	25 83       	std	Z+5, r18	; 0x05
    1916:	20 e0       	ldi	r18, 0x00	; 0
    1918:	31 e0       	ldi	r19, 0x01	; 1
    191a:	12 c0       	rjmp	.+36     	; 0x1940 <DHCP_ProcessDHCPPacket+0x18c>
				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    191c:	88 23       	and	r24, r24
    191e:	19 f4       	brne	.+6      	; 0x1926 <DHCP_ProcessDHCPPacket+0x172>
    1920:	81 e0       	ldi	r24, 0x01	; 1
    1922:	90 e0       	ldi	r25, 0x00	; 0
    1924:	04 c0       	rjmp	.+8      	; 0x192e <DHCP_ProcessDHCPPacket+0x17a>
    1926:	f4 01       	movw	r30, r8
    1928:	81 81       	ldd	r24, Z+1	; 0x01
    192a:	90 e0       	ldi	r25, 0x00	; 0
    192c:	02 96       	adiw	r24, 0x02	; 2
    192e:	88 0e       	add	r8, r24
    1930:	99 1e       	adc	r9, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1932:	f4 01       	movw	r30, r8
    1934:	80 81       	ld	r24, Z
    1936:	8f 3f       	cpi	r24, 0xFF	; 255
    1938:	09 f0       	breq	.+2      	; 0x193c <DHCP_ProcessDHCPPacket+0x188>
    193a:	a0 cf       	rjmp	.-192    	; 0x187c <DHCP_ProcessDHCPPacket+0xc8>
    193c:	20 e0       	ldi	r18, 0x00	; 0
    193e:	30 e0       	ldi	r19, 0x00	; 0
		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
}
    1940:	c9 01       	movw	r24, r18
    1942:	df 91       	pop	r29
    1944:	cf 91       	pop	r28
    1946:	1f 91       	pop	r17
    1948:	0f 91       	pop	r16
    194a:	ff 90       	pop	r15
    194c:	ef 90       	pop	r14
    194e:	df 90       	pop	r13
    1950:	cf 90       	pop	r12
    1952:	bf 90       	pop	r11
    1954:	af 90       	pop	r10
    1956:	9f 90       	pop	r9
    1958:	8f 90       	pop	r8
    195a:	08 95       	ret

0000195c <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    195c:	ef 92       	push	r14
    195e:	ff 92       	push	r15
    1960:	0f 93       	push	r16
    1962:	1f 93       	push	r17
    1964:	cf 93       	push	r28
    1966:	df 93       	push	r29
    1968:	18 2f       	mov	r17, r24
    196a:	09 2f       	mov	r16, r25
    196c:	f6 2e       	mov	r15, r22
    196e:	e7 2e       	mov	r14, r23
	DecodeARPHeader(InDataStart);
    1970:	1f d8       	rcall	.-4034   	; 0x9b0 <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
    1972:	c1 2f       	mov	r28, r17
    1974:	d0 2f       	mov	r29, r16
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1976:	8a 81       	ldd	r24, Y+2	; 0x02
    1978:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    197a:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    197c:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    197e:	92 2f       	mov	r25, r18
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    1980:	80 50       	subi	r24, 0x00	; 0
    1982:	98 40       	sbci	r25, 0x08	; 8
    1984:	09 f0       	breq	.+2      	; 0x1988 <ARP_ProcessARPPacket+0x2c>
    1986:	5e c0       	rjmp	.+188    	; 0x1a44 <ARP_ProcessARPPacket+0xe8>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1988:	8e 81       	ldd	r24, Y+6	; 0x06
    198a:	9f 81       	ldd	r25, Y+7	; 0x07

				Temp = Data.Bytes[0];
    198c:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    198e:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    1990:	92 2f       	mov	r25, r18
    1992:	01 97       	sbiw	r24, 0x01	; 1
    1994:	09 f0       	breq	.+2      	; 0x1998 <ARP_ProcessARPPacket+0x3c>
    1996:	56 c0       	rjmp	.+172    	; 0x1a44 <ARP_ProcessARPPacket+0xe8>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1998:	ce 01       	movw	r24, r28
    199a:	48 96       	adiw	r24, 0x18	; 24
    199c:	6e e0       	ldi	r22, 0x0E	; 14
    199e:	71 e0       	ldi	r23, 0x01	; 1
    19a0:	44 e0       	ldi	r20, 0x04	; 4
    19a2:	50 e0       	ldi	r21, 0x00	; 0
    19a4:	0e 94 90 16 	call	0x2d20	; 0x2d20 <memcmp>
    19a8:	00 97       	sbiw	r24, 0x00	; 0
    19aa:	59 f0       	breq	.+22     	; 0x19c2 <ARP_ProcessARPPacket+0x66>
    19ac:	ce 01       	movw	r24, r28
    19ae:	42 96       	adiw	r24, 0x12	; 18
    19b0:	68 e0       	ldi	r22, 0x08	; 8
    19b2:	71 e0       	ldi	r23, 0x01	; 1
    19b4:	46 e0       	ldi	r20, 0x06	; 6
    19b6:	50 e0       	ldi	r21, 0x00	; 0
    19b8:	0e 94 90 16 	call	0x2d20	; 0x2d20 <memcmp>
    19bc:	00 97       	sbiw	r24, 0x00	; 0
    19be:	09 f0       	breq	.+2      	; 0x19c2 <ARP_ProcessARPPacket+0x66>
    19c0:	41 c0       	rjmp	.+130    	; 0x1a44 <ARP_ProcessARPPacket+0xe8>
                             void* OutDataStart)
{
	DecodeARPHeader(InDataStart);

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;
    19c2:	ef 2d       	mov	r30, r15
    19c4:	fe 2d       	mov	r31, r14
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    19c6:	88 81       	ld	r24, Y
    19c8:	99 81       	ldd	r25, Y+1	; 0x01
    19ca:	91 83       	std	Z+1, r25	; 0x01
    19cc:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    19ce:	8a 81       	ldd	r24, Y+2	; 0x02
    19d0:	9b 81       	ldd	r25, Y+3	; 0x03
    19d2:	93 83       	std	Z+3, r25	; 0x03
    19d4:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    19d6:	8c 81       	ldd	r24, Y+4	; 0x04
    19d8:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    19da:	8d 81       	ldd	r24, Y+5	; 0x05
    19dc:	85 83       	std	Z+5, r24	; 0x05
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    19de:	80 e0       	ldi	r24, 0x00	; 0
    19e0:	92 e0       	ldi	r25, 0x02	; 2
    19e2:	97 83       	std	Z+7, r25	; 0x07
    19e4:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    19e6:	9f 01       	movw	r18, r30
    19e8:	2e 5e       	subi	r18, 0xEE	; 238
    19ea:	3f 4f       	sbci	r19, 0xFF	; 255
    19ec:	ae 01       	movw	r20, r28
    19ee:	48 5f       	subi	r20, 0xF8	; 248
    19f0:	5f 4f       	sbci	r21, 0xFF	; 255
    19f2:	86 e0       	ldi	r24, 0x06	; 6
    19f4:	da 01       	movw	r26, r20
    19f6:	0d 90       	ld	r0, X+
    19f8:	ad 01       	movw	r20, r26
    19fa:	d9 01       	movw	r26, r18
    19fc:	0d 92       	st	X+, r0
    19fe:	9d 01       	movw	r18, r26
    1a00:	81 50       	subi	r24, 0x01	; 1
    1a02:	c1 f7       	brne	.-16     	; 0x19f4 <ARP_ProcessARPPacket+0x98>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    1a04:	8e 85       	ldd	r24, Y+14	; 0x0e
    1a06:	9f 85       	ldd	r25, Y+15	; 0x0f
    1a08:	a8 89       	ldd	r26, Y+16	; 0x10
    1a0a:	b9 89       	ldd	r27, Y+17	; 0x11
    1a0c:	80 8f       	std	Z+24, r24	; 0x18
    1a0e:	91 8f       	std	Z+25, r25	; 0x19
    1a10:	a2 8f       	std	Z+26, r26	; 0x1a
    1a12:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    1a14:	ef 01       	movw	r28, r30
    1a16:	28 96       	adiw	r28, 0x08	; 8
    1a18:	a8 e0       	ldi	r26, 0x08	; 8
    1a1a:	b1 e0       	ldi	r27, 0x01	; 1
    1a1c:	86 e0       	ldi	r24, 0x06	; 6
    1a1e:	0d 90       	ld	r0, X+
    1a20:	09 92       	st	Y+, r0
    1a22:	81 50       	subi	r24, 0x01	; 1
    1a24:	e1 f7       	brne	.-8      	; 0x1a1e <ARP_ProcessARPPacket+0xc2>
			ARPHeaderOUT->SPA = ServerIPAddress;
    1a26:	80 91 0e 01 	lds	r24, 0x010E
    1a2a:	90 91 0f 01 	lds	r25, 0x010F
    1a2e:	a0 91 10 01 	lds	r26, 0x0110
    1a32:	b0 91 11 01 	lds	r27, 0x0111
    1a36:	86 87       	std	Z+14, r24	; 0x0e
    1a38:	97 87       	std	Z+15, r25	; 0x0f
    1a3a:	a0 8b       	std	Z+16, r26	; 0x10
    1a3c:	b1 8b       	std	Z+17, r27	; 0x11
    1a3e:	2c e1       	ldi	r18, 0x1C	; 28
    1a40:	30 e0       	ldi	r19, 0x00	; 0
    1a42:	02 c0       	rjmp	.+4      	; 0x1a48 <ARP_ProcessARPPacket+0xec>

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    1a44:	20 e0       	ldi	r18, 0x00	; 0
    1a46:	30 e0       	ldi	r19, 0x00	; 0
		}
	}

	return NO_RESPONSE;
}
    1a48:	c9 01       	movw	r24, r18
    1a4a:	df 91       	pop	r29
    1a4c:	cf 91       	pop	r28
    1a4e:	1f 91       	pop	r17
    1a50:	0f 91       	pop	r16
    1a52:	ff 90       	pop	r15
    1a54:	ef 90       	pop	r14
    1a56:	08 95       	ret

00001a58 <IP_ProcessIPPacket>:
 *           response was generated, NO_PROCESS if the packet processing was deferred until the
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(void* InDataStart,
                           void* OutDataStart)
{
    1a58:	df 92       	push	r13
    1a5a:	ef 92       	push	r14
    1a5c:	ff 92       	push	r15
    1a5e:	0f 93       	push	r16
    1a60:	1f 93       	push	r17
    1a62:	cf 93       	push	r28
    1a64:	df 93       	push	r29
    1a66:	7c 01       	movw	r14, r24
    1a68:	eb 01       	movw	r28, r22
	DecodeIPHeader(InDataStart);
    1a6a:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1a6e:	f7 01       	movw	r30, r14
    1a70:	d0 80       	ld	r13, Z
    1a72:	ff e0       	ldi	r31, 0x0F	; 15
    1a74:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    1a76:	87 01       	movw	r16, r14
    1a78:	00 5f       	subi	r16, 0xF0	; 240
    1a7a:	1f 4f       	sbci	r17, 0xFF	; 255
    1a7c:	c8 01       	movw	r24, r16
    1a7e:	6e e0       	ldi	r22, 0x0E	; 14
    1a80:	71 e0       	ldi	r23, 0x01	; 1
    1a82:	44 e0       	ldi	r20, 0x04	; 4
    1a84:	50 e0       	ldi	r21, 0x00	; 0
    1a86:	0e 94 90 16 	call	0x2d20	; 0x2d20 <memcmp>
    1a8a:	00 97       	sbiw	r24, 0x00	; 0
    1a8c:	49 f0       	breq	.+18     	; 0x1aa0 <IP_ProcessIPPacket+0x48>
    1a8e:	c8 01       	movw	r24, r16
    1a90:	68 e1       	ldi	r22, 0x18	; 24
    1a92:	71 e0       	ldi	r23, 0x01	; 1
    1a94:	44 e0       	ldi	r20, 0x04	; 4
    1a96:	50 e0       	ldi	r21, 0x00	; 0
    1a98:	0e 94 90 16 	call	0x2d20	; 0x2d20 <memcmp>
    1a9c:	00 97       	sbiw	r24, 0x00	; 0
    1a9e:	71 f4       	brne	.+28     	; 0x1abc <IP_ProcessIPPacket+0x64>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1aa0:	2d 2d       	mov	r18, r13
    1aa2:	30 e0       	ldi	r19, 0x00	; 0
    1aa4:	22 0f       	add	r18, r18
    1aa6:	33 1f       	adc	r19, r19
    1aa8:	22 0f       	add	r18, r18
    1aaa:	33 1f       	adc	r19, r19
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1aac:	f7 01       	movw	r30, r14
    1aae:	81 85       	ldd	r24, Z+9	; 0x09
    1ab0:	86 30       	cpi	r24, 0x06	; 6
    1ab2:	81 f0       	breq	.+32     	; 0x1ad4 <IP_ProcessIPPacket+0x7c>
    1ab4:	81 31       	cpi	r24, 0x11	; 17
    1ab6:	b9 f0       	breq	.+46     	; 0x1ae6 <IP_ProcessIPPacket+0x8e>
    1ab8:	81 30       	cpi	r24, 0x01	; 1
    1aba:	19 f0       	breq	.+6      	; 0x1ac2 <IP_ProcessIPPacket+0x6a>
    1abc:	20 e0       	ldi	r18, 0x00	; 0
    1abe:	30 e0       	ldi	r19, 0x00	; 0
    1ac0:	49 c0       	rjmp	.+146    	; 0x1b54 <IP_ProcessIPPacket+0xfc>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(&((uint8_t*)InDataStart)[HeaderLengthBytes],
    1ac2:	be 01       	movw	r22, r28
    1ac4:	6c 5e       	subi	r22, 0xEC	; 236
    1ac6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ac8:	c7 01       	movw	r24, r14
    1aca:	82 0f       	add	r24, r18
    1acc:	93 1f       	adc	r25, r19
    1ace:	0e 94 de 04 	call	0x9bc	; 0x9bc <ICMP_ProcessICMPPacket>
    1ad2:	11 c0       	rjmp	.+34     	; 0x1af6 <IP_ProcessIPPacket+0x9e>
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    1ad4:	2e 0d       	add	r18, r14
    1ad6:	3f 1d       	adc	r19, r15
    1ad8:	ae 01       	movw	r20, r28
    1ada:	4c 5e       	subi	r20, 0xEC	; 236
    1adc:	5f 4f       	sbci	r21, 0xFF	; 255
    1ade:	c7 01       	movw	r24, r14
    1ae0:	b9 01       	movw	r22, r18
    1ae2:	00 da       	rcall	.-3072   	; 0xee4 <TCP_ProcessTCPPacket>
    1ae4:	08 c0       	rjmp	.+16     	; 0x1af6 <IP_ProcessIPPacket+0x9e>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    1ae6:	2e 0d       	add	r18, r14
    1ae8:	3f 1d       	adc	r19, r15
    1aea:	ae 01       	movw	r20, r28
    1aec:	4c 5e       	subi	r20, 0xEC	; 236
    1aee:	5f 4f       	sbci	r21, 0xFF	; 255
    1af0:	c7 01       	movw	r24, r14
    1af2:	b9 01       	movw	r22, r18
    1af4:	25 de       	rcall	.-950    	; 0x1740 <UDP_ProcessUDPPacket>
    1af6:	9c 01       	movw	r18, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1af8:	18 16       	cp	r1, r24
    1afa:	19 06       	cpc	r1, r25
    1afc:	5c f5       	brge	.+86     	; 0x1b54 <IP_ProcessIPPacket+0xfc>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    1afe:	8c 01       	movw	r16, r24
    1b00:	0c 5e       	subi	r16, 0xEC	; 236
    1b02:	1f 4f       	sbci	r17, 0xFF	; 255
    1b04:	1a 83       	std	Y+2, r17	; 0x02
    1b06:	0b 83       	std	Y+3, r16	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    1b08:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    1b0a:	85 e4       	ldi	r24, 0x45	; 69
    1b0c:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    1b0e:	1e 82       	std	Y+6, r1	; 0x06
    1b10:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    1b12:	1d 82       	std	Y+5, r1	; 0x05
    1b14:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    1b16:	1b 86       	std	Y+11, r1	; 0x0b
    1b18:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    1b1a:	f7 01       	movw	r30, r14
    1b1c:	81 85       	ldd	r24, Z+9	; 0x09
    1b1e:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    1b20:	80 e8       	ldi	r24, 0x80	; 128
    1b22:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    1b24:	80 89       	ldd	r24, Z+16	; 0x10
    1b26:	91 89       	ldd	r25, Z+17	; 0x11
    1b28:	a2 89       	ldd	r26, Z+18	; 0x12
    1b2a:	b3 89       	ldd	r27, Z+19	; 0x13
    1b2c:	8c 87       	std	Y+12, r24	; 0x0c
    1b2e:	9d 87       	std	Y+13, r25	; 0x0d
    1b30:	ae 87       	std	Y+14, r26	; 0x0e
    1b32:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    1b34:	84 85       	ldd	r24, Z+12	; 0x0c
    1b36:	95 85       	ldd	r25, Z+13	; 0x0d
    1b38:	a6 85       	ldd	r26, Z+14	; 0x0e
    1b3a:	b7 85       	ldd	r27, Z+15	; 0x0f
    1b3c:	88 8b       	std	Y+16, r24	; 0x10
    1b3e:	99 8b       	std	Y+17, r25	; 0x11
    1b40:	aa 8b       	std	Y+18, r26	; 0x12
    1b42:	bb 8b       	std	Y+19, r27	; 0x13

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1b44:	ce 01       	movw	r24, r28
    1b46:	64 e1       	ldi	r22, 0x14	; 20
    1b48:	70 e0       	ldi	r23, 0x00	; 0
    1b4a:	0e 94 37 04 	call	0x86e	; 0x86e <Ethernet_Checksum16>
    1b4e:	9b 87       	std	Y+11, r25	; 0x0b
    1b50:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1b52:	98 01       	movw	r18, r16
	}

	return RetSize;
}
    1b54:	c9 01       	movw	r24, r18
    1b56:	df 91       	pop	r29
    1b58:	cf 91       	pop	r28
    1b5a:	1f 91       	pop	r17
    1b5c:	0f 91       	pop	r16
    1b5e:	ff 90       	pop	r15
    1b60:	ef 90       	pop	r14
    1b62:	df 90       	pop	r13
    1b64:	08 95       	ret

00001b66 <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    1b66:	db 01       	movw	r26, r22
    1b68:	0d 90       	ld	r0, X+
    1b6a:	00 20       	and	r0, r0
    1b6c:	e9 f7       	brne	.-6      	; 0x1b68 <IsHTTPCommand+0x2>
    1b6e:	11 97       	sbiw	r26, 0x01	; 1
    1b70:	a6 1b       	sub	r26, r22
    1b72:	b7 0b       	sbc	r27, r23
    1b74:	ad 01       	movw	r20, r26
    1b76:	0e 94 b7 16 	call	0x2d6e	; 0x2d6e <strncmp>
    1b7a:	9c 01       	movw	r18, r24
    1b7c:	80 e0       	ldi	r24, 0x00	; 0
    1b7e:	23 2b       	or	r18, r19
    1b80:	09 f4       	brne	.+2      	; 0x1b84 <IsHTTPCommand+0x1e>
    1b82:	81 e0       	ldi	r24, 0x01	; 1
}
    1b84:	08 95       	ret

00001b86 <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    1b86:	af 92       	push	r10
    1b88:	bf 92       	push	r11
    1b8a:	cf 92       	push	r12
    1b8c:	df 92       	push	r13
    1b8e:	ef 92       	push	r14
    1b90:	ff 92       	push	r15
    1b92:	0f 93       	push	r16
    1b94:	1f 93       	push	r17
    1b96:	cf 93       	push	r28
    1b98:	df 93       	push	r29
    1b9a:	5c 01       	movw	r10, r24
    1b9c:	eb 01       	movw	r28, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1b9e:	8b 01       	movw	r16, r22
    1ba0:	0e 5f       	subi	r16, 0xFE	; 254
    1ba2:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    1ba4:	33 e0       	ldi	r19, 0x03	; 3
    1ba6:	c3 2e       	mov	r12, r19
    1ba8:	32 e0       	ldi	r19, 0x02	; 2
    1baa:	d3 2e       	mov	r13, r19
    1bac:	c6 0e       	add	r12, r22
    1bae:	d7 1e       	adc	r13, r23
    1bb0:	f6 01       	movw	r30, r12
    1bb2:	80 81       	ld	r24, Z
    1bb4:	88 23       	and	r24, r24
    1bb6:	09 f4       	brne	.+2      	; 0x1bba <Webserver_ApplicationCallback+0x34>
    1bb8:	66 c0       	rjmp	.+204    	; 0x1c86 <Webserver_ApplicationCallback+0x100>
    1bba:	22 e0       	ldi	r18, 0x02	; 2
    1bbc:	e2 2e       	mov	r14, r18
    1bbe:	f2 2e       	mov	r15, r18
    1bc0:	e6 0e       	add	r14, r22
    1bc2:	f7 1e       	adc	r15, r23
    1bc4:	f7 01       	movw	r30, r14
    1bc6:	80 81       	ld	r24, Z
    1bc8:	88 23       	and	r24, r24
    1bca:	09 f0       	breq	.+2      	; 0x1bce <Webserver_ApplicationCallback+0x48>
    1bcc:	a7 c0       	rjmp	.+334    	; 0x1d1c <Webserver_ApplicationCallback+0x196>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    1bce:	c8 01       	movw	r24, r16
    1bd0:	66 e2       	ldi	r22, 0x26	; 38
    1bd2:	71 e0       	ldi	r23, 0x01	; 1
    1bd4:	c8 df       	rcall	.-112    	; 0x1b66 <IsHTTPCommand>
    1bd6:	88 23       	and	r24, r24
    1bd8:	f9 f0       	breq	.+62     	; 0x1c18 <Webserver_ApplicationCallback+0x92>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    1bda:	c8 01       	movw	r24, r16
    1bdc:	6a e2       	ldi	r22, 0x2A	; 42
    1bde:	71 e0       	ldi	r23, 0x01	; 1
    1be0:	c2 df       	rcall	.-124    	; 0x1b66 <IsHTTPCommand>
    1be2:	88 23       	and	r24, r24
    1be4:	49 f1       	breq	.+82     	; 0x1c38 <Webserver_ApplicationCallback+0xb2>
			{
				PageBlock = 0;
    1be6:	10 92 46 01 	sts	0x0146, r1

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1bea:	c8 01       	movw	r24, r16
    1bec:	60 e3       	ldi	r22, 0x30	; 48
    1bee:	71 e0       	ldi	r23, 0x01	; 1
    1bf0:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1bf4:	81 e0       	ldi	r24, 0x01	; 1
    1bf6:	f7 01       	movw	r30, r14
    1bf8:	80 83       	st	Z, r24
    1bfa:	f8 01       	movw	r30, r16
    1bfc:	01 90       	ld	r0, Z+
    1bfe:	00 20       	and	r0, r0
    1c00:	e9 f7       	brne	.-6      	; 0x1bfc <Webserver_ApplicationCallback+0x76>
    1c02:	31 97       	sbiw	r30, 0x01	; 1
    1c04:	e0 1b       	sub	r30, r16
    1c06:	f1 0b       	sbc	r31, r17
    1c08:	f9 83       	std	Y+1, r31	; 0x01
    1c0a:	e8 83       	st	Y, r30
    1c0c:	f6 01       	movw	r30, r12
    1c0e:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    1c10:	cc 5f       	subi	r28, 0xFC	; 252
    1c12:	dd 4f       	sbci	r29, 0xFD	; 253
    1c14:	88 83       	st	Y, r24
    1c16:	82 c0       	rjmp	.+260    	; 0x1d1c <Webserver_ApplicationCallback+0x196>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    1c18:	c8 01       	movw	r24, r16
    1c1a:	61 e3       	ldi	r22, 0x31	; 49
    1c1c:	71 e0       	ldi	r23, 0x01	; 1
    1c1e:	a3 df       	rcall	.-186    	; 0x1b66 <IsHTTPCommand>
    1c20:	88 23       	and	r24, r24
    1c22:	11 f1       	breq	.+68     	; 0x1c68 <Webserver_ApplicationCallback+0xe2>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    1c24:	c8 01       	movw	r24, r16
    1c26:	66 e3       	ldi	r22, 0x36	; 54
    1c28:	71 e0       	ldi	r23, 0x01	; 1
    1c2a:	9d df       	rcall	.-198    	; 0x1b66 <IsHTTPCommand>
    1c2c:	88 23       	and	r24, r24
    1c2e:	21 f0       	breq	.+8      	; 0x1c38 <Webserver_ApplicationCallback+0xb2>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1c30:	c8 01       	movw	r24, r16
    1c32:	60 e3       	ldi	r22, 0x30	; 48
    1c34:	71 e0       	ldi	r23, 0x01	; 1
    1c36:	03 c0       	rjmp	.+6      	; 0x1c3e <Webserver_ApplicationCallback+0xb8>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1c38:	c8 01       	movw	r24, r16
    1c3a:	64 e8       	ldi	r22, 0x84	; 132
    1c3c:	71 e0       	ldi	r23, 0x01	; 1
    1c3e:	0e 94 71 16 	call	0x2ce2	; 0x2ce2 <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1c42:	81 e0       	ldi	r24, 0x01	; 1
    1c44:	f7 01       	movw	r30, r14
    1c46:	80 83       	st	Z, r24
    1c48:	f8 01       	movw	r30, r16
    1c4a:	01 90       	ld	r0, Z+
    1c4c:	00 20       	and	r0, r0
    1c4e:	e9 f7       	brne	.-6      	; 0x1c4a <Webserver_ApplicationCallback+0xc4>
    1c50:	31 97       	sbiw	r30, 0x01	; 1
    1c52:	e0 1b       	sub	r30, r16
    1c54:	f1 0b       	sbc	r31, r17
    1c56:	f9 83       	std	Y+1, r31	; 0x01
    1c58:	e8 83       	st	Y, r30
    1c5a:	f6 01       	movw	r30, r12
    1c5c:	80 83       	st	Z, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1c5e:	85 e1       	ldi	r24, 0x15	; 21
    1c60:	92 e0       	ldi	r25, 0x02	; 2
    1c62:	a8 0e       	add	r10, r24
    1c64:	b9 1e       	adc	r11, r25
    1c66:	57 c0       	rjmp	.+174    	; 0x1d16 <Webserver_ApplicationCallback+0x190>
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1c68:	c8 01       	movw	r24, r16
    1c6a:	6e e3       	ldi	r22, 0x3E	; 62
    1c6c:	71 e0       	ldi	r23, 0x01	; 1
    1c6e:	7b df       	rcall	.-266    	; 0x1b66 <IsHTTPCommand>
    1c70:	88 23       	and	r24, r24
    1c72:	21 f0       	breq	.+8      	; 0x1c7c <Webserver_ApplicationCallback+0xf6>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1c74:	81 e0       	ldi	r24, 0x01	; 1
    1c76:	f7 01       	movw	r30, r14
    1c78:	80 83       	st	Z, r24
    1c7a:	ef cf       	rjmp	.-34     	; 0x1c5a <Webserver_ApplicationCallback+0xd4>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1c7c:	f6 01       	movw	r30, r12
    1c7e:	10 82       	st	Z, r1
    1c80:	19 82       	std	Y+1, r1	; 0x01
    1c82:	18 82       	st	Y, r1
    1c84:	4b c0       	rjmp	.+150    	; 0x1d1c <Webserver_ApplicationCallback+0x196>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1c86:	cc 5f       	subi	r28, 0xFC	; 252
    1c88:	dd 4f       	sbci	r29, 0xFD	; 253
    1c8a:	88 81       	ld	r24, Y
    1c8c:	c4 50       	subi	r28, 0x04	; 4
    1c8e:	d2 40       	sbci	r29, 0x02	; 2
    1c90:	88 23       	and	r24, r24
    1c92:	09 f4       	brne	.+2      	; 0x1c96 <Webserver_ApplicationCallback+0x110>
    1c94:	43 c0       	rjmp	.+134    	; 0x1d1c <Webserver_ApplicationCallback+0x196>
    1c96:	ce 5f       	subi	r28, 0xFE	; 254
    1c98:	dd 4f       	sbci	r29, 0xFD	; 253
    1c9a:	88 81       	ld	r24, Y
    1c9c:	c2 50       	subi	r28, 0x02	; 2
    1c9e:	d2 40       	sbci	r29, 0x02	; 2
    1ca0:	88 23       	and	r24, r24
    1ca2:	e1 f1       	breq	.+120    	; 0x1d1c <Webserver_ApplicationCallback+0x196>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1ca4:	80 91 46 01 	lds	r24, 0x0146
    1ca8:	c8 2e       	mov	r12, r24
    1caa:	dd 24       	eor	r13, r13
    1cac:	d6 94       	lsr	r13
    1cae:	dc 2c       	mov	r13, r12
    1cb0:	cc 24       	eor	r12, r12
    1cb2:	d7 94       	ror	r13
    1cb4:	c7 94       	ror	r12
    1cb6:	86 ec       	ldi	r24, 0xC6	; 198
    1cb8:	91 e0       	ldi	r25, 0x01	; 1
    1cba:	c8 0e       	add	r12, r24
    1cbc:	d9 1e       	adc	r13, r25
    1cbe:	c6 01       	movw	r24, r12
    1cc0:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <strlen_P>
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = MIN(RemLength, HTTP_REPLY_BLOCK_SIZE);
    1cc4:	7c 01       	movw	r14, r24
    1cc6:	91 e8       	ldi	r25, 0x81	; 129
    1cc8:	e9 16       	cp	r14, r25
    1cca:	f1 04       	cpc	r15, r1
    1ccc:	18 f0       	brcs	.+6      	; 0x1cd4 <Webserver_ApplicationCallback+0x14e>
    1cce:	80 e8       	ldi	r24, 0x80	; 128
    1cd0:	e8 2e       	mov	r14, r24
    1cd2:	f1 2c       	mov	r15, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1cd4:	c8 01       	movw	r24, r16
    1cd6:	b6 01       	movw	r22, r12
    1cd8:	a7 01       	movw	r20, r14
    1cda:	0e 94 81 16 	call	0x2d02	; 0x2d02 <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1cde:	ce 5f       	subi	r28, 0xFE	; 254
    1ce0:	dd 4f       	sbci	r29, 0xFD	; 253
    1ce2:	81 e0       	ldi	r24, 0x01	; 1
    1ce4:	88 83       	st	Y, r24
    1ce6:	c2 50       	subi	r28, 0x02	; 2
    1ce8:	d2 40       	sbci	r29, 0x02	; 2
    1cea:	f9 82       	std	Y+1, r15	; 0x01
    1cec:	e8 82       	st	Y, r14
    1cee:	cd 5f       	subi	r28, 0xFD	; 253
    1cf0:	dd 4f       	sbci	r29, 0xFD	; 253
    1cf2:	88 83       	st	Y, r24
    1cf4:	c3 50       	subi	r28, 0x03	; 3
    1cf6:	d2 40       	sbci	r29, 0x02	; 2

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    1cf8:	80 91 46 01 	lds	r24, 0x0146
    1cfc:	8f 5f       	subi	r24, 0xFF	; 255
    1cfe:	80 93 46 01 	sts	0x0146, r24
    1d02:	81 50       	subi	r24, 0x01	; 1
    1d04:	83 30       	cpi	r24, 0x03	; 3
    1d06:	51 f4       	brne	.+20     	; 0x1d1c <Webserver_ApplicationCallback+0x196>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1d08:	cc 5f       	subi	r28, 0xFC	; 252
    1d0a:	dd 4f       	sbci	r29, 0xFD	; 253
    1d0c:	18 82       	st	Y, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1d0e:	e5 e1       	ldi	r30, 0x15	; 21
    1d10:	f2 e0       	ldi	r31, 0x02	; 2
    1d12:	ae 0e       	add	r10, r30
    1d14:	bf 1e       	adc	r11, r31
    1d16:	87 e0       	ldi	r24, 0x07	; 7
    1d18:	f5 01       	movw	r30, r10
    1d1a:	80 83       	st	Z, r24
		}
	}
}
    1d1c:	df 91       	pop	r29
    1d1e:	cf 91       	pop	r28
    1d20:	1f 91       	pop	r17
    1d22:	0f 91       	pop	r16
    1d24:	ff 90       	pop	r15
    1d26:	ef 90       	pop	r14
    1d28:	df 90       	pop	r13
    1d2a:	cf 90       	pop	r12
    1d2c:	bf 90       	pop	r11
    1d2e:	af 90       	pop	r10
    1d30:	08 95       	ret

00001d32 <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    1d32:	80 e0       	ldi	r24, 0x00	; 0
    1d34:	90 e5       	ldi	r25, 0x50	; 80
    1d36:	61 e0       	ldi	r22, 0x01	; 1
    1d38:	43 ec       	ldi	r20, 0xC3	; 195
    1d3a:	5d e0       	ldi	r21, 0x0D	; 13
    1d3c:	0c 94 21 05 	jmp	0xa42	; 0xa42 <TCP_SetPortState>

00001d40 <ProcessRNDISControlMessage>:
void ProcessRNDISControlMessage(void)
{
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	switch (MessageHeader->MessageType)
    1d40:	e0 91 44 01 	lds	r30, 0x0144
    1d44:	f0 91 45 01 	lds	r31, 0x0145
    1d48:	80 81       	ld	r24, Z
    1d4a:	91 81       	ldd	r25, Z+1	; 0x01
    1d4c:	a2 81       	ldd	r26, Z+2	; 0x02
    1d4e:	b3 81       	ldd	r27, Z+3	; 0x03
    1d50:	84 30       	cpi	r24, 0x04	; 4
    1d52:	91 05       	cpc	r25, r1
    1d54:	a1 05       	cpc	r26, r1
    1d56:	b1 05       	cpc	r27, r1
    1d58:	09 f4       	brne	.+2      	; 0x1d5c <ProcessRNDISControlMessage+0x1c>
    1d5a:	a1 c0       	rjmp	.+322    	; 0x1e9e <ProcessRNDISControlMessage+0x15e>
    1d5c:	85 30       	cpi	r24, 0x05	; 5
    1d5e:	91 05       	cpc	r25, r1
    1d60:	a1 05       	cpc	r26, r1
    1d62:	b1 05       	cpc	r27, r1
    1d64:	58 f4       	brcc	.+22     	; 0x1d7c <ProcessRNDISControlMessage+0x3c>
    1d66:	82 30       	cpi	r24, 0x02	; 2
    1d68:	91 05       	cpc	r25, r1
    1d6a:	a1 05       	cpc	r26, r1
    1d6c:	b1 05       	cpc	r27, r1
    1d6e:	c1 f0       	breq	.+48     	; 0x1da0 <ProcessRNDISControlMessage+0x60>
    1d70:	03 97       	sbiw	r24, 0x03	; 3
    1d72:	a1 05       	cpc	r26, r1
    1d74:	b1 05       	cpc	r27, r1
    1d76:	09 f0       	breq	.+2      	; 0x1d7a <ProcessRNDISControlMessage+0x3a>
    1d78:	b5 c2       	rjmp	.+1386   	; 0x22e4 <__stack+0x1e5>
    1d7a:	88 c0       	rjmp	.+272    	; 0x1e8c <ProcessRNDISControlMessage+0x14c>
    1d7c:	86 30       	cpi	r24, 0x06	; 6
    1d7e:	91 05       	cpc	r25, r1
    1d80:	a1 05       	cpc	r26, r1
    1d82:	b1 05       	cpc	r27, r1
    1d84:	09 f4       	brne	.+2      	; 0x1d88 <ProcessRNDISControlMessage+0x48>
    1d86:	34 c2       	rjmp	.+1128   	; 0x21f0 <__stack+0xf1>
    1d88:	86 30       	cpi	r24, 0x06	; 6
    1d8a:	91 05       	cpc	r25, r1
    1d8c:	a1 05       	cpc	r26, r1
    1d8e:	b1 05       	cpc	r27, r1
    1d90:	08 f4       	brcc	.+2      	; 0x1d94 <ProcessRNDISControlMessage+0x54>
    1d92:	d5 c1       	rjmp	.+938    	; 0x213e <__stack+0x3f>
    1d94:	08 97       	sbiw	r24, 0x08	; 8
    1d96:	a1 05       	cpc	r26, r1
    1d98:	b1 05       	cpc	r27, r1
    1d9a:	09 f0       	breq	.+2      	; 0x1d9e <ProcessRNDISControlMessage+0x5e>
    1d9c:	a3 c2       	rjmp	.+1350   	; 0x22e4 <__stack+0x1e5>
    1d9e:	4c c2       	rjmp	.+1176   	; 0x2238 <__stack+0x139>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			/* Initialize the adapter - return information about the supported RNDIS version and buffer sizes */

			ResponseReady = true;
    1da0:	21 e0       	ldi	r18, 0x01	; 1
    1da2:	20 93 47 01 	sts	0x0147, r18

			RNDIS_Initialize_Message_t*  INITIALIZE_Message  = (RNDIS_Initialize_Message_t*)&RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response = (RNDIS_Initialize_Complete_t*)&RNDISMessageBuffer;

			INITIALIZE_Response->MessageType           = REMOTE_NDIS_INITIALIZE_CMPLT;
    1da6:	82 e0       	ldi	r24, 0x02	; 2
    1da8:	90 e0       	ldi	r25, 0x00	; 0
    1daa:	a0 e0       	ldi	r26, 0x00	; 0
    1dac:	b0 e8       	ldi	r27, 0x80	; 128
    1dae:	80 93 50 13 	sts	0x1350, r24
    1db2:	90 93 51 13 	sts	0x1351, r25
    1db6:	a0 93 52 13 	sts	0x1352, r26
    1dba:	b0 93 53 13 	sts	0x1353, r27
			INITIALIZE_Response->MessageLength         = sizeof(RNDIS_Initialize_Complete_t);
    1dbe:	84 e3       	ldi	r24, 0x34	; 52
    1dc0:	90 e0       	ldi	r25, 0x00	; 0
    1dc2:	a0 e0       	ldi	r26, 0x00	; 0
    1dc4:	b0 e0       	ldi	r27, 0x00	; 0
    1dc6:	80 93 54 13 	sts	0x1354, r24
    1dca:	90 93 55 13 	sts	0x1355, r25
    1dce:	a0 93 56 13 	sts	0x1356, r26
    1dd2:	b0 93 57 13 	sts	0x1357, r27
			INITIALIZE_Response->RequestId             = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                = REMOTE_NDIS_STATUS_SUCCESS;
    1dd6:	10 92 5c 13 	sts	0x135C, r1
    1dda:	10 92 5d 13 	sts	0x135D, r1
    1dde:	10 92 5e 13 	sts	0x135E, r1
    1de2:	10 92 5f 13 	sts	0x135F, r1

			INITIALIZE_Response->MajorVersion          = REMOTE_NDIS_VERSION_MAJOR;
    1de6:	81 e0       	ldi	r24, 0x01	; 1
    1de8:	90 e0       	ldi	r25, 0x00	; 0
    1dea:	a0 e0       	ldi	r26, 0x00	; 0
    1dec:	b0 e0       	ldi	r27, 0x00	; 0
    1dee:	80 93 60 13 	sts	0x1360, r24
    1df2:	90 93 61 13 	sts	0x1361, r25
    1df6:	a0 93 62 13 	sts	0x1362, r26
    1dfa:	b0 93 63 13 	sts	0x1363, r27
			INITIALIZE_Response->MinorVersion          = REMOTE_NDIS_VERSION_MINOR;
    1dfe:	10 92 64 13 	sts	0x1364, r1
    1e02:	10 92 65 13 	sts	0x1365, r1
    1e06:	10 92 66 13 	sts	0x1366, r1
    1e0a:	10 92 67 13 	sts	0x1367, r1
			INITIALIZE_Response->DeviceFlags           = REMOTE_NDIS_DF_CONNECTIONLESS;
    1e0e:	80 93 68 13 	sts	0x1368, r24
    1e12:	90 93 69 13 	sts	0x1369, r25
    1e16:	a0 93 6a 13 	sts	0x136A, r26
    1e1a:	b0 93 6b 13 	sts	0x136B, r27
			INITIALIZE_Response->Medium                = REMOTE_NDIS_MEDIUM_802_3;
    1e1e:	10 92 6c 13 	sts	0x136C, r1
    1e22:	10 92 6d 13 	sts	0x136D, r1
    1e26:	10 92 6e 13 	sts	0x136E, r1
    1e2a:	10 92 6f 13 	sts	0x136F, r1
			INITIALIZE_Response->MaxPacketsPerTransfer = 1;
    1e2e:	80 93 70 13 	sts	0x1370, r24
    1e32:	90 93 71 13 	sts	0x1371, r25
    1e36:	a0 93 72 13 	sts	0x1372, r26
    1e3a:	b0 93 73 13 	sts	0x1373, r27
			INITIALIZE_Response->MaxTransferSize       = (sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    1e3e:	88 e0       	ldi	r24, 0x08	; 8
    1e40:	96 e0       	ldi	r25, 0x06	; 6
    1e42:	a0 e0       	ldi	r26, 0x00	; 0
    1e44:	b0 e0       	ldi	r27, 0x00	; 0
    1e46:	80 93 74 13 	sts	0x1374, r24
    1e4a:	90 93 75 13 	sts	0x1375, r25
    1e4e:	a0 93 76 13 	sts	0x1376, r26
    1e52:	b0 93 77 13 	sts	0x1377, r27
			INITIALIZE_Response->PacketAlignmentFactor = 0;
    1e56:	10 92 78 13 	sts	0x1378, r1
    1e5a:	10 92 79 13 	sts	0x1379, r1
    1e5e:	10 92 7a 13 	sts	0x137A, r1
    1e62:	10 92 7b 13 	sts	0x137B, r1
			INITIALIZE_Response->AFListOffset          = 0;
    1e66:	10 92 7c 13 	sts	0x137C, r1
    1e6a:	10 92 7d 13 	sts	0x137D, r1
    1e6e:	10 92 7e 13 	sts	0x137E, r1
    1e72:	10 92 7f 13 	sts	0x137F, r1
			INITIALIZE_Response->AFListSize            = 0;
    1e76:	10 92 80 13 	sts	0x1380, r1
    1e7a:	10 92 81 13 	sts	0x1381, r1
    1e7e:	10 92 82 13 	sts	0x1382, r1
    1e82:	10 92 83 13 	sts	0x1383, r1

			CurrRNDISState = RNDIS_Initialized;
    1e86:	20 93 48 01 	sts	0x0148, r18
    1e8a:	08 95       	ret

			break;
		case REMOTE_NDIS_HALT_MSG:
			/* Halt the adapter, reset the adapter state - note that no response should be returned when completed */

			ResponseReady = false;
    1e8c:	10 92 47 01 	sts	0x0147, r1
			MessageHeader->MessageLength = 0;
    1e90:	14 82       	std	Z+4, r1	; 0x04
    1e92:	15 82       	std	Z+5, r1	; 0x05
    1e94:	16 82       	std	Z+6, r1	; 0x06
    1e96:	17 82       	std	Z+7, r1	; 0x07

			CurrRNDISState = RNDIS_Uninitialized;
    1e98:	10 92 48 01 	sts	0x0148, r1
    1e9c:	08 95       	ret

			break;
		case REMOTE_NDIS_QUERY_MSG:
			/* Request for information about a parameter about the adapter, specified as an OID token */

			ResponseReady = true;
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
    1ea0:	80 93 47 01 	sts	0x0147, r24

			RNDIS_Query_Message_t*  QUERY_Message  = (RNDIS_Query_Message_t*)&RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response = (RNDIS_Query_Complete_t*)&RNDISMessageBuffer;
    1ea4:	60 e5       	ldi	r22, 0x50	; 80
    1ea6:	73 e1       	ldi	r23, 0x13	; 19
			uint32_t                Query_Oid      = QUERY_Message->Oid;
    1ea8:	20 91 5c 13 	lds	r18, 0x135C
    1eac:	30 91 5d 13 	lds	r19, 0x135D
    1eb0:	40 91 5e 13 	lds	r20, 0x135E
    1eb4:	50 91 5f 13 	lds	r21, 0x135F
			void*     QueryData                 = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                          QUERY_Message->InformationBufferOffset];
			void*     ResponseData              = &RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
			uint16_t  ResponseSize;

			QUERY_Response->MessageType         = REMOTE_NDIS_QUERY_CMPLT;
    1eb8:	84 e0       	ldi	r24, 0x04	; 4
    1eba:	90 e0       	ldi	r25, 0x00	; 0
    1ebc:	a0 e0       	ldi	r26, 0x00	; 0
    1ebe:	b0 e8       	ldi	r27, 0x80	; 128
    1ec0:	80 93 50 13 	sts	0x1350, r24
    1ec4:	90 93 51 13 	sts	0x1351, r25
    1ec8:	a0 93 52 13 	sts	0x1352, r26
    1ecc:	b0 93 53 13 	sts	0x1353, r27
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);
    1ed0:	88 e1       	ldi	r24, 0x18	; 24
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	a0 e0       	ldi	r26, 0x00	; 0
    1ed6:	b0 e0       	ldi	r27, 0x00	; 0
    1ed8:	80 93 54 13 	sts	0x1354, r24
    1edc:	90 93 55 13 	sts	0x1355, r25
    1ee0:	a0 93 56 13 	sts	0x1356, r26
    1ee4:	b0 93 57 13 	sts	0x1357, r27
static bool ProcessNDISQuery(const uint32_t OId, void* QueryData, uint16_t QuerySize,
                             void* ResponseData, uint16_t* ResponseSize)
{
	/* Handler for REMOTE_NDIS_QUERY_MSG messages */

	switch (OId)
    1ee8:	2e 30       	cpi	r18, 0x0E	; 14
    1eea:	81 e0       	ldi	r24, 0x01	; 1
    1eec:	38 07       	cpc	r19, r24
    1eee:	81 e0       	ldi	r24, 0x01	; 1
    1ef0:	48 07       	cpc	r20, r24
    1ef2:	80 e0       	ldi	r24, 0x00	; 0
    1ef4:	58 07       	cpc	r21, r24
    1ef6:	09 f4       	brne	.+2      	; 0x1efa <ProcessRNDISControlMessage+0x1ba>
    1ef8:	e4 c0       	rjmp	.+456    	; 0x20c2 <ProcessRNDISControlMessage+0x382>
    1efa:	2f 30       	cpi	r18, 0x0F	; 15
    1efc:	81 e0       	ldi	r24, 0x01	; 1
    1efe:	38 07       	cpc	r19, r24
    1f00:	81 e0       	ldi	r24, 0x01	; 1
    1f02:	48 07       	cpc	r20, r24
    1f04:	80 e0       	ldi	r24, 0x00	; 0
    1f06:	58 07       	cpc	r21, r24
    1f08:	08 f0       	brcs	.+2      	; 0x1f0c <ProcessRNDISControlMessage+0x1cc>
    1f0a:	58 c0       	rjmp	.+176    	; 0x1fbc <ProcessRNDISControlMessage+0x27c>
    1f0c:	26 30       	cpi	r18, 0x06	; 6
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
    1f10:	38 07       	cpc	r19, r24
    1f12:	81 e0       	ldi	r24, 0x01	; 1
    1f14:	48 07       	cpc	r20, r24
    1f16:	80 e0       	ldi	r24, 0x00	; 0
    1f18:	58 07       	cpc	r21, r24
    1f1a:	09 f4       	brne	.+2      	; 0x1f1e <ProcessRNDISControlMessage+0x1de>
    1f1c:	af c0       	rjmp	.+350    	; 0x207c <ProcessRNDISControlMessage+0x33c>
    1f1e:	27 30       	cpi	r18, 0x07	; 7
    1f20:	81 e0       	ldi	r24, 0x01	; 1
    1f22:	38 07       	cpc	r19, r24
    1f24:	81 e0       	ldi	r24, 0x01	; 1
    1f26:	48 07       	cpc	r20, r24
    1f28:	80 e0       	ldi	r24, 0x00	; 0
    1f2a:	58 07       	cpc	r21, r24
    1f2c:	f8 f4       	brcc	.+62     	; 0x1f6c <ProcessRNDISControlMessage+0x22c>
    1f2e:	22 30       	cpi	r18, 0x02	; 2
    1f30:	81 e0       	ldi	r24, 0x01	; 1
    1f32:	38 07       	cpc	r19, r24
    1f34:	81 e0       	ldi	r24, 0x01	; 1
    1f36:	48 07       	cpc	r20, r24
    1f38:	80 e0       	ldi	r24, 0x00	; 0
    1f3a:	58 07       	cpc	r21, r24
    1f3c:	09 f4       	brne	.+2      	; 0x1f40 <ProcessRNDISControlMessage+0x200>
    1f3e:	ca c0       	rjmp	.+404    	; 0x20d4 <ProcessRNDISControlMessage+0x394>
    1f40:	23 30       	cpi	r18, 0x03	; 3
    1f42:	81 e0       	ldi	r24, 0x01	; 1
    1f44:	38 07       	cpc	r19, r24
    1f46:	81 e0       	ldi	r24, 0x01	; 1
    1f48:	48 07       	cpc	r20, r24
    1f4a:	80 e0       	ldi	r24, 0x00	; 0
    1f4c:	58 07       	cpc	r21, r24
    1f4e:	38 f4       	brcc	.+14     	; 0x1f5e <ProcessRNDISControlMessage+0x21e>
    1f50:	21 50       	subi	r18, 0x01	; 1
    1f52:	31 40       	sbci	r19, 0x01	; 1
    1f54:	41 40       	sbci	r20, 0x01	; 1
    1f56:	50 40       	sbci	r21, 0x00	; 0
    1f58:	09 f0       	breq	.+2      	; 0x1f5c <ProcessRNDISControlMessage+0x21c>
    1f5a:	d4 c0       	rjmp	.+424    	; 0x2104 <__stack+0x5>
    1f5c:	80 c0       	rjmp	.+256    	; 0x205e <ProcessRNDISControlMessage+0x31e>
    1f5e:	25 50       	subi	r18, 0x05	; 5
    1f60:	31 40       	sbci	r19, 0x01	; 1
    1f62:	41 40       	sbci	r20, 0x01	; 1
    1f64:	50 40       	sbci	r21, 0x00	; 0
    1f66:	08 f0       	brcs	.+2      	; 0x1f6a <ProcessRNDISControlMessage+0x22a>
    1f68:	cd c0       	rjmp	.+410    	; 0x2104 <__stack+0x5>
    1f6a:	b4 c0       	rjmp	.+360    	; 0x20d4 <ProcessRNDISControlMessage+0x394>
    1f6c:	2c 30       	cpi	r18, 0x0C	; 12
    1f6e:	81 e0       	ldi	r24, 0x01	; 1
    1f70:	38 07       	cpc	r19, r24
    1f72:	81 e0       	ldi	r24, 0x01	; 1
    1f74:	48 07       	cpc	r20, r24
    1f76:	80 e0       	ldi	r24, 0x00	; 0
    1f78:	58 07       	cpc	r21, r24
    1f7a:	80 f4       	brcc	.+32     	; 0x1f9c <ProcessRNDISControlMessage+0x25c>
    1f7c:	2a 30       	cpi	r18, 0x0A	; 10
    1f7e:	61 e0       	ldi	r22, 0x01	; 1
    1f80:	36 07       	cpc	r19, r22
    1f82:	61 e0       	ldi	r22, 0x01	; 1
    1f84:	46 07       	cpc	r20, r22
    1f86:	60 e0       	ldi	r22, 0x00	; 0
    1f88:	56 07       	cpc	r21, r22
    1f8a:	08 f0       	brcs	.+2      	; 0x1f8e <ProcessRNDISControlMessage+0x24e>
    1f8c:	77 c0       	rjmp	.+238    	; 0x207c <ProcessRNDISControlMessage+0x33c>
    1f8e:	27 50       	subi	r18, 0x07	; 7
    1f90:	31 40       	sbci	r19, 0x01	; 1
    1f92:	41 40       	sbci	r20, 0x01	; 1
    1f94:	50 40       	sbci	r21, 0x00	; 0
    1f96:	09 f0       	breq	.+2      	; 0x1f9a <ProcessRNDISControlMessage+0x25a>
    1f98:	b5 c0       	rjmp	.+362    	; 0x2104 <__stack+0x5>
    1f9a:	7f c0       	rjmp	.+254    	; 0x209a <ProcessRNDISControlMessage+0x35a>
    1f9c:	2c 30       	cpi	r18, 0x0C	; 12
    1f9e:	81 e0       	ldi	r24, 0x01	; 1
    1fa0:	38 07       	cpc	r19, r24
    1fa2:	81 e0       	ldi	r24, 0x01	; 1
    1fa4:	48 07       	cpc	r20, r24
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	58 07       	cpc	r21, r24
    1faa:	09 f4       	brne	.+2      	; 0x1fae <ProcessRNDISControlMessage+0x26e>
    1fac:	62 c0       	rjmp	.+196    	; 0x2072 <ProcessRNDISControlMessage+0x332>
    1fae:	2d 50       	subi	r18, 0x0D	; 13
    1fb0:	31 40       	sbci	r19, 0x01	; 1
    1fb2:	41 40       	sbci	r20, 0x01	; 1
    1fb4:	50 40       	sbci	r21, 0x00	; 0
    1fb6:	09 f0       	breq	.+2      	; 0x1fba <ProcessRNDISControlMessage+0x27a>
    1fb8:	a5 c0       	rjmp	.+330    	; 0x2104 <__stack+0x5>
    1fba:	65 c0       	rjmp	.+202    	; 0x2086 <ProcessRNDISControlMessage+0x346>
    1fbc:	26 30       	cpi	r18, 0x06	; 6
    1fbe:	81 e0       	ldi	r24, 0x01	; 1
    1fc0:	38 07       	cpc	r19, r24
    1fc2:	82 e0       	ldi	r24, 0x02	; 2
    1fc4:	48 07       	cpc	r20, r24
    1fc6:	80 e0       	ldi	r24, 0x00	; 0
    1fc8:	58 07       	cpc	r21, r24
    1fca:	10 f5       	brcc	.+68     	; 0x2010 <ProcessRNDISControlMessage+0x2d0>
    1fcc:	21 30       	cpi	r18, 0x01	; 1
    1fce:	61 e0       	ldi	r22, 0x01	; 1
    1fd0:	36 07       	cpc	r19, r22
    1fd2:	62 e0       	ldi	r22, 0x02	; 2
    1fd4:	46 07       	cpc	r20, r22
    1fd6:	60 e0       	ldi	r22, 0x00	; 0
    1fd8:	56 07       	cpc	r21, r22
    1fda:	08 f0       	brcs	.+2      	; 0x1fde <ProcessRNDISControlMessage+0x29e>
    1fdc:	7b c0       	rjmp	.+246    	; 0x20d4 <ProcessRNDISControlMessage+0x394>
    1fde:	24 31       	cpi	r18, 0x14	; 20
    1fe0:	81 e0       	ldi	r24, 0x01	; 1
    1fe2:	38 07       	cpc	r19, r24
    1fe4:	81 e0       	ldi	r24, 0x01	; 1
    1fe6:	48 07       	cpc	r20, r24
    1fe8:	80 e0       	ldi	r24, 0x00	; 0
    1fea:	58 07       	cpc	r21, r24
    1fec:	09 f4       	brne	.+2      	; 0x1ff0 <ProcessRNDISControlMessage+0x2b0>
    1fee:	72 c0       	rjmp	.+228    	; 0x20d4 <ProcessRNDISControlMessage+0x394>
    1ff0:	22 30       	cpi	r18, 0x02	; 2
    1ff2:	62 e0       	ldi	r22, 0x02	; 2
    1ff4:	36 07       	cpc	r19, r22
    1ff6:	61 e0       	ldi	r22, 0x01	; 1
    1ff8:	46 07       	cpc	r20, r22
    1ffa:	60 e0       	ldi	r22, 0x00	; 0
    1ffc:	56 07       	cpc	r21, r22
    1ffe:	09 f4       	brne	.+2      	; 0x2002 <ProcessRNDISControlMessage+0x2c2>
    2000:	69 c0       	rjmp	.+210    	; 0x20d4 <ProcessRNDISControlMessage+0x394>
    2002:	21 51       	subi	r18, 0x11	; 17
    2004:	31 40       	sbci	r19, 0x01	; 1
    2006:	41 40       	sbci	r20, 0x01	; 1
    2008:	50 40       	sbci	r21, 0x00	; 0
    200a:	09 f0       	breq	.+2      	; 0x200e <ProcessRNDISControlMessage+0x2ce>
    200c:	7b c0       	rjmp	.+246    	; 0x2104 <__stack+0x5>
    200e:	6b c0       	rjmp	.+214    	; 0x20e6 <ProcessRNDISControlMessage+0x3a6>
    2010:	24 30       	cpi	r18, 0x04	; 4
    2012:	81 e0       	ldi	r24, 0x01	; 1
    2014:	38 07       	cpc	r19, r24
    2016:	81 e0       	ldi	r24, 0x01	; 1
    2018:	48 07       	cpc	r20, r24
    201a:	81 e0       	ldi	r24, 0x01	; 1
    201c:	58 07       	cpc	r21, r24
    201e:	09 f4       	brne	.+2      	; 0x2022 <ProcessRNDISControlMessage+0x2e2>
    2020:	4b c0       	rjmp	.+150    	; 0x20b8 <ProcessRNDISControlMessage+0x378>
    2022:	25 30       	cpi	r18, 0x05	; 5
    2024:	81 e0       	ldi	r24, 0x01	; 1
    2026:	38 07       	cpc	r19, r24
    2028:	81 e0       	ldi	r24, 0x01	; 1
    202a:	48 07       	cpc	r20, r24
    202c:	81 e0       	ldi	r24, 0x01	; 1
    202e:	58 07       	cpc	r21, r24
    2030:	58 f4       	brcc	.+22     	; 0x2048 <ProcessRNDISControlMessage+0x308>
    2032:	21 50       	subi	r18, 0x01	; 1
    2034:	31 40       	sbci	r19, 0x01	; 1
    2036:	41 40       	sbci	r20, 0x01	; 1
    2038:	51 40       	sbci	r21, 0x01	; 1
    203a:	22 30       	cpi	r18, 0x02	; 2
    203c:	31 05       	cpc	r19, r1
    203e:	41 05       	cpc	r20, r1
    2040:	51 05       	cpc	r21, r1
    2042:	08 f0       	brcs	.+2      	; 0x2046 <ProcessRNDISControlMessage+0x306>
    2044:	5f c0       	rjmp	.+190    	; 0x2104 <__stack+0x5>
    2046:	2e c0       	rjmp	.+92     	; 0x20a4 <ProcessRNDISControlMessage+0x364>
    2048:	21 50       	subi	r18, 0x01	; 1
    204a:	31 40       	sbci	r19, 0x01	; 1
    204c:	42 40       	sbci	r20, 0x02	; 2
    204e:	51 40       	sbci	r21, 0x01	; 1
    2050:	23 30       	cpi	r18, 0x03	; 3
    2052:	31 05       	cpc	r19, r1
    2054:	41 05       	cpc	r20, r1
    2056:	51 05       	cpc	r21, r1
    2058:	08 f0       	brcs	.+2      	; 0x205c <ProcessRNDISControlMessage+0x31c>
    205a:	54 c0       	rjmp	.+168    	; 0x2104 <__stack+0x5>
    205c:	3b c0       	rjmp	.+118    	; 0x20d4 <ProcessRNDISControlMessage+0x394>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			/* Copy the list of supported NDIS OID tokens to the response buffer */
			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    205e:	cb 01       	movw	r24, r22
    2060:	48 96       	adiw	r24, 0x18	; 24
    2062:	66 eb       	ldi	r22, 0xB6	; 182
    2064:	73 e0       	ldi	r23, 0x03	; 3
    2066:	4c e6       	ldi	r20, 0x6C	; 108
    2068:	50 e0       	ldi	r21, 0x00	; 0
    206a:	32 d6       	rcall	.+3172   	; 0x2cd0 <memcpy_P>
    206c:	8c e6       	ldi	r24, 0x6C	; 108
    206e:	90 e0       	ldi	r25, 0x00	; 0
    2070:	07 c1       	rjmp	.+526    	; 0x2280 <__stack+0x181>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = 0x00FFFFFF;
    2072:	8f ef       	ldi	r24, 0xFF	; 255
    2074:	9f ef       	ldi	r25, 0xFF	; 255
    2076:	af ef       	ldi	r26, 0xFF	; 255
    2078:	b0 e0       	ldi	r27, 0x00	; 0
    207a:	39 c0       	rjmp	.+114    	; 0x20ee <ProcessRNDISControlMessage+0x3ae>
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate that the maximum frame size is the size of the ethernet frame buffer */
			*((uint32_t*)ResponseData) = ETHERNET_FRAME_SIZE_MAX;
    207c:	8c ed       	ldi	r24, 0xDC	; 220
    207e:	95 e0       	ldi	r25, 0x05	; 5
    2080:	a0 e0       	ldi	r26, 0x00	; 0
    2082:	b0 e0       	ldi	r27, 0x00	; 0
    2084:	34 c0       	rjmp	.+104    	; 0x20ee <ProcessRNDISControlMessage+0x3ae>
			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = sizeof(AdapterVendorDescription);

			/* Copy vendor description string to the response buffer */
			memcpy_P(ResponseData, AdapterVendorDescription, sizeof(AdapterVendorDescription));
    2086:	cb 01       	movw	r24, r22
    2088:	48 96       	adiw	r24, 0x18	; 24
    208a:	62 e2       	ldi	r22, 0x22	; 34
    208c:	74 e0       	ldi	r23, 0x04	; 4
    208e:	43 e1       	ldi	r20, 0x13	; 19
    2090:	50 e0       	ldi	r21, 0x00	; 0
    2092:	1e d6       	rcall	.+3132   	; 0x2cd0 <memcpy_P>
    2094:	83 e1       	ldi	r24, 0x13	; 19
    2096:	90 e0       	ldi	r25, 0x00	; 0
    2098:	f3 c0       	rjmp	.+486    	; 0x2280 <__stack+0x181>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = 100000;
    209a:	80 ea       	ldi	r24, 0xA0	; 160
    209c:	96 e8       	ldi	r25, 0x86	; 134
    209e:	a1 e0       	ldi	r26, 0x01	; 1
    20a0:	b0 e0       	ldi	r27, 0x00	; 0
    20a2:	25 c0       	rjmp	.+74     	; 0x20ee <ProcessRNDISControlMessage+0x3ae>
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			/* Copy over the fixed adapter MAC to the response buffer */
			memcpy_P(ResponseData, &AdapterMACAddress, sizeof(MAC_Address_t));
    20a4:	cb 01       	movw	r24, r22
    20a6:	48 96       	adiw	r24, 0x18	; 24
    20a8:	65 e3       	ldi	r22, 0x35	; 53
    20aa:	74 e0       	ldi	r23, 0x04	; 4
    20ac:	46 e0       	ldi	r20, 0x06	; 6
    20ae:	50 e0       	ldi	r21, 0x00	; 0
    20b0:	0f d6       	rcall	.+3102   	; 0x2cd0 <memcpy_P>
    20b2:	86 e0       	ldi	r24, 0x06	; 6
    20b4:	90 e0       	ldi	r25, 0x00	; 0
    20b6:	e4 c0       	rjmp	.+456    	; 0x2280 <__stack+0x181>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = 1;
    20b8:	81 e0       	ldi	r24, 0x01	; 1
    20ba:	90 e0       	ldi	r25, 0x00	; 0
    20bc:	a0 e0       	ldi	r26, 0x00	; 0
    20be:	b0 e0       	ldi	r27, 0x00	; 0
    20c0:	16 c0       	rjmp	.+44     	; 0x20ee <ProcessRNDISControlMessage+0x3ae>
			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate the current packet filter mask */
			*((uint32_t*)ResponseData) = CurrPacketFilter;
    20c2:	80 91 49 01 	lds	r24, 0x0149
    20c6:	90 91 4a 01 	lds	r25, 0x014A
    20ca:	a0 91 4b 01 	lds	r26, 0x014B
    20ce:	b0 91 4c 01 	lds	r27, 0x014C
    20d2:	0d c0       	rjmp	.+26     	; 0x20ee <ProcessRNDISControlMessage+0x3ae>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = 0;
    20d4:	10 92 68 13 	sts	0x1368, r1
    20d8:	10 92 69 13 	sts	0x1369, r1
    20dc:	10 92 6a 13 	sts	0x136A, r1
    20e0:	10 92 6b 13 	sts	0x136B, r1
    20e4:	0c c0       	rjmp	.+24     	; 0x20fe <ProcessRNDISControlMessage+0x3be>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = (sizeof(RNDISMessageBuffer) + ETHERNET_FRAME_SIZE_MAX);
    20e6:	80 e6       	ldi	r24, 0x60	; 96
    20e8:	96 e0       	ldi	r25, 0x06	; 6
    20ea:	a0 e0       	ldi	r26, 0x00	; 0
    20ec:	b0 e0       	ldi	r27, 0x00	; 0
    20ee:	80 93 68 13 	sts	0x1368, r24
    20f2:	90 93 69 13 	sts	0x1369, r25
    20f6:	a0 93 6a 13 	sts	0x136A, r26
    20fa:	b0 93 6b 13 	sts	0x136B, r27
    20fe:	84 e0       	ldi	r24, 0x04	; 4
    2100:	90 e0       	ldi	r25, 0x00	; 0
    2102:	be c0       	rjmp	.+380    	; 0x2280 <__stack+0x181>
				QUERY_Response->InformationBufferLength = ResponseSize;
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    2104:	8b eb       	ldi	r24, 0xBB	; 187
    2106:	90 e0       	ldi	r25, 0x00	; 0
    2108:	a0 e0       	ldi	r26, 0x00	; 0
    210a:	b0 ec       	ldi	r27, 0xC0	; 192
    210c:	80 93 5c 13 	sts	0x135C, r24
    2110:	90 93 5d 13 	sts	0x135D, r25
    2114:	a0 93 5e 13 	sts	0x135E, r26
    2118:	b0 93 5f 13 	sts	0x135F, r27

				QUERY_Response->InformationBufferLength = 0;
    211c:	10 92 60 13 	sts	0x1360, r1
    2120:	10 92 61 13 	sts	0x1361, r1
    2124:	10 92 62 13 	sts	0x1362, r1
    2128:	10 92 63 13 	sts	0x1363, r1
				QUERY_Response->InformationBufferOffset = 0;
    212c:	10 92 64 13 	sts	0x1364, r1
    2130:	10 92 65 13 	sts	0x1365, r1
    2134:	10 92 66 13 	sts	0x1366, r1
    2138:	10 92 67 13 	sts	0x1367, r1
    213c:	08 95       	ret

			break;
		case REMOTE_NDIS_SET_MSG:
			/* Request to set a parameter of the adapter, specified as an OID token */

			ResponseReady = true;
    213e:	81 e0       	ldi	r24, 0x01	; 1
    2140:	80 93 47 01 	sts	0x0147, r24

			RNDIS_Set_Message_t*  SET_Message  = (RNDIS_Set_Message_t*)&RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response = (RNDIS_Set_Complete_t*)&RNDISMessageBuffer;
			uint32_t              SET_Oid      = SET_Message->Oid;
    2144:	20 91 5c 13 	lds	r18, 0x135C
    2148:	30 91 5d 13 	lds	r19, 0x135D
    214c:	40 91 5e 13 	lds	r20, 0x135E
    2150:	50 91 5f 13 	lds	r21, 0x135F

			SET_Response->MessageType       = REMOTE_NDIS_SET_CMPLT;
    2154:	85 e0       	ldi	r24, 0x05	; 5
    2156:	90 e0       	ldi	r25, 0x00	; 0
    2158:	a0 e0       	ldi	r26, 0x00	; 0
    215a:	b0 e8       	ldi	r27, 0x80	; 128
    215c:	80 93 50 13 	sts	0x1350, r24
    2160:	90 93 51 13 	sts	0x1351, r25
    2164:	a0 93 52 13 	sts	0x1352, r26
    2168:	b0 93 53 13 	sts	0x1353, r27
			SET_Response->MessageLength     = sizeof(RNDIS_Set_Complete_t);
    216c:	80 e1       	ldi	r24, 0x10	; 16
    216e:	90 e0       	ldi	r25, 0x00	; 0
    2170:	a0 e0       	ldi	r26, 0x00	; 0
    2172:	b0 e0       	ldi	r27, 0x00	; 0
    2174:	80 93 54 13 	sts	0x1354, r24
    2178:	90 93 55 13 	sts	0x1355, r25
    217c:	a0 93 56 13 	sts	0x1356, r26
    2180:	b0 93 57 13 	sts	0x1357, r27
			SET_Response->RequestId         = SET_Message->RequestId;

			void* SetData                   = &RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                      SET_Message->InformationBufferOffset];
    2184:	80 91 64 13 	lds	r24, 0x1364
    2188:	90 91 65 13 	lds	r25, 0x1365
    218c:	a0 91 66 13 	lds	r26, 0x1366
    2190:	b0 91 67 13 	lds	r27, 0x1367
 */
static bool ProcessNDISSet(uint32_t OId, void* SetData, uint16_t SetSize)
{
	/* Handler for REMOTE_NDIS_SET_MSG messages */

	switch (OId)
    2194:	2e 30       	cpi	r18, 0x0E	; 14
    2196:	61 e0       	ldi	r22, 0x01	; 1
    2198:	36 07       	cpc	r19, r22
    219a:	61 e0       	ldi	r22, 0x01	; 1
    219c:	46 07       	cpc	r20, r22
    219e:	60 e0       	ldi	r22, 0x00	; 0
    21a0:	56 07       	cpc	r21, r22
    21a2:	31 f0       	breq	.+12     	; 0x21b0 <__stack+0xb1>
    21a4:	23 50       	subi	r18, 0x03	; 3
    21a6:	31 40       	sbci	r19, 0x01	; 1
    21a8:	41 40       	sbci	r20, 0x01	; 1
    21aa:	51 40       	sbci	r21, 0x01	; 1
    21ac:	a1 f4       	brne	.+40     	; 0x21d6 <__stack+0xd7>
    21ae:	5f c0       	rjmp	.+190    	; 0x226e <__stack+0x16f>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			/* Save the packet filter mask in case the host queries it again later */
			CurrPacketFilter = *((uint32_t*)SetData);
    21b0:	fc 01       	movw	r30, r24
    21b2:	e8 5a       	subi	r30, 0xA8	; 168
    21b4:	fc 4e       	sbci	r31, 0xEC	; 236
    21b6:	80 81       	ld	r24, Z
    21b8:	91 81       	ldd	r25, Z+1	; 0x01
    21ba:	a2 81       	ldd	r26, Z+2	; 0x02
    21bc:	b3 81       	ldd	r27, Z+3	; 0x03
    21be:	80 93 49 01 	sts	0x0149, r24
    21c2:	90 93 4a 01 	sts	0x014A, r25
    21c6:	a0 93 4b 01 	sts	0x014B, r26
    21ca:	b0 93 4c 01 	sts	0x014C, r27

			/* Set the RNDIS state to initialized if the packet filter is non-zero */
			CurrRNDISState = ((CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Data_Initialized);
    21ce:	82 e0       	ldi	r24, 0x02	; 2
    21d0:	80 93 48 01 	sts	0x0148, r24
    21d4:	4c c0       	rjmp	.+152    	; 0x226e <__stack+0x16f>
			                                                      SET_Message->InformationBufferOffset];

			if (ProcessNDISSet(SET_Oid, SetData, SET_Message->InformationBufferLength))
			  SET_Response->Status        = REMOTE_NDIS_STATUS_SUCCESS;
			else
			  SET_Response->Status        = REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    21d6:	8b eb       	ldi	r24, 0xBB	; 187
    21d8:	90 e0       	ldi	r25, 0x00	; 0
    21da:	a0 e0       	ldi	r26, 0x00	; 0
    21dc:	b0 ec       	ldi	r27, 0xC0	; 192
    21de:	80 93 5c 13 	sts	0x135C, r24
    21e2:	90 93 5d 13 	sts	0x135D, r25
    21e6:	a0 93 5e 13 	sts	0x135E, r26
    21ea:	b0 93 5f 13 	sts	0x135F, r27
    21ee:	08 95       	ret

			break;
		case REMOTE_NDIS_RESET_MSG:
			/* Soft reset the adapter */

			ResponseReady = true;
    21f0:	81 e0       	ldi	r24, 0x01	; 1
    21f2:	80 93 47 01 	sts	0x0147, r24

			RNDIS_Reset_Complete_t* RESET_Response = (RNDIS_Reset_Complete_t*)&RNDISMessageBuffer;

			RESET_Response->MessageType         = REMOTE_NDIS_RESET_CMPLT;
    21f6:	86 e0       	ldi	r24, 0x06	; 6
    21f8:	90 e0       	ldi	r25, 0x00	; 0
    21fa:	a0 e0       	ldi	r26, 0x00	; 0
    21fc:	b0 e8       	ldi	r27, 0x80	; 128
    21fe:	80 93 50 13 	sts	0x1350, r24
    2202:	90 93 51 13 	sts	0x1351, r25
    2206:	a0 93 52 13 	sts	0x1352, r26
    220a:	b0 93 53 13 	sts	0x1353, r27
			RESET_Response->MessageLength       = sizeof(RNDIS_Reset_Complete_t);
    220e:	80 e1       	ldi	r24, 0x10	; 16
    2210:	90 e0       	ldi	r25, 0x00	; 0
    2212:	a0 e0       	ldi	r26, 0x00	; 0
    2214:	b0 e0       	ldi	r27, 0x00	; 0
    2216:	80 93 54 13 	sts	0x1354, r24
    221a:	90 93 55 13 	sts	0x1355, r25
    221e:	a0 93 56 13 	sts	0x1356, r26
    2222:	b0 93 57 13 	sts	0x1357, r27
			RESET_Response->Status              = REMOTE_NDIS_STATUS_SUCCESS;
    2226:	10 92 58 13 	sts	0x1358, r1
    222a:	10 92 59 13 	sts	0x1359, r1
    222e:	10 92 5a 13 	sts	0x135A, r1
    2232:	10 92 5b 13 	sts	0x135B, r1
    2236:	1b c0       	rjmp	.+54     	; 0x226e <__stack+0x16f>

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			/* Keep alive message sent to the adapter every 5 seconds when idle to ensure it is still responding */

			ResponseReady = true;
    2238:	81 e0       	ldi	r24, 0x01	; 1
    223a:	80 93 47 01 	sts	0x0147, r24

			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  = (RNDIS_KeepAlive_Message_t*)&RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response = (RNDIS_KeepAlive_Complete_t*)&RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType     = REMOTE_NDIS_KEEPALIVE_CMPLT;
    223e:	88 e0       	ldi	r24, 0x08	; 8
    2240:	90 e0       	ldi	r25, 0x00	; 0
    2242:	a0 e0       	ldi	r26, 0x00	; 0
    2244:	b0 e8       	ldi	r27, 0x80	; 128
    2246:	80 93 50 13 	sts	0x1350, r24
    224a:	90 93 51 13 	sts	0x1351, r25
    224e:	a0 93 52 13 	sts	0x1352, r26
    2252:	b0 93 53 13 	sts	0x1353, r27
			KEEPALIVE_Response->MessageLength   = sizeof(RNDIS_KeepAlive_Complete_t);
    2256:	80 e1       	ldi	r24, 0x10	; 16
    2258:	90 e0       	ldi	r25, 0x00	; 0
    225a:	a0 e0       	ldi	r26, 0x00	; 0
    225c:	b0 e0       	ldi	r27, 0x00	; 0
    225e:	80 93 54 13 	sts	0x1354, r24
    2262:	90 93 55 13 	sts	0x1355, r25
    2266:	a0 93 56 13 	sts	0x1356, r26
    226a:	b0 93 57 13 	sts	0x1357, r27
			KEEPALIVE_Response->RequestId       = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status          = REMOTE_NDIS_STATUS_SUCCESS;
    226e:	10 92 5c 13 	sts	0x135C, r1
    2272:	10 92 5d 13 	sts	0x135D, r1
    2276:	10 92 5e 13 	sts	0x135E, r1
    227a:	10 92 5f 13 	sts	0x135F, r1
    227e:	08 95       	ret
			QUERY_Response->MessageLength       = sizeof(RNDIS_Query_Complete_t);

			if (ProcessNDISQuery(Query_Oid, QueryData, QUERY_Message->InformationBufferLength,
			                     ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = REMOTE_NDIS_STATUS_SUCCESS;
    2280:	10 92 5c 13 	sts	0x135C, r1
    2284:	10 92 5d 13 	sts	0x135D, r1
    2288:	10 92 5e 13 	sts	0x135E, r1
    228c:	10 92 5f 13 	sts	0x135F, r1
				QUERY_Response->MessageLength          += ResponseSize;
    2290:	a0 e0       	ldi	r26, 0x00	; 0
    2292:	b0 e0       	ldi	r27, 0x00	; 0
    2294:	20 91 54 13 	lds	r18, 0x1354
    2298:	30 91 55 13 	lds	r19, 0x1355
    229c:	40 91 56 13 	lds	r20, 0x1356
    22a0:	50 91 57 13 	lds	r21, 0x1357
    22a4:	28 0f       	add	r18, r24
    22a6:	39 1f       	adc	r19, r25
    22a8:	4a 1f       	adc	r20, r26
    22aa:	5b 1f       	adc	r21, r27
    22ac:	20 93 54 13 	sts	0x1354, r18
    22b0:	30 93 55 13 	sts	0x1355, r19
    22b4:	40 93 56 13 	sts	0x1356, r20
    22b8:	50 93 57 13 	sts	0x1357, r21

				QUERY_Response->InformationBufferLength = ResponseSize;
    22bc:	80 93 60 13 	sts	0x1360, r24
    22c0:	90 93 61 13 	sts	0x1361, r25
    22c4:	a0 93 62 13 	sts	0x1362, r26
    22c8:	b0 93 63 13 	sts	0x1363, r27
				QUERY_Response->InformationBufferOffset = (sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    22cc:	80 e1       	ldi	r24, 0x10	; 16
    22ce:	90 e0       	ldi	r25, 0x00	; 0
    22d0:	a0 e0       	ldi	r26, 0x00	; 0
    22d2:	b0 e0       	ldi	r27, 0x00	; 0
    22d4:	80 93 64 13 	sts	0x1364, r24
    22d8:	90 93 65 13 	sts	0x1365, r25
    22dc:	a0 93 66 13 	sts	0x1366, r26
    22e0:	b0 93 67 13 	sts	0x1367, r27
    22e4:	08 95       	ret

000022e6 <Endpoint_ConfigureEndpoint_Prv>:
#endif

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
    22e6:	38 2f       	mov	r19, r24
    22e8:	28 2f       	mov	r18, r24
    22ea:	2c c0       	rjmp	.+88     	; 0x2344 <Endpoint_ConfigureEndpoint_Prv+0x5e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    22ec:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);
		
		if (EPNum == Number)
    22f0:	23 17       	cp	r18, r19
    22f2:	21 f4       	brne	.+8      	; 0x22fc <Endpoint_ConfigureEndpoint_Prv+0x16>
    22f4:	76 2f       	mov	r23, r22
    22f6:	94 2f       	mov	r25, r20
    22f8:	50 e0       	ldi	r21, 0x00	; 0
    22fa:	06 c0       	rjmp	.+12     	; 0x2308 <Endpoint_ConfigureEndpoint_Prv+0x22>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    22fc:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    2300:	90 91 ed 00 	lds	r25, 0x00ED
			UEIENXTemp  = UEIENX;
    2304:	50 91 f0 00 	lds	r21, 0x00F0
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    2308:	91 ff       	sbrs	r25, 1
    230a:	1b c0       	rjmp	.+54     	; 0x2342 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    230c:	80 91 eb 00 	lds	r24, 0x00EB
    2310:	8e 7f       	andi	r24, 0xFE	; 254
    2312:	80 93 eb 00 	sts	0x00EB, r24
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    2316:	80 91 ed 00 	lds	r24, 0x00ED
    231a:	8d 7f       	andi	r24, 0xFD	; 253
    231c:	80 93 ed 00 	sts	0x00ED, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    2320:	80 91 eb 00 	lds	r24, 0x00EB
    2324:	81 60       	ori	r24, 0x01	; 1
    2326:	80 93 eb 00 	sts	0x00EB, r24

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    232a:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    232e:	90 93 ed 00 	sts	0x00ED, r25
		UEIENX  = UEIENXTemp;
    2332:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    2336:	80 91 ee 00 	lds	r24, 0x00EE
			
		if (!(Endpoint_IsConfigured()))
    233a:	87 fd       	sbrc	r24, 7
    233c:	02 c0       	rjmp	.+4      	; 0x2342 <Endpoint_ConfigureEndpoint_Prv+0x5c>
    233e:	80 e0       	ldi	r24, 0x00	; 0
    2340:	08 95       	ret
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else	
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    2342:	2f 5f       	subi	r18, 0xFF	; 255
    2344:	27 30       	cpi	r18, 0x07	; 7
    2346:	90 f2       	brcs	.-92     	; 0x22ec <Endpoint_ConfigureEndpoint_Prv+0x6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2348:	30 93 e9 00 	sts	0x00E9, r19
    234c:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    234e:	08 95       	ret

00002350 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    2350:	80 91 d9 13 	lds	r24, 0x13D9
    2354:	88 23       	and	r24, r24
    2356:	9c f4       	brge	.+38     	; 0x237e <Endpoint_ClearStatusStage+0x2e>
    2358:	04 c0       	rjmp	.+8      	; 0x2362 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    235a:	80 91 d8 13 	lds	r24, 0x13D8
    235e:	88 23       	and	r24, r24
    2360:	b9 f0       	breq	.+46     	; 0x2390 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2362:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    2366:	82 ff       	sbrs	r24, 2
    2368:	f8 cf       	rjmp	.-16     	; 0x235a <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    236a:	80 91 e8 00 	lds	r24, 0x00E8
    236e:	8b 77       	andi	r24, 0x7B	; 123
    2370:	80 93 e8 00 	sts	0x00E8, r24
    2374:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    2376:	80 91 d8 13 	lds	r24, 0x13D8
    237a:	88 23       	and	r24, r24
    237c:	49 f0       	breq	.+18     	; 0x2390 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    237e:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    2382:	80 ff       	sbrs	r24, 0
    2384:	f8 cf       	rjmp	.-16     	; 0x2376 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2386:	80 91 e8 00 	lds	r24, 0x00E8
    238a:	8e 77       	andi	r24, 0x7E	; 126
    238c:	80 93 e8 00 	sts	0x00E8, r24
    2390:	08 95       	ret

00002392 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    2392:	40 91 e4 00 	lds	r20, 0x00E4
    2396:	50 91 e5 00 	lds	r21, 0x00E5
    239a:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    239c:	80 91 ec 00 	lds	r24, 0x00EC
    23a0:	80 ff       	sbrs	r24, 0
    23a2:	24 c0       	rjmp	.+72     	; 0x23ec <Endpoint_WaitUntilReady+0x5a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    23a4:	80 91 e8 00 	lds	r24, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    23a8:	80 fd       	sbrc	r24, 0
    23aa:	1e c0       	rjmp	.+60     	; 0x23e8 <Endpoint_WaitUntilReady+0x56>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    23ac:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    23b0:	88 23       	and	r24, r24
    23b2:	11 f4       	brne	.+4      	; 0x23b8 <Endpoint_WaitUntilReady+0x26>
    23b4:	82 e0       	ldi	r24, 0x02	; 2
    23b6:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    23b8:	85 30       	cpi	r24, 0x05	; 5
    23ba:	11 f4       	brne	.+4      	; 0x23c0 <Endpoint_WaitUntilReady+0x2e>
    23bc:	83 e0       	ldi	r24, 0x03	; 3
    23be:	08 95       	ret
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    23c0:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    23c4:	85 ff       	sbrs	r24, 5
    23c6:	02 c0       	rjmp	.+4      	; 0x23cc <Endpoint_WaitUntilReady+0x3a>
    23c8:	81 e0       	ldi	r24, 0x01	; 1
    23ca:	08 95       	ret
    23cc:	80 91 e4 00 	lds	r24, 0x00E4
    23d0:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    23d4:	84 17       	cp	r24, r20
    23d6:	95 07       	cpc	r25, r21
    23d8:	09 f3       	breq	.-62     	; 0x239c <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    23da:	22 23       	and	r18, r18
    23dc:	11 f4       	brne	.+4      	; 0x23e2 <Endpoint_WaitUntilReady+0x50>
    23de:	84 e0       	ldi	r24, 0x04	; 4
    23e0:	08 95       	ret
    23e2:	21 50       	subi	r18, 0x01	; 1
    23e4:	ac 01       	movw	r20, r24
    23e6:	da cf       	rjmp	.-76     	; 0x239c <Endpoint_WaitUntilReady+0xa>
    23e8:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    23ea:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    23ec:	80 91 e8 00 	lds	r24, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    23f0:	82 ff       	sbrs	r24, 2
    23f2:	dc cf       	rjmp	.-72     	; 0x23ac <Endpoint_WaitUntilReady+0x1a>
    23f4:	f9 cf       	rjmp	.-14     	; 0x23e8 <Endpoint_WaitUntilReady+0x56>

000023f6 <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    23f6:	ef 92       	push	r14
    23f8:	ff 92       	push	r15
    23fa:	0f 93       	push	r16
    23fc:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    23fe:	4d d0       	rcall	.+154    	; 0x249a <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    2400:	54 d0       	rcall	.+168    	; 0x24aa <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    2402:	08 ed       	ldi	r16, 0xD8	; 216
    2404:	10 e0       	ldi	r17, 0x00	; 0
    2406:	f8 01       	movw	r30, r16
    2408:	80 81       	ld	r24, Z
    240a:	8f 77       	andi	r24, 0x7F	; 127
    240c:	80 83       	st	Z, r24
				USBCON |=  (1 << USBE);
    240e:	80 81       	ld	r24, Z
    2410:	80 68       	ori	r24, 0x80	; 128
    2412:	80 83       	st	Z, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    2414:	80 81       	ld	r24, Z
    2416:	8f 7d       	andi	r24, 0xDF	; 223
    2418:	80 83       	st	Z, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    241a:	e7 ed       	ldi	r30, 0xD7	; 215
    241c:	f0 e0       	ldi	r31, 0x00	; 0
    241e:	80 81       	ld	r24, Z
    2420:	80 68       	ori	r24, 0x80	; 128
    2422:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2424:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    2426:	10 92 d8 13 	sts	0x13D8, r1
	USB_Device_ConfigurationNumber  = 0;
    242a:	10 92 d4 13 	sts	0x13D4, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    242e:	10 92 d6 13 	sts	0x13D6, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    2432:	10 92 d5 13 	sts	0x13D5, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    2436:	80 ee       	ldi	r24, 0xE0	; 224
    2438:	e8 2e       	mov	r14, r24
    243a:	f1 2c       	mov	r15, r1
    243c:	f7 01       	movw	r30, r14
    243e:	80 81       	ld	r24, Z
    2440:	8b 7f       	andi	r24, 0xFB	; 251
    2442:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    2444:	f8 01       	movw	r30, r16
    2446:	80 81       	ld	r24, Z
    2448:	81 60       	ori	r24, 0x01	; 1
    244a:	80 83       	st	Z, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    244c:	80 e0       	ldi	r24, 0x00	; 0
    244e:	60 e0       	ldi	r22, 0x00	; 0
    2450:	42 e0       	ldi	r20, 0x02	; 2
    2452:	49 df       	rcall	.-366    	; 0x22e6 <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    2454:	e1 ee       	ldi	r30, 0xE1	; 225
    2456:	f0 e0       	ldi	r31, 0x00	; 0
    2458:	80 81       	ld	r24, Z
    245a:	8e 7f       	andi	r24, 0xFE	; 254
    245c:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    245e:	e2 ee       	ldi	r30, 0xE2	; 226
    2460:	f0 e0       	ldi	r31, 0x00	; 0
    2462:	80 81       	ld	r24, Z
    2464:	81 60       	ori	r24, 0x01	; 1
    2466:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    2468:	80 81       	ld	r24, Z
    246a:	88 60       	ori	r24, 0x08	; 8
    246c:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    246e:	f7 01       	movw	r30, r14
    2470:	80 81       	ld	r24, Z
    2472:	8e 7f       	andi	r24, 0xFE	; 254
    2474:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    2476:	f8 01       	movw	r30, r16
    2478:	80 81       	ld	r24, Z
    247a:	80 61       	ori	r24, 0x10	; 16
    247c:	80 83       	st	Z, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    247e:	1f 91       	pop	r17
    2480:	0f 91       	pop	r16
    2482:	ff 90       	pop	r15
    2484:	ef 90       	pop	r14
    2486:	08 95       	ret

00002488 <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    2488:	e7 ed       	ldi	r30, 0xD7	; 215
    248a:	f0 e0       	ldi	r31, 0x00	; 0
    248c:	80 81       	ld	r24, Z
    248e:	81 60       	ori	r24, 0x01	; 1
    2490:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    2492:	81 e0       	ldi	r24, 0x01	; 1
    2494:	80 93 d7 13 	sts	0x13D7, r24

	USB_ResetInterface();
}
    2498:	ae cf       	rjmp	.-164    	; 0x23f6 <USB_ResetInterface>

0000249a <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    249a:	e8 ed       	ldi	r30, 0xD8	; 216
    249c:	f0 e0       	ldi	r31, 0x00	; 0
    249e:	80 81       	ld	r24, Z
    24a0:	8c 7f       	andi	r24, 0xFC	; 252
    24a2:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    24a4:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    24a8:	08 95       	ret

000024aa <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    24aa:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    24ae:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    24b2:	08 95       	ret

000024b4 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    24b4:	1f 92       	push	r1
    24b6:	0f 92       	push	r0
    24b8:	0f b6       	in	r0, 0x3f	; 63
    24ba:	0f 92       	push	r0
    24bc:	0b b6       	in	r0, 0x3b	; 59
    24be:	0f 92       	push	r0
    24c0:	11 24       	eor	r1, r1
    24c2:	2f 93       	push	r18
    24c4:	3f 93       	push	r19
    24c6:	4f 93       	push	r20
    24c8:	5f 93       	push	r21
    24ca:	6f 93       	push	r22
    24cc:	7f 93       	push	r23
    24ce:	8f 93       	push	r24
    24d0:	9f 93       	push	r25
    24d2:	af 93       	push	r26
    24d4:	bf 93       	push	r27
    24d6:	ef 93       	push	r30
    24d8:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    24da:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    24de:	82 ff       	sbrs	r24, 2
    24e0:	0a c0       	rjmp	.+20     	; 0x24f6 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    24e2:	80 91 e2 00 	lds	r24, 0x00E2
    24e6:	82 ff       	sbrs	r24, 2
    24e8:	06 c0       	rjmp	.+12     	; 0x24f6 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    24ea:	80 91 e1 00 	lds	r24, 0x00E1
    24ee:	8b 7f       	andi	r24, 0xFB	; 251
    24f0:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    24f4:	bb d3       	rcall	.+1910   	; 0x2c6c <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    24f6:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    24fa:	80 ff       	sbrs	r24, 0
    24fc:	1f c0       	rjmp	.+62     	; 0x253c <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    24fe:	80 91 d8 00 	lds	r24, 0x00D8
    2502:	80 ff       	sbrs	r24, 0
    2504:	1b c0       	rjmp	.+54     	; 0x253c <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    2506:	80 91 da 00 	lds	r24, 0x00DA
    250a:	8e 7f       	andi	r24, 0xFE	; 254
    250c:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    2510:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    2514:	80 ff       	sbrs	r24, 0
    2516:	0d c0       	rjmp	.+26     	; 0x2532 <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    2518:	8c e0       	ldi	r24, 0x0C	; 12
    251a:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    251c:	8e e0       	ldi	r24, 0x0E	; 14
    251e:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    2520:	09 b4       	in	r0, 0x29	; 41
    2522:	00 fe       	sbrs	r0, 0
    2524:	fd cf       	rjmp	.-6      	; 0x2520 <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    2526:	81 e0       	ldi	r24, 0x01	; 1
    2528:	80 93 d8 13 	sts	0x13D8, r24
			EVENT_USB_Device_Connect();
    252c:	0e 94 3d 02 	call	0x47a	; 0x47a <EVENT_USB_Device_Connect>
    2530:	05 c0       	rjmp	.+10     	; 0x253c <__vector_10+0x88>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    2532:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    2534:	10 92 d8 13 	sts	0x13D8, r1
			EVENT_USB_Device_Disconnect();
    2538:	0e 94 42 02 	call	0x484	; 0x484 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    253c:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    2540:	80 ff       	sbrs	r24, 0
    2542:	18 c0       	rjmp	.+48     	; 0x2574 <__vector_10+0xc0>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    2544:	80 91 e2 00 	lds	r24, 0x00E2
    2548:	80 ff       	sbrs	r24, 0
    254a:	14 c0       	rjmp	.+40     	; 0x2574 <__vector_10+0xc0>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    254c:	80 91 e2 00 	lds	r24, 0x00E2
    2550:	8e 7f       	andi	r24, 0xFE	; 254
    2552:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    2556:	80 91 e2 00 	lds	r24, 0x00E2
    255a:	80 61       	ori	r24, 0x10	; 16
    255c:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    2560:	80 91 d8 00 	lds	r24, 0x00D8
    2564:	80 62       	ori	r24, 0x20	; 32
    2566:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    256a:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    256c:	85 e0       	ldi	r24, 0x05	; 5
    256e:	80 93 d8 13 	sts	0x13D8, r24
		EVENT_USB_Device_Suspend();
    2572:	7c d3       	rcall	.+1784   	; 0x2c6c <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    2574:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    2578:	84 ff       	sbrs	r24, 4
    257a:	2d c0       	rjmp	.+90     	; 0x25d6 <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    257c:	80 91 e2 00 	lds	r24, 0x00E2
    2580:	84 ff       	sbrs	r24, 4
    2582:	29 c0       	rjmp	.+82     	; 0x25d6 <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    2584:	8c e0       	ldi	r24, 0x0C	; 12
    2586:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    2588:	8e e0       	ldi	r24, 0x0E	; 14
    258a:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    258c:	09 b4       	in	r0, 0x29	; 41
    258e:	00 fe       	sbrs	r0, 0
    2590:	fd cf       	rjmp	.-6      	; 0x258c <__vector_10+0xd8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    2592:	80 91 d8 00 	lds	r24, 0x00D8
    2596:	8f 7d       	andi	r24, 0xDF	; 223
    2598:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    259c:	80 91 e1 00 	lds	r24, 0x00E1
    25a0:	8f 7e       	andi	r24, 0xEF	; 239
    25a2:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    25a6:	80 91 e2 00 	lds	r24, 0x00E2
    25aa:	8f 7e       	andi	r24, 0xEF	; 239
    25ac:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    25b0:	80 91 e2 00 	lds	r24, 0x00E2
    25b4:	81 60       	ori	r24, 0x01	; 1
    25b6:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    25ba:	80 91 d4 13 	lds	r24, 0x13D4
    25be:	88 23       	and	r24, r24
    25c0:	31 f4       	brne	.+12     	; 0x25ce <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    25c2:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    25c6:	87 fd       	sbrc	r24, 7
    25c8:	02 c0       	rjmp	.+4      	; 0x25ce <__vector_10+0x11a>
    25ca:	81 e0       	ldi	r24, 0x01	; 1
    25cc:	01 c0       	rjmp	.+2      	; 0x25d0 <__vector_10+0x11c>
    25ce:	84 e0       	ldi	r24, 0x04	; 4
    25d0:	80 93 d8 13 	sts	0x13D8, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    25d4:	4b d3       	rcall	.+1686   	; 0x2c6c <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    25d6:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    25da:	83 ff       	sbrs	r24, 3
    25dc:	22 c0       	rjmp	.+68     	; 0x2622 <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    25de:	80 91 e2 00 	lds	r24, 0x00E2
    25e2:	83 ff       	sbrs	r24, 3
    25e4:	1e c0       	rjmp	.+60     	; 0x2622 <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    25e6:	80 91 e1 00 	lds	r24, 0x00E1
    25ea:	87 7f       	andi	r24, 0xF7	; 247
    25ec:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    25f0:	82 e0       	ldi	r24, 0x02	; 2
    25f2:	80 93 d8 13 	sts	0x13D8, r24
		USB_Device_ConfigurationNumber = 0;
    25f6:	10 92 d4 13 	sts	0x13D4, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    25fa:	80 91 e1 00 	lds	r24, 0x00E1
    25fe:	8e 7f       	andi	r24, 0xFE	; 254
    2600:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    2604:	80 91 e2 00 	lds	r24, 0x00E2
    2608:	8e 7f       	andi	r24, 0xFE	; 254
    260a:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    260e:	80 91 e2 00 	lds	r24, 0x00E2
    2612:	80 61       	ori	r24, 0x10	; 16
    2614:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    2618:	80 e0       	ldi	r24, 0x00	; 0
    261a:	60 e0       	ldi	r22, 0x00	; 0
    261c:	42 e0       	ldi	r20, 0x02	; 2
    261e:	63 de       	rcall	.-826    	; 0x22e6 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    2620:	25 d3       	rcall	.+1610   	; 0x2c6c <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    2622:	ff 91       	pop	r31
    2624:	ef 91       	pop	r30
    2626:	bf 91       	pop	r27
    2628:	af 91       	pop	r26
    262a:	9f 91       	pop	r25
    262c:	8f 91       	pop	r24
    262e:	7f 91       	pop	r23
    2630:	6f 91       	pop	r22
    2632:	5f 91       	pop	r21
    2634:	4f 91       	pop	r20
    2636:	3f 91       	pop	r19
    2638:	2f 91       	pop	r18
    263a:	0f 90       	pop	r0
    263c:	0b be       	out	0x3b, r0	; 59
    263e:	0f 90       	pop	r0
    2640:	0f be       	out	0x3f, r0	; 63
    2642:	0f 90       	pop	r0
    2644:	1f 90       	pop	r1
    2646:	18 95       	reti

00002648 <Endpoint_Write_Control_Stream_LE>:
    2648:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    264a:	40 91 df 13 	lds	r20, 0x13DF
    264e:	50 91 e0 13 	lds	r21, 0x13E0
    2652:	46 17       	cp	r20, r22
    2654:	57 07       	cpc	r21, r23
    2656:	18 f4       	brcc	.+6      	; 0x265e <Endpoint_Write_Control_Stream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2658:	f9 01       	movw	r30, r18
    265a:	90 e0       	ldi	r25, 0x00	; 0
    265c:	3d c0       	rjmp	.+122    	; 0x26d8 <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    265e:	61 15       	cp	r22, r1
    2660:	71 05       	cpc	r23, r1
    2662:	11 f0       	breq	.+4      	; 0x2668 <Endpoint_Write_Control_Stream_LE+0x20>
    2664:	ab 01       	movw	r20, r22
    2666:	f8 cf       	rjmp	.-16     	; 0x2658 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2668:	80 91 e8 00 	lds	r24, 0x00E8
    266c:	8e 77       	andi	r24, 0x7E	; 126
    266e:	80 93 e8 00 	sts	0x00E8, r24
    2672:	40 e0       	ldi	r20, 0x00	; 0
    2674:	50 e0       	ldi	r21, 0x00	; 0
    2676:	f0 cf       	rjmp	.-32     	; 0x2658 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2678:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    267c:	88 23       	and	r24, r24
    267e:	f1 f1       	breq	.+124    	; 0x26fc <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2680:	85 30       	cpi	r24, 0x05	; 5
    2682:	f1 f1       	breq	.+124    	; 0x2700 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2684:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    2688:	83 ff       	sbrs	r24, 3
    268a:	02 c0       	rjmp	.+4      	; 0x2690 <Endpoint_Write_Control_Stream_LE+0x48>
    268c:	81 e0       	ldi	r24, 0x01	; 1
    268e:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2690:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    2694:	82 fd       	sbrc	r24, 2
    2696:	2c c0       	rjmp	.+88     	; 0x26f0 <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2698:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    269c:	80 ff       	sbrs	r24, 0
    269e:	1c c0       	rjmp	.+56     	; 0x26d8 <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    26a0:	20 91 f2 00 	lds	r18, 0x00F2
    26a4:	30 91 f3 00 	lds	r19, 0x00F3
    26a8:	07 c0       	rjmp	.+14     	; 0x26b8 <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    26aa:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    26ac:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    26b0:	41 50       	subi	r20, 0x01	; 1
    26b2:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    26b4:	2f 5f       	subi	r18, 0xFF	; 255
    26b6:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    26b8:	41 15       	cp	r20, r1
    26ba:	51 05       	cpc	r21, r1
    26bc:	19 f0       	breq	.+6      	; 0x26c4 <Endpoint_Write_Control_Stream_LE+0x7c>
    26be:	28 30       	cpi	r18, 0x08	; 8
    26c0:	31 05       	cpc	r19, r1
    26c2:	98 f3       	brcs	.-26     	; 0x26aa <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    26c4:	90 e0       	ldi	r25, 0x00	; 0
    26c6:	28 30       	cpi	r18, 0x08	; 8
    26c8:	31 05       	cpc	r19, r1
    26ca:	09 f4       	brne	.+2      	; 0x26ce <Endpoint_Write_Control_Stream_LE+0x86>
    26cc:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    26ce:	80 91 e8 00 	lds	r24, 0x00E8
    26d2:	8e 77       	andi	r24, 0x7E	; 126
    26d4:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    26d8:	41 15       	cp	r20, r1
    26da:	51 05       	cpc	r21, r1
    26dc:	69 f6       	brne	.-102    	; 0x2678 <Endpoint_Write_Control_Stream_LE+0x30>
    26de:	99 23       	and	r25, r25
    26e0:	59 f6       	brne	.-106    	; 0x2678 <Endpoint_Write_Control_Stream_LE+0x30>
    26e2:	06 c0       	rjmp	.+12     	; 0x26f0 <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    26e4:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    26e8:	88 23       	and	r24, r24
    26ea:	41 f0       	breq	.+16     	; 0x26fc <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    26ec:	85 30       	cpi	r24, 0x05	; 5
    26ee:	41 f0       	breq	.+16     	; 0x2700 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    26f0:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    26f4:	82 ff       	sbrs	r24, 2
    26f6:	f6 cf       	rjmp	.-20     	; 0x26e4 <Endpoint_Write_Control_Stream_LE+0x9c>
    26f8:	80 e0       	ldi	r24, 0x00	; 0
    26fa:	08 95       	ret
    26fc:	82 e0       	ldi	r24, 0x02	; 2
    26fe:	08 95       	ret
    2700:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2702:	08 95       	ret

00002704 <Endpoint_Read_Control_Stream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    2704:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    2706:	61 15       	cp	r22, r1
    2708:	71 05       	cpc	r23, r1
    270a:	29 f4       	brne	.+10     	; 0x2716 <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    270c:	80 91 e8 00 	lds	r24, 0x00E8
    2710:	8b 77       	andi	r24, 0x7B	; 123
    2712:	80 93 e8 00 	sts	0x00E8, r24
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2716:	f9 01       	movw	r30, r18
    2718:	22 c0       	rjmp	.+68     	; 0x275e <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    271a:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    271e:	88 23       	and	r24, r24
    2720:	71 f1       	breq	.+92     	; 0x277e <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2722:	85 30       	cpi	r24, 0x05	; 5
    2724:	71 f1       	breq	.+92     	; 0x2782 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2726:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    272a:	83 ff       	sbrs	r24, 3
    272c:	02 c0       	rjmp	.+4      	; 0x2732 <Endpoint_Read_Control_Stream_LE+0x2e>
    272e:	81 e0       	ldi	r24, 0x01	; 1
    2730:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2732:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    2736:	82 ff       	sbrs	r24, 2
    2738:	f0 cf       	rjmp	.-32     	; 0x271a <Endpoint_Read_Control_Stream_LE+0x16>
    273a:	06 c0       	rjmp	.+12     	; 0x2748 <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    273c:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    2740:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    2742:	61 50       	subi	r22, 0x01	; 1
    2744:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    2746:	31 f0       	breq	.+12     	; 0x2754 <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    2748:	80 91 f2 00 	lds	r24, 0x00F2
    274c:	90 91 f3 00 	lds	r25, 0x00F3
    2750:	89 2b       	or	r24, r25
    2752:	a1 f7       	brne	.-24     	; 0x273c <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2754:	80 91 e8 00 	lds	r24, 0x00E8
    2758:	8b 77       	andi	r24, 0x7B	; 123
    275a:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    275e:	61 15       	cp	r22, r1
    2760:	71 05       	cpc	r23, r1
    2762:	d9 f6       	brne	.-74     	; 0x271a <Endpoint_Read_Control_Stream_LE+0x16>
    2764:	06 c0       	rjmp	.+12     	; 0x2772 <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2766:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    276a:	88 23       	and	r24, r24
    276c:	41 f0       	breq	.+16     	; 0x277e <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    276e:	85 30       	cpi	r24, 0x05	; 5
    2770:	41 f0       	breq	.+16     	; 0x2782 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2772:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    2776:	80 ff       	sbrs	r24, 0
    2778:	f6 cf       	rjmp	.-20     	; 0x2766 <Endpoint_Read_Control_Stream_LE+0x62>
    277a:	80 e0       	ldi	r24, 0x00	; 0
    277c:	08 95       	ret
    277e:	82 e0       	ldi	r24, 0x02	; 2
    2780:	08 95       	ret
    2782:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2784:	08 95       	ret

00002786 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    2786:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    2788:	40 91 df 13 	lds	r20, 0x13DF
    278c:	50 91 e0 13 	lds	r21, 0x13E0
    2790:	46 17       	cp	r20, r22
    2792:	57 07       	cpc	r21, r23
    2794:	18 f4       	brcc	.+6      	; 0x279c <Endpoint_Write_Control_PStream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    2796:	f9 01       	movw	r30, r18
    2798:	90 e0       	ldi	r25, 0x00	; 0
    279a:	40 c0       	rjmp	.+128    	; 0x281c <Endpoint_Write_Control_PStream_LE+0x96>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    279c:	61 15       	cp	r22, r1
    279e:	71 05       	cpc	r23, r1
    27a0:	11 f0       	breq	.+4      	; 0x27a6 <Endpoint_Write_Control_PStream_LE+0x20>
    27a2:	ab 01       	movw	r20, r22
    27a4:	f8 cf       	rjmp	.-16     	; 0x2796 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    27a6:	80 91 e8 00 	lds	r24, 0x00E8
    27aa:	8e 77       	andi	r24, 0x7E	; 126
    27ac:	80 93 e8 00 	sts	0x00E8, r24
    27b0:	40 e0       	ldi	r20, 0x00	; 0
    27b2:	50 e0       	ldi	r21, 0x00	; 0
    27b4:	f0 cf       	rjmp	.-32     	; 0x2796 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    27b6:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    27ba:	88 23       	and	r24, r24
    27bc:	09 f4       	brne	.+2      	; 0x27c0 <Endpoint_Write_Control_PStream_LE+0x3a>
    27be:	40 c0       	rjmp	.+128    	; 0x2840 <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    27c0:	85 30       	cpi	r24, 0x05	; 5
    27c2:	09 f4       	brne	.+2      	; 0x27c6 <Endpoint_Write_Control_PStream_LE+0x40>
    27c4:	3f c0       	rjmp	.+126    	; 0x2844 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    27c6:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    27ca:	83 ff       	sbrs	r24, 3
    27cc:	02 c0       	rjmp	.+4      	; 0x27d2 <Endpoint_Write_Control_PStream_LE+0x4c>
    27ce:	81 e0       	ldi	r24, 0x01	; 1
    27d0:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    27d2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    27d6:	82 fd       	sbrc	r24, 2
    27d8:	2d c0       	rjmp	.+90     	; 0x2834 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    27da:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    27de:	80 ff       	sbrs	r24, 0
    27e0:	1d c0       	rjmp	.+58     	; 0x281c <Endpoint_Write_Control_PStream_LE+0x96>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    27e2:	20 91 f2 00 	lds	r18, 0x00F2
    27e6:	30 91 f3 00 	lds	r19, 0x00F3
    27ea:	08 c0       	rjmp	.+16     	; 0x27fc <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    27ec:	84 91       	lpm	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    27ee:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    27f2:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    27f4:	41 50       	subi	r20, 0x01	; 1
    27f6:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    27f8:	2f 5f       	subi	r18, 0xFF	; 255
    27fa:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    27fc:	41 15       	cp	r20, r1
    27fe:	51 05       	cpc	r21, r1
    2800:	19 f0       	breq	.+6      	; 0x2808 <Endpoint_Write_Control_PStream_LE+0x82>
    2802:	28 30       	cpi	r18, 0x08	; 8
    2804:	31 05       	cpc	r19, r1
    2806:	90 f3       	brcs	.-28     	; 0x27ec <Endpoint_Write_Control_PStream_LE+0x66>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    2808:	90 e0       	ldi	r25, 0x00	; 0
    280a:	28 30       	cpi	r18, 0x08	; 8
    280c:	31 05       	cpc	r19, r1
    280e:	09 f4       	brne	.+2      	; 0x2812 <Endpoint_Write_Control_PStream_LE+0x8c>
    2810:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2812:	80 91 e8 00 	lds	r24, 0x00E8
    2816:	8e 77       	andi	r24, 0x7E	; 126
    2818:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    281c:	41 15       	cp	r20, r1
    281e:	51 05       	cpc	r21, r1
    2820:	51 f6       	brne	.-108    	; 0x27b6 <Endpoint_Write_Control_PStream_LE+0x30>
    2822:	99 23       	and	r25, r25
    2824:	41 f6       	brne	.-112    	; 0x27b6 <Endpoint_Write_Control_PStream_LE+0x30>
    2826:	06 c0       	rjmp	.+12     	; 0x2834 <Endpoint_Write_Control_PStream_LE+0xae>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2828:	80 91 d8 13 	lds	r24, 0x13D8

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    282c:	88 23       	and	r24, r24
    282e:	41 f0       	breq	.+16     	; 0x2840 <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2830:	85 30       	cpi	r24, 0x05	; 5
    2832:	41 f0       	breq	.+16     	; 0x2844 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2834:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2838:	82 ff       	sbrs	r24, 2
    283a:	f6 cf       	rjmp	.-20     	; 0x2828 <Endpoint_Write_Control_PStream_LE+0xa2>
    283c:	80 e0       	ldi	r24, 0x00	; 0
    283e:	08 95       	ret
    2840:	82 e0       	ldi	r24, 0x02	; 2
    2842:	08 95       	ret
    2844:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2846:	08 95       	ret

00002848 <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2848:	bf 92       	push	r11
    284a:	cf 92       	push	r12
    284c:	df 92       	push	r13
    284e:	ef 92       	push	r14
    2850:	ff 92       	push	r15
    2852:	0f 93       	push	r16
    2854:	1f 93       	push	r17
    2856:	cf 93       	push	r28
    2858:	df 93       	push	r29
    285a:	18 2f       	mov	r17, r24
    285c:	09 2f       	mov	r16, r25
    285e:	7b 01       	movw	r14, r22
    2860:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2862:	97 dd       	rcall	.-1234   	; 0x2392 <Endpoint_WaitUntilReady>
    2864:	b8 2e       	mov	r11, r24
    2866:	88 23       	and	r24, r24
    2868:	b1 f5       	brne	.+108    	; 0x28d6 <Endpoint_Read_Stream_LE+0x8e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    286a:	81 2f       	mov	r24, r17
    286c:	90 2f       	mov	r25, r16
    286e:	9c 01       	movw	r18, r24
    2870:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    2872:	c1 14       	cp	r12, r1
    2874:	d1 04       	cpc	r13, r1
    2876:	39 f0       	breq	.+14     	; 0x2886 <Endpoint_Read_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    2878:	f6 01       	movw	r30, r12
    287a:	80 81       	ld	r24, Z
    287c:	91 81       	ldd	r25, Z+1	; 0x01
    287e:	e8 1a       	sub	r14, r24
    2880:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    2882:	c8 0f       	add	r28, r24
    2884:	d9 1f       	adc	r29, r25
    2886:	00 e0       	ldi	r16, 0x00	; 0
    2888:	10 e0       	ldi	r17, 0x00	; 0
    288a:	22 c0       	rjmp	.+68     	; 0x28d0 <Endpoint_Read_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    288c:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2890:	85 fd       	sbrc	r24, 5
    2892:	16 c0       	rjmp	.+44     	; 0x28c0 <Endpoint_Read_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2894:	80 91 e8 00 	lds	r24, 0x00E8
    2898:	8b 77       	andi	r24, 0x7B	; 123
    289a:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    289e:	e7 d1       	rcall	.+974    	; 0x2c6e <USB_USBTask>
			#endif

			if (BytesProcessed != NULL)
    28a0:	c1 14       	cp	r12, r1
    28a2:	d1 04       	cpc	r13, r1
    28a4:	49 f0       	breq	.+18     	; 0x28b8 <Endpoint_Read_Stream_LE+0x70>
			{
				*BytesProcessed += BytesInTransfer;
    28a6:	f6 01       	movw	r30, r12
    28a8:	80 81       	ld	r24, Z
    28aa:	91 81       	ldd	r25, Z+1	; 0x01
    28ac:	80 0f       	add	r24, r16
    28ae:	91 1f       	adc	r25, r17
    28b0:	91 83       	std	Z+1, r25	; 0x01
    28b2:	80 83       	st	Z, r24
    28b4:	85 e0       	ldi	r24, 0x05	; 5
    28b6:	10 c0       	rjmp	.+32     	; 0x28d8 <Endpoint_Read_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    28b8:	6c dd       	rcall	.-1320   	; 0x2392 <Endpoint_WaitUntilReady>
    28ba:	88 23       	and	r24, r24
    28bc:	49 f0       	breq	.+18     	; 0x28d0 <Endpoint_Read_Stream_LE+0x88>
    28be:	0c c0       	rjmp	.+24     	; 0x28d8 <Endpoint_Read_Stream_LE+0x90>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    28c0:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    28c4:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    28c6:	08 94       	sec
    28c8:	e1 08       	sbc	r14, r1
    28ca:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    28cc:	0f 5f       	subi	r16, 0xFF	; 255
    28ce:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    28d0:	e1 14       	cp	r14, r1
    28d2:	f1 04       	cpc	r15, r1
    28d4:	d9 f6       	brne	.-74     	; 0x288c <Endpoint_Read_Stream_LE+0x44>
    28d6:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    28d8:	df 91       	pop	r29
    28da:	cf 91       	pop	r28
    28dc:	1f 91       	pop	r17
    28de:	0f 91       	pop	r16
    28e0:	ff 90       	pop	r15
    28e2:	ef 90       	pop	r14
    28e4:	df 90       	pop	r13
    28e6:	cf 90       	pop	r12
    28e8:	bf 90       	pop	r11
    28ea:	08 95       	ret

000028ec <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    28ec:	bf 92       	push	r11
    28ee:	cf 92       	push	r12
    28f0:	df 92       	push	r13
    28f2:	ef 92       	push	r14
    28f4:	ff 92       	push	r15
    28f6:	0f 93       	push	r16
    28f8:	1f 93       	push	r17
    28fa:	cf 93       	push	r28
    28fc:	df 93       	push	r29
    28fe:	18 2f       	mov	r17, r24
    2900:	09 2f       	mov	r16, r25
    2902:	7b 01       	movw	r14, r22
    2904:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2906:	45 dd       	rcall	.-1398   	; 0x2392 <Endpoint_WaitUntilReady>
    2908:	b8 2e       	mov	r11, r24
    290a:	88 23       	and	r24, r24
    290c:	b1 f5       	brne	.+108    	; 0x297a <Endpoint_Write_Stream_LE+0x8e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    290e:	81 2f       	mov	r24, r17
    2910:	90 2f       	mov	r25, r16
    2912:	9c 01       	movw	r18, r24
    2914:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    2916:	c1 14       	cp	r12, r1
    2918:	d1 04       	cpc	r13, r1
    291a:	39 f0       	breq	.+14     	; 0x292a <Endpoint_Write_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    291c:	f6 01       	movw	r30, r12
    291e:	80 81       	ld	r24, Z
    2920:	91 81       	ldd	r25, Z+1	; 0x01
    2922:	e8 1a       	sub	r14, r24
    2924:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    2926:	c8 0f       	add	r28, r24
    2928:	d9 1f       	adc	r29, r25
    292a:	00 e0       	ldi	r16, 0x00	; 0
    292c:	10 e0       	ldi	r17, 0x00	; 0
    292e:	22 c0       	rjmp	.+68     	; 0x2974 <Endpoint_Write_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    2930:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2934:	85 fd       	sbrc	r24, 5
    2936:	16 c0       	rjmp	.+44     	; 0x2964 <Endpoint_Write_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2938:	80 91 e8 00 	lds	r24, 0x00E8
    293c:	8e 77       	andi	r24, 0x7E	; 126
    293e:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    2942:	95 d1       	rcall	.+810    	; 0x2c6e <USB_USBTask>
			#endif

			if (BytesProcessed != NULL)
    2944:	c1 14       	cp	r12, r1
    2946:	d1 04       	cpc	r13, r1
    2948:	49 f0       	breq	.+18     	; 0x295c <Endpoint_Write_Stream_LE+0x70>
			{
				*BytesProcessed += BytesInTransfer;
    294a:	f6 01       	movw	r30, r12
    294c:	80 81       	ld	r24, Z
    294e:	91 81       	ldd	r25, Z+1	; 0x01
    2950:	80 0f       	add	r24, r16
    2952:	91 1f       	adc	r25, r17
    2954:	91 83       	std	Z+1, r25	; 0x01
    2956:	80 83       	st	Z, r24
    2958:	85 e0       	ldi	r24, 0x05	; 5
    295a:	10 c0       	rjmp	.+32     	; 0x297c <Endpoint_Write_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    295c:	1a dd       	rcall	.-1484   	; 0x2392 <Endpoint_WaitUntilReady>
    295e:	88 23       	and	r24, r24
    2960:	49 f0       	breq	.+18     	; 0x2974 <Endpoint_Write_Stream_LE+0x88>
    2962:	0c c0       	rjmp	.+24     	; 0x297c <Endpoint_Write_Stream_LE+0x90>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    2964:	89 91       	ld	r24, Y+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2966:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    296a:	08 94       	sec
    296c:	e1 08       	sbc	r14, r1
    296e:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    2970:	0f 5f       	subi	r16, 0xFF	; 255
    2972:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    2974:	e1 14       	cp	r14, r1
    2976:	f1 04       	cpc	r15, r1
    2978:	d9 f6       	brne	.-74     	; 0x2930 <Endpoint_Write_Stream_LE+0x44>
    297a:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    297c:	df 91       	pop	r29
    297e:	cf 91       	pop	r28
    2980:	1f 91       	pop	r17
    2982:	0f 91       	pop	r16
    2984:	ff 90       	pop	r15
    2986:	ef 90       	pop	r14
    2988:	df 90       	pop	r13
    298a:	cf 90       	pop	r12
    298c:	bf 90       	pop	r11
    298e:	08 95       	ret

00002990 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    2990:	0f 93       	push	r16
    2992:	1f 93       	push	r17
    2994:	df 93       	push	r29
    2996:	cf 93       	push	r28
    2998:	cd b7       	in	r28, 0x3d	; 61
    299a:	de b7       	in	r29, 0x3e	; 62
    299c:	ac 97       	sbiw	r28, 0x2c	; 44
    299e:	0f b6       	in	r0, 0x3f	; 63
    29a0:	f8 94       	cli
    29a2:	de bf       	out	0x3e, r29	; 62
    29a4:	0f be       	out	0x3f, r0	; 63
    29a6:	cd bf       	out	0x3d, r28	; 61
    29a8:	e9 ed       	ldi	r30, 0xD9	; 217
    29aa:	f3 e1       	ldi	r31, 0x13	; 19
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    29ac:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    29b0:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    29b2:	23 e1       	ldi	r18, 0x13	; 19
    29b4:	e1 3e       	cpi	r30, 0xE1	; 225
    29b6:	f2 07       	cpc	r31, r18
    29b8:	c9 f7       	brne	.-14     	; 0x29ac <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    29ba:	0e 94 2b 03 	call	0x656	; 0x656 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    29be:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    29c2:	83 ff       	sbrs	r24, 3
    29c4:	3a c1       	rjmp	.+628    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    29c6:	80 91 d9 13 	lds	r24, 0x13D9

		switch (USB_ControlRequest.bRequest)
    29ca:	30 91 da 13 	lds	r19, 0x13DA
    29ce:	35 30       	cpi	r19, 0x05	; 5
    29d0:	09 f4       	brne	.+2      	; 0x29d4 <USB_Device_ProcessControlRequest+0x44>
    29d2:	87 c0       	rjmp	.+270    	; 0x2ae2 <USB_Device_ProcessControlRequest+0x152>
    29d4:	36 30       	cpi	r19, 0x06	; 6
    29d6:	40 f4       	brcc	.+16     	; 0x29e8 <USB_Device_ProcessControlRequest+0x58>
    29d8:	31 30       	cpi	r19, 0x01	; 1
    29da:	c9 f1       	breq	.+114    	; 0x2a4e <USB_Device_ProcessControlRequest+0xbe>
    29dc:	31 30       	cpi	r19, 0x01	; 1
    29de:	70 f0       	brcs	.+28     	; 0x29fc <USB_Device_ProcessControlRequest+0x6c>
    29e0:	33 30       	cpi	r19, 0x03	; 3
    29e2:	09 f0       	breq	.+2      	; 0x29e6 <USB_Device_ProcessControlRequest+0x56>
    29e4:	2a c1       	rjmp	.+596    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
    29e6:	33 c0       	rjmp	.+102    	; 0x2a4e <USB_Device_ProcessControlRequest+0xbe>
    29e8:	38 30       	cpi	r19, 0x08	; 8
    29ea:	09 f4       	brne	.+2      	; 0x29ee <USB_Device_ProcessControlRequest+0x5e>
    29ec:	f7 c0       	rjmp	.+494    	; 0x2bdc <USB_Device_ProcessControlRequest+0x24c>
    29ee:	39 30       	cpi	r19, 0x09	; 9
    29f0:	09 f4       	brne	.+2      	; 0x29f4 <USB_Device_ProcessControlRequest+0x64>
    29f2:	06 c1       	rjmp	.+524    	; 0x2c00 <USB_Device_ProcessControlRequest+0x270>
    29f4:	36 30       	cpi	r19, 0x06	; 6
    29f6:	09 f0       	breq	.+2      	; 0x29fa <USB_Device_ProcessControlRequest+0x6a>
    29f8:	20 c1       	rjmp	.+576    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
    29fa:	97 c0       	rjmp	.+302    	; 0x2b2a <USB_Device_ProcessControlRequest+0x19a>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    29fc:	80 38       	cpi	r24, 0x80	; 128
    29fe:	21 f0       	breq	.+8      	; 0x2a08 <USB_Device_ProcessControlRequest+0x78>
    2a00:	82 38       	cpi	r24, 0x82	; 130
    2a02:	09 f0       	breq	.+2      	; 0x2a06 <USB_Device_ProcessControlRequest+0x76>
    2a04:	1a c1       	rjmp	.+564    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
    2a06:	08 c0       	rjmp	.+16     	; 0x2a18 <USB_Device_ProcessControlRequest+0x88>
    2a08:	90 91 d5 13 	lds	r25, 0x13D5
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    2a0c:	80 91 d6 13 	lds	r24, 0x13D6
    2a10:	88 23       	and	r24, r24
    2a12:	99 f0       	breq	.+38     	; 0x2a3a <USB_Device_ProcessControlRequest+0xaa>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    2a14:	92 60       	ori	r25, 0x02	; 2
    2a16:	11 c0       	rjmp	.+34     	; 0x2a3a <USB_Device_ProcessControlRequest+0xaa>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2a18:	80 91 dd 13 	lds	r24, 0x13DD
    2a1c:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2a1e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2a22:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    2a26:	90 e0       	ldi	r25, 0x00	; 0
    2a28:	25 e0       	ldi	r18, 0x05	; 5
    2a2a:	96 95       	lsr	r25
    2a2c:	87 95       	ror	r24
    2a2e:	2a 95       	dec	r18
    2a30:	e1 f7       	brne	.-8      	; 0x2a2a <USB_Device_ProcessControlRequest+0x9a>
    2a32:	98 2f       	mov	r25, r24
    2a34:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2a36:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2a3a:	80 91 e8 00 	lds	r24, 0x00E8
    2a3e:	87 7f       	andi	r24, 0xF7	; 247
    2a40:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    2a44:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Data >> 8);
    2a48:	10 92 f1 00 	sts	0x00F1, r1
    2a4c:	d2 c0       	rjmp	.+420    	; 0x2bf2 <USB_Device_ProcessControlRequest+0x262>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2a4e:	88 23       	and	r24, r24
    2a50:	19 f0       	breq	.+6      	; 0x2a58 <USB_Device_ProcessControlRequest+0xc8>
    2a52:	82 30       	cpi	r24, 0x02	; 2
    2a54:	09 f0       	breq	.+2      	; 0x2a58 <USB_Device_ProcessControlRequest+0xc8>
    2a56:	f1 c0       	rjmp	.+482    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    2a58:	90 e0       	ldi	r25, 0x00	; 0
    2a5a:	8f 71       	andi	r24, 0x1F	; 31
    2a5c:	90 70       	andi	r25, 0x00	; 0
    2a5e:	00 97       	sbiw	r24, 0x00	; 0
    2a60:	21 f0       	breq	.+8      	; 0x2a6a <USB_Device_ProcessControlRequest+0xda>
    2a62:	02 97       	sbiw	r24, 0x02	; 2
    2a64:	09 f0       	breq	.+2      	; 0x2a68 <USB_Device_ProcessControlRequest+0xd8>
    2a66:	e9 c0       	rjmp	.+466    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
    2a68:	0c c0       	rjmp	.+24     	; 0x2a82 <USB_Device_ProcessControlRequest+0xf2>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    2a6a:	80 91 db 13 	lds	r24, 0x13DB
    2a6e:	81 30       	cpi	r24, 0x01	; 1
    2a70:	09 f0       	breq	.+2      	; 0x2a74 <USB_Device_ProcessControlRequest+0xe4>
    2a72:	e3 c0       	rjmp	.+454    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    2a74:	10 92 d6 13 	sts	0x13D6, r1
    2a78:	33 30       	cpi	r19, 0x03	; 3
    2a7a:	69 f5       	brne	.+90     	; 0x2ad6 <USB_Device_ProcessControlRequest+0x146>
    2a7c:	80 93 d6 13 	sts	0x13D6, r24
    2a80:	2a c0       	rjmp	.+84     	; 0x2ad6 <USB_Device_ProcessControlRequest+0x146>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    2a82:	80 91 db 13 	lds	r24, 0x13DB
    2a86:	88 23       	and	r24, r24
    2a88:	31 f5       	brne	.+76     	; 0x2ad6 <USB_Device_ProcessControlRequest+0x146>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2a8a:	20 91 dd 13 	lds	r18, 0x13DD
    2a8e:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    2a90:	09 f4       	brne	.+2      	; 0x2a94 <USB_Device_ProcessControlRequest+0x104>
    2a92:	d3 c0       	rjmp	.+422    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2a94:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    2a98:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    2a9c:	80 ff       	sbrs	r24, 0
    2a9e:	1b c0       	rjmp	.+54     	; 0x2ad6 <USB_Device_ProcessControlRequest+0x146>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    2aa0:	33 30       	cpi	r19, 0x03	; 3
    2aa2:	21 f4       	brne	.+8      	; 0x2aac <USB_Device_ProcessControlRequest+0x11c>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2aa4:	80 91 eb 00 	lds	r24, 0x00EB
    2aa8:	80 62       	ori	r24, 0x20	; 32
    2aaa:	13 c0       	rjmp	.+38     	; 0x2ad2 <USB_Device_ProcessControlRequest+0x142>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    2aac:	80 91 eb 00 	lds	r24, 0x00EB
    2ab0:	80 61       	ori	r24, 0x10	; 16
    2ab2:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    2ab6:	81 e0       	ldi	r24, 0x01	; 1
    2ab8:	90 e0       	ldi	r25, 0x00	; 0
    2aba:	02 c0       	rjmp	.+4      	; 0x2ac0 <USB_Device_ProcessControlRequest+0x130>
    2abc:	88 0f       	add	r24, r24
    2abe:	99 1f       	adc	r25, r25
    2ac0:	2a 95       	dec	r18
    2ac2:	e2 f7       	brpl	.-8      	; 0x2abc <USB_Device_ProcessControlRequest+0x12c>
    2ac4:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    2ac8:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    2acc:	80 91 eb 00 	lds	r24, 0x00EB
    2ad0:	88 60       	ori	r24, 0x08	; 8
    2ad2:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2ad6:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2ada:	80 91 e8 00 	lds	r24, 0x00E8
    2ade:	87 7f       	andi	r24, 0xF7	; 247
    2ae0:	8b c0       	rjmp	.+278    	; 0x2bf8 <USB_Device_ProcessControlRequest+0x268>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2ae2:	88 23       	and	r24, r24
    2ae4:	09 f0       	breq	.+2      	; 0x2ae8 <USB_Device_ProcessControlRequest+0x158>
    2ae6:	a9 c0       	rjmp	.+338    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    2ae8:	10 91 db 13 	lds	r17, 0x13DB
    2aec:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2aee:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2af0:	f8 94       	cli
    2af2:	80 91 e8 00 	lds	r24, 0x00E8
    2af6:	87 7f       	andi	r24, 0xF7	; 247
    2af8:	80 93 e8 00 	sts	0x00E8, r24
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    2afc:	29 dc       	rcall	.-1966   	; 0x2350 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2afe:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    2b02:	80 ff       	sbrs	r24, 0
    2b04:	fc cf       	rjmp	.-8      	; 0x2afe <USB_Device_ProcessControlRequest+0x16e>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2b06:	80 91 e3 00 	lds	r24, 0x00E3
    2b0a:	80 78       	andi	r24, 0x80	; 128
    2b0c:	81 2b       	or	r24, r17

				UDADDR = Temp;
    2b0e:	80 93 e3 00 	sts	0x00E3, r24
				UDADDR = Temp | (1 << ADDEN);
    2b12:	80 68       	ori	r24, 0x80	; 128
    2b14:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2b18:	11 23       	and	r17, r17
    2b1a:	11 f4       	brne	.+4      	; 0x2b20 <USB_Device_ProcessControlRequest+0x190>
    2b1c:	82 e0       	ldi	r24, 0x02	; 2
    2b1e:	01 c0       	rjmp	.+2      	; 0x2b22 <USB_Device_ProcessControlRequest+0x192>
    2b20:	83 e0       	ldi	r24, 0x03	; 3
    2b22:	80 93 d8 13 	sts	0x13D8, r24
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2b26:	0f bf       	out	0x3f, r16	; 63
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;				
				#endif
				
				GCC_MEMORY_BARRIER();
    2b28:	88 c0       	rjmp	.+272    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    2b2a:	80 58       	subi	r24, 0x80	; 128
    2b2c:	82 30       	cpi	r24, 0x02	; 2
    2b2e:	08 f0       	brcs	.+2      	; 0x2b32 <USB_Device_ProcessControlRequest+0x1a2>
    2b30:	84 c0       	rjmp	.+264    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    2b32:	80 91 db 13 	lds	r24, 0x13DB
    2b36:	90 91 dc 13 	lds	r25, 0x13DC
    2b3a:	23 e0       	ldi	r18, 0x03	; 3
    2b3c:	8c 3d       	cpi	r24, 0xDC	; 220
    2b3e:	92 07       	cpc	r25, r18
    2b40:	09 f0       	breq	.+2      	; 0x2b44 <USB_Device_ProcessControlRequest+0x1b4>
    2b42:	33 c0       	rjmp	.+102    	; 0x2baa <USB_Device_ProcessControlRequest+0x21a>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    2b44:	83 e0       	ldi	r24, 0x03	; 3
    2b46:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    2b48:	8a e2       	ldi	r24, 0x2A	; 42
    2b4a:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    2b4c:	7f b7       	in	r23, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2b4e:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    2b50:	de 01       	movw	r26, r28
    2b52:	15 96       	adiw	r26, 0x05	; 5
    2b54:	6e e0       	ldi	r22, 0x0E	; 14
    2b56:	40 e0       	ldi	r20, 0x00	; 0
    2b58:	50 e0       	ldi	r21, 0x00	; 0
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    2b5a:	11 e2       	ldi	r17, 0x21	; 33
    2b5c:	e6 2f       	mov	r30, r22
    2b5e:	f0 e0       	ldi	r31, 0x00	; 0
    2b60:	10 93 57 00 	sts	0x0057, r17
    2b64:	84 91       	lpm	r24, Z+

					if (SerialCharNum & 0x01)
    2b66:	40 ff       	sbrs	r20, 0
    2b68:	03 c0       	rjmp	.+6      	; 0x2b70 <USB_Device_ProcessControlRequest+0x1e0>
					{
						SerialByte >>= 4;
    2b6a:	82 95       	swap	r24
    2b6c:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    2b6e:	6f 5f       	subi	r22, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    2b70:	8f 70       	andi	r24, 0x0F	; 15
    2b72:	28 2f       	mov	r18, r24
    2b74:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    2b76:	8a 30       	cpi	r24, 0x0A	; 10
    2b78:	18 f0       	brcs	.+6      	; 0x2b80 <USB_Device_ProcessControlRequest+0x1f0>
    2b7a:	c9 01       	movw	r24, r18
    2b7c:	c7 96       	adiw	r24, 0x37	; 55
    2b7e:	02 c0       	rjmp	.+4      	; 0x2b84 <USB_Device_ProcessControlRequest+0x1f4>
    2b80:	c9 01       	movw	r24, r18
    2b82:	c0 96       	adiw	r24, 0x30	; 48
    2b84:	8d 93       	st	X+, r24
    2b86:	9d 93       	st	X+, r25
    2b88:	4f 5f       	subi	r20, 0xFF	; 255
    2b8a:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    2b8c:	44 31       	cpi	r20, 0x14	; 20
    2b8e:	51 05       	cpc	r21, r1
    2b90:	29 f7       	brne	.-54     	; 0x2b5c <USB_Device_ProcessControlRequest+0x1cc>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2b92:	7f bf       	out	0x3f, r23	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2b94:	80 91 e8 00 	lds	r24, 0x00E8
    2b98:	87 7f       	andi	r24, 0xF7	; 247
    2b9a:	80 93 e8 00 	sts	0x00E8, r24
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    2b9e:	ce 01       	movw	r24, r28
    2ba0:	03 96       	adiw	r24, 0x03	; 3
    2ba2:	6a e2       	ldi	r22, 0x2A	; 42
    2ba4:	70 e0       	ldi	r23, 0x00	; 0
    2ba6:	50 dd       	rcall	.-1376   	; 0x2648 <Endpoint_Write_Control_Stream_LE>
    2ba8:	13 c0       	rjmp	.+38     	; 0x2bd0 <USB_Device_ProcessControlRequest+0x240>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    2baa:	60 91 dd 13 	lds	r22, 0x13DD
    2bae:	ae 01       	movw	r20, r28
    2bb0:	4f 5f       	subi	r20, 0xFF	; 255
    2bb2:	5f 4f       	sbci	r21, 0xFF	; 255
    2bb4:	0e 94 09 04 	call	0x812	; 0x812 <CALLBACK_USB_GetDescriptor>
    2bb8:	bc 01       	movw	r22, r24
    2bba:	00 97       	sbiw	r24, 0x00	; 0
    2bbc:	09 f4       	brne	.+2      	; 0x2bc0 <USB_Device_ProcessControlRequest+0x230>
    2bbe:	3d c0       	rjmp	.+122    	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
    2bc0:	80 91 e8 00 	lds	r24, 0x00E8
    2bc4:	87 7f       	andi	r24, 0xF7	; 247
    2bc6:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    2bca:	89 81       	ldd	r24, Y+1	; 0x01
    2bcc:	9a 81       	ldd	r25, Y+2	; 0x02
    2bce:	db dd       	rcall	.-1098   	; 0x2786 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2bd0:	80 91 e8 00 	lds	r24, 0x00E8
    2bd4:	8b 77       	andi	r24, 0x7B	; 123
    2bd6:	80 93 e8 00 	sts	0x00E8, r24
    2bda:	2f c0       	rjmp	.+94     	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    2bdc:	80 38       	cpi	r24, 0x80	; 128
    2bde:	69 f5       	brne	.+90     	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2be0:	80 91 e8 00 	lds	r24, 0x00E8
    2be4:	87 7f       	andi	r24, 0xF7	; 247
    2be6:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    2bea:	80 91 d4 13 	lds	r24, 0x13D4
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2bee:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2bf2:	80 91 e8 00 	lds	r24, 0x00E8
    2bf6:	8e 77       	andi	r24, 0x7E	; 126
    2bf8:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    2bfc:	a9 db       	rcall	.-2222   	; 0x2350 <Endpoint_ClearStatusStage>
    2bfe:	1d c0       	rjmp	.+58     	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2c00:	88 23       	and	r24, r24
    2c02:	d9 f4       	brne	.+54     	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2c04:	90 91 db 13 	lds	r25, 0x13DB
    2c08:	92 30       	cpi	r25, 0x02	; 2
    2c0a:	b8 f4       	brcc	.+46     	; 0x2c3a <USB_Device_ProcessControlRequest+0x2aa>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2c0c:	80 91 e8 00 	lds	r24, 0x00E8
    2c10:	87 7f       	andi	r24, 0xF7	; 247
    2c12:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2c16:	90 93 d4 13 	sts	0x13D4, r25

	Endpoint_ClearStatusStage();
    2c1a:	9a db       	rcall	.-2252   	; 0x2350 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    2c1c:	80 91 d4 13 	lds	r24, 0x13D4
    2c20:	88 23       	and	r24, r24
    2c22:	31 f4       	brne	.+12     	; 0x2c30 <USB_Device_ProcessControlRequest+0x2a0>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2c24:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2c28:	87 fd       	sbrc	r24, 7
    2c2a:	02 c0       	rjmp	.+4      	; 0x2c30 <USB_Device_ProcessControlRequest+0x2a0>
    2c2c:	81 e0       	ldi	r24, 0x01	; 1
    2c2e:	01 c0       	rjmp	.+2      	; 0x2c32 <USB_Device_ProcessControlRequest+0x2a2>
    2c30:	84 e0       	ldi	r24, 0x04	; 4
    2c32:	80 93 d8 13 	sts	0x13D8, r24

	EVENT_USB_Device_ConfigurationChanged();
    2c36:	0e 94 83 03 	call	0x706	; 0x706 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2c3a:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    2c3e:	83 ff       	sbrs	r24, 3
    2c40:	0a c0       	rjmp	.+20     	; 0x2c56 <USB_Device_ProcessControlRequest+0x2c6>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2c42:	80 91 eb 00 	lds	r24, 0x00EB
    2c46:	80 62       	ori	r24, 0x20	; 32
    2c48:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2c4c:	80 91 e8 00 	lds	r24, 0x00E8
    2c50:	87 7f       	andi	r24, 0xF7	; 247
    2c52:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    2c56:	ac 96       	adiw	r28, 0x2c	; 44
    2c58:	0f b6       	in	r0, 0x3f	; 63
    2c5a:	f8 94       	cli
    2c5c:	de bf       	out	0x3e, r29	; 62
    2c5e:	0f be       	out	0x3f, r0	; 63
    2c60:	cd bf       	out	0x3d, r28	; 61
    2c62:	cf 91       	pop	r28
    2c64:	df 91       	pop	r29
    2c66:	1f 91       	pop	r17
    2c68:	0f 91       	pop	r16
    2c6a:	08 95       	ret

00002c6c <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    2c6c:	08 95       	ret

00002c6e <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    2c6e:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    2c70:	80 91 d8 13 	lds	r24, 0x13D8
    2c74:	88 23       	and	r24, r24
    2c76:	61 f0       	breq	.+24     	; 0x2c90 <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    2c78:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2c7c:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    2c80:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    2c84:	83 ff       	sbrs	r24, 3
    2c86:	01 c0       	rjmp	.+2      	; 0x2c8a <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
    2c88:	83 de       	rcall	.-762    	; 0x2990 <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    2c8a:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2c8c:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    2c90:	1f 91       	pop	r17
    2c92:	08 95       	ret

00002c94 <Serial_putchar>:

FILE USARTSerialStream;

int Serial_putchar(char DataByte,
                   FILE *Stream)
{
    2c94:	98 2f       	mov	r25, r24
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2c96:	80 91 c8 00 	lds	r24, 0x00C8
    2c9a:	85 ff       	sbrs	r24, 5
    2c9c:	fc cf       	rjmp	.-8      	; 0x2c96 <Serial_putchar+0x2>
				UDR1 = DataByte;
    2c9e:	90 93 ce 00 	sts	0x00CE, r25
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2ca2:	80 e0       	ldi	r24, 0x00	; 0
    2ca4:	90 e0       	ldi	r25, 0x00	; 0
    2ca6:	08 95       	ret

00002ca8 <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2ca8:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2cac:	87 fd       	sbrc	r24, 7
    2cae:	03 c0       	rjmp	.+6      	; 0x2cb6 <Serial_getchar+0xe>
    2cb0:	2e ef       	ldi	r18, 0xFE	; 254
    2cb2:	3f ef       	ldi	r19, 0xFF	; 255
    2cb4:	0b c0       	rjmp	.+22     	; 0x2ccc <Serial_getchar+0x24>
    2cb6:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2cba:	87 fd       	sbrc	r24, 7
    2cbc:	03 c0       	rjmp	.+6      	; 0x2cc4 <Serial_getchar+0x1c>
    2cbe:	2f ef       	ldi	r18, 0xFF	; 255
    2cc0:	3f ef       	ldi	r19, 0xFF	; 255
    2cc2:	04 c0       	rjmp	.+8      	; 0x2ccc <Serial_getchar+0x24>
				  return -1;
				
				return UDR1;
    2cc4:	80 91 ce 00 	lds	r24, 0x00CE
    2cc8:	28 2f       	mov	r18, r24
    2cca:	30 e0       	ldi	r19, 0x00	; 0
	  return _FDEV_EOF;

	return Serial_ReceiveByte();
}
    2ccc:	c9 01       	movw	r24, r18
    2cce:	08 95       	ret

00002cd0 <memcpy_P>:
    2cd0:	fb 01       	movw	r30, r22
    2cd2:	dc 01       	movw	r26, r24
    2cd4:	02 c0       	rjmp	.+4      	; 0x2cda <memcpy_P+0xa>
    2cd6:	05 90       	lpm	r0, Z+
    2cd8:	0d 92       	st	X+, r0
    2cda:	41 50       	subi	r20, 0x01	; 1
    2cdc:	50 40       	sbci	r21, 0x00	; 0
    2cde:	d8 f7       	brcc	.-10     	; 0x2cd6 <memcpy_P+0x6>
    2ce0:	08 95       	ret

00002ce2 <strcpy_P>:
    2ce2:	fb 01       	movw	r30, r22
    2ce4:	dc 01       	movw	r26, r24
    2ce6:	05 90       	lpm	r0, Z+
    2ce8:	0d 92       	st	X+, r0
    2cea:	00 20       	and	r0, r0
    2cec:	e1 f7       	brne	.-8      	; 0x2ce6 <strcpy_P+0x4>
    2cee:	08 95       	ret

00002cf0 <strlen_P>:
    2cf0:	fc 01       	movw	r30, r24
    2cf2:	05 90       	lpm	r0, Z+
    2cf4:	00 20       	and	r0, r0
    2cf6:	e9 f7       	brne	.-6      	; 0x2cf2 <strlen_P+0x2>
    2cf8:	80 95       	com	r24
    2cfa:	90 95       	com	r25
    2cfc:	8e 0f       	add	r24, r30
    2cfe:	9f 1f       	adc	r25, r31
    2d00:	08 95       	ret

00002d02 <strncpy_P>:
    2d02:	fb 01       	movw	r30, r22
    2d04:	dc 01       	movw	r26, r24
    2d06:	41 50       	subi	r20, 0x01	; 1
    2d08:	50 40       	sbci	r21, 0x00	; 0
    2d0a:	48 f0       	brcs	.+18     	; 0x2d1e <strncpy_P+0x1c>
    2d0c:	05 90       	lpm	r0, Z+
    2d0e:	0d 92       	st	X+, r0
    2d10:	00 20       	and	r0, r0
    2d12:	c9 f7       	brne	.-14     	; 0x2d06 <strncpy_P+0x4>
    2d14:	01 c0       	rjmp	.+2      	; 0x2d18 <strncpy_P+0x16>
    2d16:	1d 92       	st	X+, r1
    2d18:	41 50       	subi	r20, 0x01	; 1
    2d1a:	50 40       	sbci	r21, 0x00	; 0
    2d1c:	e0 f7       	brcc	.-8      	; 0x2d16 <strncpy_P+0x14>
    2d1e:	08 95       	ret

00002d20 <memcmp>:
    2d20:	fb 01       	movw	r30, r22
    2d22:	dc 01       	movw	r26, r24
    2d24:	04 c0       	rjmp	.+8      	; 0x2d2e <memcmp+0xe>
    2d26:	8d 91       	ld	r24, X+
    2d28:	01 90       	ld	r0, Z+
    2d2a:	80 19       	sub	r24, r0
    2d2c:	21 f4       	brne	.+8      	; 0x2d36 <memcmp+0x16>
    2d2e:	41 50       	subi	r20, 0x01	; 1
    2d30:	50 40       	sbci	r21, 0x00	; 0
    2d32:	c8 f7       	brcc	.-14     	; 0x2d26 <memcmp+0x6>
    2d34:	88 1b       	sub	r24, r24
    2d36:	99 0b       	sbc	r25, r25
    2d38:	08 95       	ret

00002d3a <memcpy>:
    2d3a:	fb 01       	movw	r30, r22
    2d3c:	dc 01       	movw	r26, r24
    2d3e:	02 c0       	rjmp	.+4      	; 0x2d44 <memcpy+0xa>
    2d40:	01 90       	ld	r0, Z+
    2d42:	0d 92       	st	X+, r0
    2d44:	41 50       	subi	r20, 0x01	; 1
    2d46:	50 40       	sbci	r21, 0x00	; 0
    2d48:	d8 f7       	brcc	.-10     	; 0x2d40 <memcpy+0x6>
    2d4a:	08 95       	ret

00002d4c <memmove>:
    2d4c:	68 17       	cp	r22, r24
    2d4e:	79 07       	cpc	r23, r25
    2d50:	68 f4       	brcc	.+26     	; 0x2d6c <memmove+0x20>
    2d52:	fb 01       	movw	r30, r22
    2d54:	dc 01       	movw	r26, r24
    2d56:	e4 0f       	add	r30, r20
    2d58:	f5 1f       	adc	r31, r21
    2d5a:	a4 0f       	add	r26, r20
    2d5c:	b5 1f       	adc	r27, r21
    2d5e:	02 c0       	rjmp	.+4      	; 0x2d64 <memmove+0x18>
    2d60:	02 90       	ld	r0, -Z
    2d62:	0e 92       	st	-X, r0
    2d64:	41 50       	subi	r20, 0x01	; 1
    2d66:	50 40       	sbci	r21, 0x00	; 0
    2d68:	d8 f7       	brcc	.-10     	; 0x2d60 <memmove+0x14>
    2d6a:	08 95       	ret
    2d6c:	e6 cf       	rjmp	.-52     	; 0x2d3a <memcpy>

00002d6e <strncmp>:
    2d6e:	fb 01       	movw	r30, r22
    2d70:	dc 01       	movw	r26, r24
    2d72:	41 50       	subi	r20, 0x01	; 1
    2d74:	50 40       	sbci	r21, 0x00	; 0
    2d76:	30 f0       	brcs	.+12     	; 0x2d84 <strncmp+0x16>
    2d78:	8d 91       	ld	r24, X+
    2d7a:	01 90       	ld	r0, Z+
    2d7c:	80 19       	sub	r24, r0
    2d7e:	19 f4       	brne	.+6      	; 0x2d86 <strncmp+0x18>
    2d80:	00 20       	and	r0, r0
    2d82:	b9 f7       	brne	.-18     	; 0x2d72 <strncmp+0x4>
    2d84:	88 1b       	sub	r24, r24
    2d86:	99 0b       	sbc	r25, r25
    2d88:	08 95       	ret

00002d8a <_exit>:
    2d8a:	f8 94       	cli

00002d8c <__stop_program>:
    2d8c:	ff cf       	rjmp	.-2      	; 0x2d8c <__stop_program>
