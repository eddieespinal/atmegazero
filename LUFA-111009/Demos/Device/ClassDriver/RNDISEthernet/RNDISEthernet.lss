
RNDISEthernet.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000f8  00800100  00002e48  00002edc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e48  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00001225  008001f8  008001f8  00002fd4  2**0
                  ALLOC
  3 .debug_aranges 00000660  00000000  00000000  00002fd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00001095  00000000  00000000  00003634  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000ae9f  00000000  00000000  000046c9  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000031a0  00000000  00000000  0000f568  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00008067  00000000  00000000  00012708  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000940  00000000  00000000  0001a770  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00003d78  00000000  00000000  0001b0b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000439c  00000000  00000000  0001ee28  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000748  00000000  00000000  000231c4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
	return true;
#endif
}

void Endpoint_ClearEndpoints(void)
{
       0:	10 c2       	rjmp	.+1056   	; 0x422 <__ctors_end>
	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
}
       2:	00 00       	nop

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
       4:	2c c2       	rjmp	.+1112   	; 0x45e <__bad_interrupt>

	return Serial_ReceiveByte();
}

int Serial_getchar_Blocking(FILE *Stream)
{
       6:	00 00       	nop
       8:	2a c2       	rjmp	.+1108   	; 0x45e <__bad_interrupt>
       a:	00 00       	nop
       c:	28 c2       	rjmp	.+1104   	; 0x45e <__bad_interrupt>
       e:	00 00       	nop
      10:	26 c2       	rjmp	.+1100   	; 0x45e <__bad_interrupt>
      12:	00 00       	nop
      14:	24 c2       	rjmp	.+1096   	; 0x45e <__bad_interrupt>
      16:	00 00       	nop
      18:	22 c2       	rjmp	.+1092   	; 0x45e <__bad_interrupt>
      1a:	00 00       	nop
      1c:	20 c2       	rjmp	.+1088   	; 0x45e <__bad_interrupt>
      1e:	00 00       	nop
      20:	1e c2       	rjmp	.+1084   	; 0x45e <__bad_interrupt>
      22:	00 00       	nop
      24:	1c c2       	rjmp	.+1080   	; 0x45e <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 72 0e 	jmp	0x1ce4	; 0x1ce4 <__vector_10>
      2c:	18 c2       	rjmp	.+1072   	; 0x45e <__bad_interrupt>
      2e:	00 00       	nop
      30:	16 c2       	rjmp	.+1068   	; 0x45e <__bad_interrupt>
      32:	00 00       	nop
      34:	14 c2       	rjmp	.+1064   	; 0x45e <__bad_interrupt>
      36:	00 00       	nop
      38:	12 c2       	rjmp	.+1060   	; 0x45e <__bad_interrupt>
      3a:	00 00       	nop
      3c:	10 c2       	rjmp	.+1056   	; 0x45e <__bad_interrupt>
      3e:	00 00       	nop
      40:	0e c2       	rjmp	.+1052   	; 0x45e <__bad_interrupt>
      42:	00 00       	nop
      44:	0c c2       	rjmp	.+1048   	; 0x45e <__bad_interrupt>
      46:	00 00       	nop
      48:	0a c2       	rjmp	.+1044   	; 0x45e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	08 c2       	rjmp	.+1040   	; 0x45e <__bad_interrupt>
      4e:	00 00       	nop
      50:	06 c2       	rjmp	.+1036   	; 0x45e <__bad_interrupt>
      52:	00 00       	nop
      54:	04 c2       	rjmp	.+1032   	; 0x45e <__bad_interrupt>
      56:	00 00       	nop
      58:	02 c2       	rjmp	.+1028   	; 0x45e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	00 c2       	rjmp	.+1024   	; 0x45e <__bad_interrupt>
      5e:	00 00       	nop
      60:	fe c1       	rjmp	.+1020   	; 0x45e <__bad_interrupt>
      62:	00 00       	nop
      64:	fc c1       	rjmp	.+1016   	; 0x45e <__bad_interrupt>
      66:	00 00       	nop
      68:	fa c1       	rjmp	.+1012   	; 0x45e <__bad_interrupt>
      6a:	00 00       	nop
      6c:	f8 c1       	rjmp	.+1008   	; 0x45e <__bad_interrupt>
      6e:	00 00       	nop
      70:	f6 c1       	rjmp	.+1004   	; 0x45e <__bad_interrupt>
      72:	00 00       	nop
      74:	f4 c1       	rjmp	.+1000   	; 0x45e <__bad_interrupt>
      76:	00 00       	nop
      78:	f2 c1       	rjmp	.+996    	; 0x45e <__bad_interrupt>
      7a:	00 00       	nop
      7c:	f0 c1       	rjmp	.+992    	; 0x45e <__bad_interrupt>
      7e:	00 00       	nop
      80:	ee c1       	rjmp	.+988    	; 0x45e <__bad_interrupt>
      82:	00 00       	nop
      84:	ec c1       	rjmp	.+984    	; 0x45e <__bad_interrupt>
      86:	00 00       	nop
      88:	ea c1       	rjmp	.+980    	; 0x45e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	e8 c1       	rjmp	.+976    	; 0x45e <__bad_interrupt>
      8e:	00 00       	nop
      90:	e6 c1       	rjmp	.+972    	; 0x45e <__bad_interrupt>
      92:	00 00       	nop
      94:	e4 c1       	rjmp	.+968    	; 0x45e <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 02 00 00 08 eb 03 4c 20 01 00 01 02     ..........L ....
      a8:	00 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
      ba:	ff 00 05 24 00 10 01 04 24 02 00 05 24 06 00 01     ...$....$...$...
      ca:	07 05 83 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
      da:	07 05 02 02 40 00 01 07 05 81 02 40 00 01           ....@......@..

000000e8 <LanguageString>:
      e8:	04 03 09 04                                         ....

000000ec <ManufacturerString>:
      ec:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
      fc:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000106 <ProductString>:
     106:	28 03 4c 00 55 00 46 00 41 00 20 00 52 00 4e 00     (.L.U.F.A. .R.N.
     116:	44 00 49 00 53 00 20 00 43 00 44 00 43 00 20 00     D.I.S. .C.D.C. .
     126:	44 00 65 00 6d 00 6f 00 00 00                       D.e.m.o...

00000130 <HTTP200Header>:
     130:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     140:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 52 4e     .Server: LUFA RN
     150:	44 49 53 0d 0a 43 6f 6e 74 65 6e 74 2d 74 79 70     DIS..Content-typ
     160:	65 3a 20 74 65 78 74 2f 68 74 6d 6c 0d 0a 43 6f     e: text/html..Co
     170:	6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d     nnection: close.
     180:	0a 0d 0a 00                                         ....

00000184 <HTTP404Header>:
     184:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     194:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1a4:	4c 55 46 41 20 52 4e 44 49 53 0d 0a 43 6f 6e 6e     LUFA RNDIS..Conn
     1b4:	65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d     ection: close...
     1c4:	0a 00                                               ..

000001c6 <HTTPPage>:
     1c6:	3c 68 74 6d 6c 3e 09 3c 68 65 61 64 3e 09 09 3c     <html>.<head>..<
     1d6:	74 69 74 6c 65 3e 09 09 09 4c 55 46 41 20 57 65     title>...LUFA We
     1e6:	62 73 65 72 76 65 72 20 44 65 6d 6f 09 09 3c 2f     bserver Demo..</
     1f6:	74 69 74 6c 65 3e 09 3c 2f 68 65 61 64 3e 09 3c     title>.</head>.<
     206:	62 6f 64 79 3e 09 09 3c 68 31 3e 48 65 6c 6c 6f     body>..<h1>Hello
     216:	20 66 72 6f 6d 20 79 6f 75 72 20 55 53 42 20 41      from your USB A
     226:	56 52 21 3c 2f 68 31 3e 09 09 3c 70 3e 09 09 09     VR!</h1>..<p>...
     236:	48 65 6c 6c 6f 21 20 57 65 6c 63 6f 6d 65 20 74     Hello! Welcome t
     246:	6f 20 74 68 65 20 4c 55 46 41 20 52 4e 44 49 53     o the LUFA RNDIS
     256:	20 44 65 6d 6f 20 57 65 62 73 65 72 76 65 72 20      Demo Webserver 
     266:	74 65 73 74 20 70 61 67 65 2c 20 72 75 6e 6e 69     test page, runni
     276:	6e 67 20 6f 6e 20 79 6f 75 72 20 55 53 42 20 41     ng on your USB A
     286:	56 52 20 76 69 61 20 74 68 65 20 4c 55 46 41 20     VR via the LUFA 
     296:	6c 69 62 72 61 72 79 2e 20 54 68 69 73 20 64 65     library. This de
     2a6:	6d 6f 6e 73 74 72 61 74 65 73 20 74 68 65 20 48     monstrates the H
     2b6:	54 54 50 20 77 65 62 73 65 72 76 65 72 2c 20 54     TTP webserver, T
     2c6:	43 50 2f 49 50 20 73 74 61 63 6b 20 61 6e 64 20     CP/IP stack and 
     2d6:	52 4e 44 49 53 20 64 65 6d 6f 20 61 6c 6c 20 72     RNDIS demo all r
     2e6:	75 6e 6e 69 6e 67 20 61 74 6f 70 20 74 68 65 20     unning atop the 
     2f6:	4c 55 46 41 20 55 53 42 20 73 74 61 63 6b 2e 09     LUFA USB stack..
     306:	09 09 3c 62 72 20 2f 3e 3c 62 72 20 2f 3e 09 09     ..<br /><br />..
     316:	09 3c 73 6d 61 6c 6c 3e 50 72 6f 6a 65 63 74 20     .<small>Project 
     326:	49 6e 66 6f 72 6d 61 74 69 6f 6e 3a 20 3c 61 20     Information: <a 
     336:	68 72 65 66 3d 22 68 74 74 70 3a 2f 2f 77 77 77     href="http://www
     346:	2e 6c 75 66 61 2d 6c 69 62 2e 6f 72 67 22 3e 68     .lufa-lib.org">h
     356:	74 74 70 3a 2f 2f 77 77 77 2e 6c 75 66 61 2d 6c     ttp://www.lufa-l
     366:	69 62 2e 6f 72 67 3c 2f 61 3e 2e 3c 2f 73 6d 61     ib.org</a>.</sma
     376:	6c 6c 3e 09 09 09 3c 68 72 20 2f 3e 09 09 09 3c     ll>...<hr />...<
     386:	69 3e 4c 55 46 41 20 56 65 72 73 69 6f 6e 3a 20     i>LUFA Version: 
     396:	3c 2f 69 3e 31 31 31 30 30 39 09 09 3c 2f 70 3e     </i>111009..</p>
     3a6:	09 3c 2f 62 6f 64 79 3e 3c 2f 68 74 6d 6c 3e 00     .</body></html>.

000003b6 <AdapterSupportedOIDList>:
     3b6:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3c6:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3d6:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3e6:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3f6:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     406:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     416:	01 01 02 01 02 01 02 01 03 01 02 01                 ............

00000422 <__ctors_end>:
     422:	11 24       	eor	r1, r1
     424:	1f be       	out	0x3f, r1	; 63
     426:	cf ef       	ldi	r28, 0xFF	; 255
     428:	d0 e2       	ldi	r29, 0x20	; 32
     42a:	de bf       	out	0x3e, r29	; 62
     42c:	cd bf       	out	0x3d, r28	; 61

0000042e <__do_copy_data>:
     42e:	11 e0       	ldi	r17, 0x01	; 1
     430:	a0 e0       	ldi	r26, 0x00	; 0
     432:	b1 e0       	ldi	r27, 0x01	; 1
     434:	e8 e4       	ldi	r30, 0x48	; 72
     436:	fe e2       	ldi	r31, 0x2E	; 46
     438:	00 e0       	ldi	r16, 0x00	; 0
     43a:	0b bf       	out	0x3b, r16	; 59
     43c:	02 c0       	rjmp	.+4      	; 0x442 <__do_copy_data+0x14>
     43e:	07 90       	elpm	r0, Z+
     440:	0d 92       	st	X+, r0
     442:	a8 3f       	cpi	r26, 0xF8	; 248
     444:	b1 07       	cpc	r27, r17
     446:	d9 f7       	brne	.-10     	; 0x43e <__do_copy_data+0x10>

00000448 <__do_clear_bss>:
     448:	14 e1       	ldi	r17, 0x14	; 20
     44a:	a8 ef       	ldi	r26, 0xF8	; 248
     44c:	b1 e0       	ldi	r27, 0x01	; 1
     44e:	01 c0       	rjmp	.+2      	; 0x452 <.do_clear_bss_start>

00000450 <.do_clear_bss_loop>:
     450:	1d 92       	st	X+, r1

00000452 <.do_clear_bss_start>:
     452:	ad 31       	cpi	r26, 0x1D	; 29
     454:	b1 07       	cpc	r27, r17
     456:	e1 f7       	brne	.-8      	; 0x450 <.do_clear_bss_loop>
     458:	6a d0       	rcall	.+212    	; 0x52e <main>
     45a:	0c 94 22 17 	jmp	0x2e44	; 0x2e44 <_exit>

0000045e <__bad_interrupt>:
     45e:	d0 cd       	rjmp	.-1120   	; 0x0 <__vectors>

00000460 <EVENT_USB_Device_Connect>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     460:	8b b1       	in	r24, 0x0b	; 11
     462:	8f 70       	andi	r24, 0x0F	; 15
     464:	80 6a       	ori	r24, 0xA0	; 160
     466:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     468:	08 95       	ret

0000046a <EVENT_USB_Device_Disconnect>:
     46a:	8b b1       	in	r24, 0x0b	; 11
     46c:	8f 70       	andi	r24, 0x0F	; 15
     46e:	80 61       	ori	r24, 0x10	; 16
     470:	8b b9       	out	0x0b, r24	; 11

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
}
     472:	08 95       	ret

00000474 <EVENT_USB_Device_ControlRequest>:
}

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface);
     474:	88 e1       	ldi	r24, 0x18	; 24
     476:	91 e0       	ldi	r25, 0x01	; 1
     478:	0c 94 df 13 	jmp	0x27be	; 0x27be <RNDIS_Device_ProcessControlRequest>

0000047c <EVENT_USB_Device_ConfigurationChanged>:
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface);
     47c:	88 e1       	ldi	r24, 0x18	; 24
     47e:	91 e0       	ldi	r25, 0x01	; 1
     480:	0e 94 8f 13 	call	0x271e	; 0x271e <RNDIS_Device_ConfigureEndpoints>

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     484:	80 fd       	sbrc	r24, 0
     486:	02 c0       	rjmp	.+4      	; 0x48c <EVENT_USB_Device_ConfigurationChanged+0x10>
     488:	90 e9       	ldi	r25, 0x90	; 144
     48a:	01 c0       	rjmp	.+2      	; 0x48e <EVENT_USB_Device_ConfigurationChanged+0x12>
     48c:	90 e6       	ldi	r25, 0x60	; 96
     48e:	8b b1       	in	r24, 0x0b	; 11
     490:	8f 70       	andi	r24, 0x0F	; 15
     492:	98 2b       	or	r25, r24
     494:	9b b9       	out	0x0b, r25	; 11
}
     496:	08 95       	ret

00000498 <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     498:	84 b7       	in	r24, 0x34	; 52
     49a:	87 7f       	andi	r24, 0xF7	; 247
     49c:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     49e:	38 e1       	ldi	r19, 0x18	; 24
     4a0:	0f b6       	in	r0, 0x3f	; 63
     4a2:	f8 94       	cli
     4a4:	30 93 60 00 	sts	0x0060, r19
     4a8:	10 92 60 00 	sts	0x0060, r1
     4ac:	0f be       	out	0x3f, r0	; 63

	/* Disable clock division */
	clock_prescale_set(clock_div_1);
     4ae:	80 e0       	ldi	r24, 0x00	; 0
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	20 e8       	ldi	r18, 0x80	; 128
     4b4:	0f b6       	in	r0, 0x3f	; 63
     4b6:	f8 94       	cli
     4b8:	20 93 61 00 	sts	0x0061, r18
     4bc:	80 93 61 00 	sts	0x0061, r24
     4c0:	0f be       	out	0x3f, r0	; 63

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     4c2:	8a b1       	in	r24, 0x0a	; 10
     4c4:	80 6f       	ori	r24, 0xF0	; 240
     4c6:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4c8:	8b b1       	in	r24, 0x0b	; 11
     4ca:	8f 70       	andi	r24, 0x0F	; 15
     4cc:	8b b9       	out	0x0b, r24	; 11
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
     4ce:	83 e3       	ldi	r24, 0x33	; 51
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	90 93 cd 00 	sts	0x00CD, r25
     4d6:	80 93 cc 00 	sts	0x00CC, r24

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
     4da:	86 e0       	ldi	r24, 0x06	; 6
     4dc:	80 93 ca 00 	sts	0x00CA, r24
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
     4e0:	10 92 c8 00 	sts	0x00C8, r1
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
     4e4:	30 93 c9 00 	sts	0x00C9, r19

				DDRD  |= (1 << 3);
     4e8:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
     4ea:	5a 9a       	sbi	0x0b, 2	; 11

	/* Hardware Initialization */
	LEDs_Init();
	Serial_Init(9600, false);
	USB_Init();
     4ec:	0e 94 5c 0e 	call	0x1cb8	; 0x1cb8 <USB_Init>
			static inline void Serial_CreateStream(FILE* Stream)
			{
				if (!(Stream))
				{
					Stream = &USARTSerialStream;
					stdin  = Stream;
     4f0:	e9 e0       	ldi	r30, 0x09	; 9
     4f2:	f4 e1       	ldi	r31, 0x14	; 20
     4f4:	f0 93 18 14 	sts	0x1418, r31
     4f8:	e0 93 17 14 	sts	0x1417, r30
					stdout = Stream;
     4fc:	f0 93 1a 14 	sts	0x141A, r31
     500:	e0 93 19 14 	sts	0x1419, r30
				}
			
				*Stream = (FILE)FDEV_SETUP_STREAM(Serial_putchar, Serial_getchar, _FDEV_SETUP_RW);
     504:	8e e0       	ldi	r24, 0x0E	; 14
     506:	df 01       	movw	r26, r30
     508:	1d 92       	st	X+, r1
     50a:	8a 95       	dec	r24
     50c:	e9 f7       	brne	.-6      	; 0x508 <SetupHardware+0x70>
     50e:	83 e0       	ldi	r24, 0x03	; 3
     510:	80 93 0c 14 	sts	0x140C, r24
     514:	87 ea       	ldi	r24, 0xA7	; 167
     516:	96 e1       	ldi	r25, 0x16	; 22
     518:	90 93 12 14 	sts	0x1412, r25
     51c:	80 93 11 14 	sts	0x1411, r24
     520:	81 eb       	ldi	r24, 0xB1	; 177
     522:	96 e1       	ldi	r25, 0x16	; 22
     524:	90 93 14 14 	sts	0x1414, r25
     528:	80 93 13 14 	sts	0x1413, r24

	/* Create a stdio stream for the serial port for stdin and stdout */
	Serial_CreateStream(NULL);
}
     52c:	08 95       	ret

0000052e <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
     52e:	b4 df       	rcall	.-152    	; 0x498 <SetupHardware>

	TCP_Init();
     530:	5e d1       	rcall	.+700    	; 0x7ee <TCP_Init>
	Webserver_Init();
     532:	0e 94 84 0d 	call	0x1b08	; 0x1b08 <Webserver_Init>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     536:	8b b1       	in	r24, 0x0b	; 11
     538:	8f 70       	andi	r24, 0x0F	; 15
     53a:	80 61       	ori	r24, 0x10	; 16
     53c:	8b b9       	out	0x0b, r24	; 11

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();
     53e:	78 94       	sei

	for (;;)
	{
		if (RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface))
     540:	88 e1       	ldi	r24, 0x18	; 24
     542:	91 e0       	ldi	r25, 0x01	; 1
     544:	0e 94 62 12 	call	0x24c4	; 0x24c4 <RNDIS_Device_IsPacketReceived>
     548:	88 23       	and	r24, r24
     54a:	31 f1       	breq	.+76     	; 0x598 <main+0x6a>
     54c:	8b b1       	in	r24, 0x0b	; 11
     54e:	8f 70       	andi	r24, 0x0F	; 15
     550:	80 62       	ori	r24, 0x20	; 32
     552:	8b b9       	out	0x0b, r24	; 11
		{
			LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
			
			RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface, &FrameIN.FrameData, &FrameIN.FrameLength);
     554:	88 e1       	ldi	r24, 0x18	; 24
     556:	91 e0       	ldi	r25, 0x01	; 1
     558:	68 ef       	ldi	r22, 0xF8	; 248
     55a:	71 e0       	ldi	r23, 0x01	; 1
     55c:	44 ed       	ldi	r20, 0xD4	; 212
     55e:	57 e0       	ldi	r21, 0x07	; 7
     560:	0e 94 32 13 	call	0x2664	; 0x2664 <RNDIS_Device_ReadPacket>
			Ethernet_ProcessPacket(&FrameIN, &FrameOUT);
     564:	88 ef       	ldi	r24, 0xF8	; 248
     566:	91 e0       	ldi	r25, 0x01	; 1
     568:	66 ed       	ldi	r22, 0xD6	; 214
     56a:	77 e0       	ldi	r23, 0x07	; 7
     56c:	81 d0       	rcall	.+258    	; 0x670 <Ethernet_ProcessPacket>
			
			if (FrameOUT.FrameLength)
     56e:	40 91 b2 0d 	lds	r20, 0x0DB2
     572:	50 91 b3 0d 	lds	r21, 0x0DB3
     576:	41 15       	cp	r20, r1
     578:	51 05       	cpc	r21, r1
     57a:	51 f0       	breq	.+20     	; 0x590 <main+0x62>
			{
				RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface, &FrameOUT.FrameData, FrameOUT.FrameLength);				
     57c:	88 e1       	ldi	r24, 0x18	; 24
     57e:	91 e0       	ldi	r25, 0x01	; 1
     580:	66 ed       	ldi	r22, 0xD6	; 214
     582:	77 e0       	ldi	r23, 0x07	; 7
     584:	0e 94 7c 12 	call	0x24f8	; 0x24f8 <RNDIS_Device_SendPacket>
				FrameOUT.FrameLength = 0;
     588:	10 92 b3 0d 	sts	0x0DB3, r1
     58c:	10 92 b2 0d 	sts	0x0DB2, r1
     590:	8b b1       	in	r24, 0x0b	; 11
     592:	8f 70       	andi	r24, 0x0F	; 15
     594:	80 66       	ori	r24, 0x60	; 96
     596:	8b b9       	out	0x0b, r24	; 11
			}
			
			LEDs_SetAllLEDs(LEDMASK_USB_READY);
		}

		TCP_TCPTask(&Ethernet_RNDIS_Interface, &FrameOUT);
     598:	88 e1       	ldi	r24, 0x18	; 24
     59a:	91 e0       	ldi	r25, 0x01	; 1
     59c:	66 ed       	ldi	r22, 0xD6	; 214
     59e:	77 e0       	ldi	r23, 0x07	; 7
     5a0:	26 d6       	rcall	.+3148   	; 0x11ee <TCP_TCPTask>

		RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface);
     5a2:	88 e1       	ldi	r24, 0x18	; 24
     5a4:	91 e0       	ldi	r25, 0x01	; 1
     5a6:	0e 94 ed 12 	call	0x25da	; 0x25da <RNDIS_Device_USBTask>
		USB_USBTask();
     5aa:	0e 94 4f 12 	call	0x249e	; 0x249e <USB_USBTask>
     5ae:	c8 cf       	rjmp	.-112    	; 0x540 <main+0x12>

000005b0 <CALLBACK_USB_GetDescriptor>:
 *  USB host.
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    const void** const DescriptorAddress)
{
     5b0:	da 01       	movw	r26, r20
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     5b2:	92 30       	cpi	r25, 0x02	; 2
     5b4:	49 f0       	breq	.+18     	; 0x5c8 <CALLBACK_USB_GetDescriptor+0x18>
     5b6:	93 30       	cpi	r25, 0x03	; 3
     5b8:	61 f0       	breq	.+24     	; 0x5d2 <CALLBACK_USB_GetDescriptor+0x22>
     5ba:	91 30       	cpi	r25, 0x01	; 1
     5bc:	f9 f4       	brne	.+62     	; 0x5fc <CALLBACK_USB_GetDescriptor+0x4c>
     5be:	e8 e9       	ldi	r30, 0x98	; 152
     5c0:	f0 e0       	ldi	r31, 0x00	; 0
     5c2:	22 e1       	ldi	r18, 0x12	; 18
     5c4:	30 e0       	ldi	r19, 0x00	; 0
     5c6:	1e c0       	rjmp	.+60     	; 0x604 <CALLBACK_USB_GetDescriptor+0x54>
     5c8:	ea ea       	ldi	r30, 0xAA	; 170
     5ca:	f0 e0       	ldi	r31, 0x00	; 0
     5cc:	2e e3       	ldi	r18, 0x3E	; 62
     5ce:	30 e0       	ldi	r19, 0x00	; 0
     5d0:	19 c0       	rjmp	.+50     	; 0x604 <CALLBACK_USB_GetDescriptor+0x54>
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
		case DTYPE_String:
			switch (DescriptorNumber)
     5d2:	81 30       	cpi	r24, 0x01	; 1
     5d4:	49 f0       	breq	.+18     	; 0x5e8 <CALLBACK_USB_GetDescriptor+0x38>
     5d6:	81 30       	cpi	r24, 0x01	; 1
     5d8:	18 f0       	brcs	.+6      	; 0x5e0 <CALLBACK_USB_GetDescriptor+0x30>
     5da:	82 30       	cpi	r24, 0x02	; 2
     5dc:	79 f4       	brne	.+30     	; 0x5fc <CALLBACK_USB_GetDescriptor+0x4c>
     5de:	08 c0       	rjmp	.+16     	; 0x5f0 <CALLBACK_USB_GetDescriptor+0x40>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     5e0:	e8 ee       	ldi	r30, 0xE8	; 232
     5e2:	f0 e0       	ldi	r31, 0x00	; 0
     5e4:	84 91       	lpm	r24, Z+
     5e6:	07 c0       	rjmp	.+14     	; 0x5f6 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     5e8:	ec ee       	ldi	r30, 0xEC	; 236
     5ea:	f0 e0       	ldi	r31, 0x00	; 0
     5ec:	84 91       	lpm	r24, Z+
     5ee:	03 c0       	rjmp	.+6      	; 0x5f6 <CALLBACK_USB_GetDescriptor+0x46>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     5f0:	e6 e0       	ldi	r30, 0x06	; 6
     5f2:	f1 e0       	ldi	r31, 0x01	; 1
     5f4:	84 91       	lpm	r24, Z+
     5f6:	28 2f       	mov	r18, r24
     5f8:	30 e0       	ldi	r19, 0x00	; 0
     5fa:	04 c0       	rjmp	.+8      	; 0x604 <CALLBACK_USB_GetDescriptor+0x54>
     5fc:	e0 e0       	ldi	r30, 0x00	; 0
     5fe:	f0 e0       	ldi	r31, 0x00	; 0
     600:	20 e0       	ldi	r18, 0x00	; 0
     602:	30 e0       	ldi	r19, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     604:	ed 93       	st	X+, r30
     606:	fc 93       	st	X, r31
	return Size;
}
     608:	c9 01       	movw	r24, r18
     60a:	08 95       	ret

0000060c <Ethernet_Checksum16>:
 *
 *  \return A 16-bit Ethernet checksum value
 */
uint16_t Ethernet_Checksum16(void* Data,
                             uint16_t Bytes)
{
     60c:	cf 93       	push	r28
     60e:	df 93       	push	r29
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     610:	76 95       	lsr	r23
     612:	67 95       	ror	r22
     614:	ec 01       	movw	r28, r24
     616:	20 e0       	ldi	r18, 0x00	; 0
     618:	30 e0       	ldi	r19, 0x00	; 0
     61a:	40 e0       	ldi	r20, 0x00	; 0
     61c:	50 e0       	ldi	r21, 0x00	; 0
     61e:	e0 e0       	ldi	r30, 0x00	; 0
     620:	f0 e0       	ldi	r31, 0x00	; 0
     622:	09 c0       	rjmp	.+18     	; 0x636 <Ethernet_Checksum16+0x2a>
	  Checksum += Words[CurrWord];
     624:	89 91       	ld	r24, Y+
     626:	99 91       	ld	r25, Y+
     628:	a0 e0       	ldi	r26, 0x00	; 0
     62a:	b0 e0       	ldi	r27, 0x00	; 0
     62c:	28 0f       	add	r18, r24
     62e:	39 1f       	adc	r19, r25
     630:	4a 1f       	adc	r20, r26
     632:	5b 1f       	adc	r21, r27
                             uint16_t Bytes)
{
	uint16_t* Words    = (uint16_t*)Data;
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
     634:	31 96       	adiw	r30, 0x01	; 1
     636:	e6 17       	cp	r30, r22
     638:	f7 07       	cpc	r31, r23
     63a:	a0 f3       	brcs	.-24     	; 0x624 <Ethernet_Checksum16+0x18>
     63c:	0b c0       	rjmp	.+22     	; 0x654 <Ethernet_Checksum16+0x48>
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     63e:	da 01       	movw	r26, r20
     640:	c9 01       	movw	r24, r18
     642:	a0 70       	andi	r26, 0x00	; 0
     644:	b0 70       	andi	r27, 0x00	; 0
     646:	9a 01       	movw	r18, r20
     648:	44 27       	eor	r20, r20
     64a:	55 27       	eor	r21, r21
     64c:	28 0f       	add	r18, r24
     64e:	39 1f       	adc	r19, r25
     650:	4a 1f       	adc	r20, r26
     652:	5b 1f       	adc	r21, r27
	uint32_t  Checksum = 0;

	for (uint16_t CurrWord = 0; CurrWord < (Bytes >> 1); CurrWord++)
	  Checksum += Words[CurrWord];

	while (Checksum & 0xFFFF0000)
     654:	da 01       	movw	r26, r20
     656:	c9 01       	movw	r24, r18
     658:	80 70       	andi	r24, 0x00	; 0
     65a:	90 70       	andi	r25, 0x00	; 0
     65c:	00 97       	sbiw	r24, 0x00	; 0
     65e:	a1 05       	cpc	r26, r1
     660:	b1 05       	cpc	r27, r1
     662:	69 f7       	brne	.-38     	; 0x63e <Ethernet_Checksum16+0x32>
     664:	20 95       	com	r18
     666:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     668:	c9 01       	movw	r24, r18
     66a:	df 91       	pop	r29
     66c:	cf 91       	pop	r28
     66e:	08 95       	ret

00000670 <Ethernet_ProcessPacket>:
/** Processes an incoming Ethernet frame, and writes the appropriate response to the output Ethernet
 *  frame buffer if the sub protocol handlers create a valid response.
 */
void Ethernet_ProcessPacket(Ethernet_Frame_Info_t* const FrameIN,
                            Ethernet_Frame_Info_t* const FrameOUT)
{
     670:	0f 93       	push	r16
     672:	1f 93       	push	r17
     674:	cf 93       	push	r28
     676:	df 93       	push	r29
     678:	ec 01       	movw	r28, r24
     67a:	8b 01       	movw	r16, r22
	DecodeEthernetFrameHeader(FrameIN->FrameData);
     67c:	6c d0       	rcall	.+216    	; 0x756 <DecodeEthernetFrameHeader>
	Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;

	int16_t                  RetSize        = NO_RESPONSE;

	/* Ensure frame is addressed to either all (broadcast) or the virtual webserver, and is a type II frame */
	if ((MAC_COMPARE(&FrameINHeader->Destination, &ServerMACAddress) ||
     67e:	ce 01       	movw	r24, r28
     680:	63 eb       	ldi	r22, 0xB3	; 179
     682:	71 e0       	ldi	r23, 0x01	; 1
     684:	46 e0       	ldi	r20, 0x06	; 6
     686:	50 e0       	ldi	r21, 0x00	; 0
     688:	0e 94 ed 16 	call	0x2dda	; 0x2dda <memcmp>
     68c:	00 97       	sbiw	r24, 0x00	; 0
     68e:	51 f0       	breq	.+20     	; 0x6a4 <Ethernet_ProcessPacket+0x34>
     690:	ce 01       	movw	r24, r28
     692:	6d eb       	ldi	r22, 0xBD	; 189
     694:	71 e0       	ldi	r23, 0x01	; 1
     696:	46 e0       	ldi	r20, 0x06	; 6
     698:	50 e0       	ldi	r21, 0x00	; 0
     69a:	0e 94 ed 16 	call	0x2dda	; 0x2dda <memcmp>
     69e:	00 97       	sbiw	r24, 0x00	; 0
     6a0:	09 f0       	breq	.+2      	; 0x6a4 <Ethernet_ProcessPacket+0x34>
     6a2:	50 c0       	rjmp	.+160    	; 0x744 <Ethernet_ProcessPacket+0xd4>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     6a4:	c4 52       	subi	r28, 0x24	; 36
     6a6:	da 4f       	sbci	r29, 0xFA	; 250
     6a8:	88 81       	ld	r24, Y
     6aa:	99 81       	ldd	r25, Y+1	; 0x01
     6ac:	cc 5d       	subi	r28, 0xDC	; 220
     6ae:	d5 40       	sbci	r29, 0x05	; 5

				Temp = Data.Bytes[0];
     6b0:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
     6b2:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
     6b4:	92 2f       	mov	r25, r18
     6b6:	81 50       	subi	r24, 0x01	; 1
     6b8:	96 40       	sbci	r25, 0x06	; 6
     6ba:	08 f4       	brcc	.+2      	; 0x6be <Ethernet_ProcessPacket+0x4e>
     6bc:	43 c0       	rjmp	.+134    	; 0x744 <Ethernet_ProcessPacket+0xd4>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     6be:	2c 85       	ldd	r18, Y+12	; 0x0c
     6c0:	3d 85       	ldd	r19, Y+13	; 0x0d

				Temp = Data.Bytes[0];
     6c2:	82 2f       	mov	r24, r18
				Data.Bytes[0] = Data.Bytes[1];
     6c4:	23 2f       	mov	r18, r19
				Data.Bytes[1] = Temp;
     6c6:	38 2f       	mov	r19, r24
	     MAC_COMPARE(&FrameINHeader->Destination, &BroadcastMACAddress)) &&
		 (SwapEndian_16(FrameIN->FrameLength) > ETHERNET_VER2_MINSIZE))
	{
		/* Process the packet depending on its protocol */
		switch (SwapEndian_16(FrameINHeader->EtherType))
     6c8:	88 e0       	ldi	r24, 0x08	; 8
     6ca:	20 30       	cpi	r18, 0x00	; 0
     6cc:	38 07       	cpc	r19, r24
     6ce:	59 f0       	breq	.+22     	; 0x6e6 <Ethernet_ProcessPacket+0x76>
     6d0:	26 50       	subi	r18, 0x06	; 6
     6d2:	38 40       	sbci	r19, 0x08	; 8
     6d4:	b9 f5       	brne	.+110    	; 0x744 <Ethernet_ProcessPacket+0xd4>
		{
			case ETHERTYPE_ARP:
				RetSize = ARP_ProcessARPPacket(&FrameIN->FrameData[sizeof(Ethernet_Frame_Header_t)],
     6d6:	b8 01       	movw	r22, r16
     6d8:	62 5f       	subi	r22, 0xF2	; 242
     6da:	7f 4f       	sbci	r23, 0xFF	; 255
     6dc:	ce 01       	movw	r24, r28
     6de:	0e 96       	adiw	r24, 0x0e	; 14
     6e0:	0e 94 95 0b 	call	0x172a	; 0x172a <ARP_ProcessARPPacket>
     6e4:	09 c0       	rjmp	.+18     	; 0x6f8 <Ethernet_ProcessPacket+0x88>
				                               &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
			case ETHERTYPE_IPV4:
				RetSize = IP_ProcessIPPacket(FrameIN,
     6e6:	be 01       	movw	r22, r28
     6e8:	62 5f       	subi	r22, 0xF2	; 242
     6ea:	7f 4f       	sbci	r23, 0xFF	; 255
     6ec:	a8 01       	movw	r20, r16
     6ee:	42 5f       	subi	r20, 0xF2	; 242
     6f0:	5f 4f       	sbci	r21, 0xFF	; 255
     6f2:	ce 01       	movw	r24, r28
     6f4:	0e 94 13 0c 	call	0x1826	; 0x1826 <IP_ProcessIPPacket>
     6f8:	9c 01       	movw	r18, r24
				                             &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)]);
				break;
		}

		/* Protocol processing routine has filled a response, complete the ethernet frame header */
		if (RetSize > 0)
     6fa:	18 16       	cp	r1, r24
     6fc:	19 06       	cpc	r1, r25
     6fe:	f4 f4       	brge	.+60     	; 0x73c <Ethernet_ProcessPacket+0xcc>
		{
			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
     700:	d8 01       	movw	r26, r16
     702:	16 96       	adiw	r26, 0x06	; 6
     704:	e3 eb       	ldi	r30, 0xB3	; 179
     706:	f1 e0       	ldi	r31, 0x01	; 1
     708:	86 e0       	ldi	r24, 0x06	; 6
     70a:	01 90       	ld	r0, Z+
     70c:	0d 92       	st	X+, r0
     70e:	81 50       	subi	r24, 0x01	; 1
     710:	e1 f7       	brne	.-8      	; 0x70a <Ethernet_ProcessPacket+0x9a>
			FrameOUTHeader->Destination     = FrameINHeader->Source;
     712:	d8 01       	movw	r26, r16
     714:	fe 01       	movw	r30, r28
     716:	36 96       	adiw	r30, 0x06	; 6
     718:	86 e0       	ldi	r24, 0x06	; 6
     71a:	01 90       	ld	r0, Z+
     71c:	0d 92       	st	X+, r0
     71e:	81 50       	subi	r24, 0x01	; 1
     720:	e1 f7       	brne	.-8      	; 0x71a <Ethernet_ProcessPacket+0xaa>
			FrameOUTHeader->EtherType       = FrameINHeader->EtherType;
     722:	8c 85       	ldd	r24, Y+12	; 0x0c
     724:	9d 85       	ldd	r25, Y+13	; 0x0d
     726:	f8 01       	movw	r30, r16
     728:	95 87       	std	Z+13, r25	; 0x0d
     72a:	84 87       	std	Z+12, r24	; 0x0c

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = (sizeof(Ethernet_Frame_Header_t) + RetSize);
     72c:	04 52       	subi	r16, 0x24	; 36
     72e:	1a 4f       	sbci	r17, 0xFA	; 250
     730:	22 5f       	subi	r18, 0xF2	; 242
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	f8 01       	movw	r30, r16
     736:	31 83       	std	Z+1, r19	; 0x01
     738:	20 83       	st	Z, r18
     73a:	04 c0       	rjmp	.+8      	; 0x744 <Ethernet_ProcessPacket+0xd4>
		}
	}

	/* Check if the packet was processed */
	if (RetSize != NO_PROCESS)
     73c:	ff ef       	ldi	r31, 0xFF	; 255
     73e:	8f 3f       	cpi	r24, 0xFF	; 255
     740:	9f 07       	cpc	r25, r31
     742:	21 f0       	breq	.+8      	; 0x74c <Ethernet_ProcessPacket+0xdc>
	{
		/* Clear the frame buffer */
		FrameIN->FrameLength = 0;
     744:	c4 52       	subi	r28, 0x24	; 36
     746:	da 4f       	sbci	r29, 0xFA	; 250
     748:	19 82       	std	Y+1, r1	; 0x01
     74a:	18 82       	st	Y, r1
	}
}
     74c:	df 91       	pop	r29
     74e:	cf 91       	pop	r28
     750:	1f 91       	pop	r17
     752:	0f 91       	pop	r16
     754:	08 95       	ret

00000756 <DecodeEthernetFrameHeader>:
	                                                                     FrameHeader->Destination.Octets[4],
	                                                                     FrameHeader->Destination.Octets[5]);

	printf_P(PSTR("  + Protocol: 0x%04x\r\n"), SwapEndian_16(FrameHeader->EtherType));
	#endif
}
     756:	08 95       	ret

00000758 <DecodeARPHeader>:
		                                                ARPHeader->TPA.Octets[1],
		                                                ARPHeader->TPA.Octets[2],
		                                                ARPHeader->TPA.Octets[3]);
	}
	#endif
}
     758:	08 95       	ret

0000075a <DecodeIPHeader>:
	printf_P(PSTR("    + IP Dst: %u.%u.%u.%u\r\n"), IPHeader->DestinationAddress.Octets[0],
	                                                IPHeader->DestinationAddress.Octets[1],
	                                                IPHeader->DestinationAddress.Octets[2],
	                                                IPHeader->DestinationAddress.Octets[3]);
	#endif
}
     75a:	08 95       	ret

0000075c <DecodeICMPHeader>:
	printf_P(PSTR("    \\\r\n     ICMP\r\n"));

	printf_P(PSTR("     + Type: %u\r\n"), ICMPHeader->Type);
	printf_P(PSTR("     + Code: %u\r\n"), ICMPHeader->Code);
	#endif
}
     75c:	08 95       	ret

0000075e <DecodeTCPHeader>:
	printf_P(PSTR("     + Flags: 0x%02X\r\n"), TCPHeader->Flags);

	if (TCP_GetPortState(TCPHeader->DestinationPort) == TCP_Port_Closed)
	  printf_P(PSTR("     + NOT LISTENING ON DESTINATION PORT\r\n"));
	#endif
}
     75e:	08 95       	ret

00000760 <DecodeUDPHeader>:
	printf_P(PSTR("     + Source Port: %u\r\n"), SwapEndian_16(UDPHeader->SourcePort));
	printf_P(PSTR("     + Destination Port: %u\r\n"), SwapEndian_16(UDPHeader->DestinationPort));

	printf_P(PSTR("     + Data Length: %d\r\n"), SwapEndian_16(UDPHeader->Length));
	#endif
}
     760:	08 95       	ret

00000762 <DecodeDHCPHeader>:

		DHCPOptions += ((DHCPOptions[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptions[1] + 2));
	}

	#endif
}
     762:	08 95       	ret

00000764 <ICMP_ProcessICMPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ICMP_ProcessICMPPacket(Ethernet_Frame_Info_t* const FrameIN,
                               void* InDataStart,
                               void* OutDataStart)
{
     764:	ef 92       	push	r14
     766:	ff 92       	push	r15
     768:	0f 93       	push	r16
     76a:	1f 93       	push	r17
     76c:	cf 93       	push	r28
     76e:	df 93       	push	r29
     770:	7c 01       	movw	r14, r24
     772:	8b 01       	movw	r16, r22
     774:	ea 01       	movw	r28, r20
	ICMP_Header_t* ICMPHeaderIN  = (ICMP_Header_t*)InDataStart;
	ICMP_Header_t* ICMPHeaderOUT = (ICMP_Header_t*)OutDataStart;

	DecodeICMPHeader(InDataStart);
     776:	cb 01       	movw	r24, r22
     778:	f1 df       	rcall	.-30     	; 0x75c <DecodeICMPHeader>

	/* Determine if the ICMP packet is an echo request (ping) */
	if (ICMPHeaderIN->Type == ICMP_TYPE_ECHOREQUEST)
     77a:	f8 01       	movw	r30, r16
     77c:	80 81       	ld	r24, Z
     77e:	88 30       	cpi	r24, 0x08	; 8
     780:	19 f0       	breq	.+6      	; 0x788 <ICMP_ProcessICMPPacket+0x24>
     782:	20 e0       	ldi	r18, 0x00	; 0
     784:	30 e0       	ldi	r19, 0x00	; 0
     786:	2b c0       	rjmp	.+86     	; 0x7de <ICMP_ProcessICMPPacket+0x7a>
	{
		/* Fill out the ICMP response packet */
		ICMPHeaderOUT->Type     = ICMP_TYPE_ECHOREPLY;
     788:	18 82       	st	Y, r1
		ICMPHeaderOUT->Code     = 0;
     78a:	19 82       	std	Y+1, r1	; 0x01
		ICMPHeaderOUT->Checksum = 0;
     78c:	1b 82       	std	Y+3, r1	; 0x03
     78e:	1a 82       	std	Y+2, r1	; 0x02
		ICMPHeaderOUT->Id       = ICMPHeaderIN->Id;
     790:	f8 01       	movw	r30, r16
     792:	84 81       	ldd	r24, Z+4	; 0x04
     794:	95 81       	ldd	r25, Z+5	; 0x05
     796:	9d 83       	std	Y+5, r25	; 0x05
     798:	8c 83       	std	Y+4, r24	; 0x04
		ICMPHeaderOUT->Sequence = ICMPHeaderIN->Sequence;
     79a:	86 81       	ldd	r24, Z+6	; 0x06
     79c:	97 81       	ldd	r25, Z+7	; 0x07
     79e:	9f 83       	std	Y+7, r25	; 0x07
     7a0:	8e 83       	std	Y+6, r24	; 0x06

		intptr_t DataSize = FrameIN->FrameLength - ((((intptr_t)InDataStart + sizeof(ICMP_Header_t)) - (intptr_t)FrameIN->FrameData));
     7a2:	b8 01       	movw	r22, r16
     7a4:	68 5f       	subi	r22, 0xF8	; 248
     7a6:	7f 4f       	sbci	r23, 0xFF	; 255
     7a8:	8c ed       	ldi	r24, 0xDC	; 220
     7aa:	95 e0       	ldi	r25, 0x05	; 5
     7ac:	e8 0e       	add	r14, r24
     7ae:	f9 1e       	adc	r15, r25
     7b0:	f7 01       	movw	r30, r14
     7b2:	80 81       	ld	r24, Z
     7b4:	91 81       	ldd	r25, Z+1	; 0x01
     7b6:	87 01       	movw	r16, r14
     7b8:	0c 5d       	subi	r16, 0xDC	; 220
     7ba:	15 40       	sbci	r17, 0x05	; 5
     7bc:	08 0f       	add	r16, r24
     7be:	19 1f       	adc	r17, r25
     7c0:	06 1b       	sub	r16, r22
     7c2:	17 0b       	sbc	r17, r23

		/* Copy the remaining payload to the response - echo requests should echo back any sent data */
		memmove(&((uint8_t*)OutDataStart)[sizeof(ICMP_Header_t)],
     7c4:	ce 01       	movw	r24, r28
     7c6:	08 96       	adiw	r24, 0x08	; 8
     7c8:	a8 01       	movw	r20, r16
     7ca:	0e 94 03 17 	call	0x2e06	; 0x2e06 <memmove>
		        &((uint8_t*)InDataStart)[sizeof(ICMP_Header_t)],
			    DataSize);

		ICMPHeaderOUT->Checksum = Ethernet_Checksum16(ICMPHeaderOUT, (DataSize + sizeof(ICMP_Header_t)));
     7ce:	08 5f       	subi	r16, 0xF8	; 248
     7d0:	1f 4f       	sbci	r17, 0xFF	; 255
     7d2:	ce 01       	movw	r24, r28
     7d4:	b8 01       	movw	r22, r16
     7d6:	1a df       	rcall	.-460    	; 0x60c <Ethernet_Checksum16>
     7d8:	9b 83       	std	Y+3, r25	; 0x03
     7da:	8a 83       	std	Y+2, r24	; 0x02

		/* Return the size of the response so far */
		return (DataSize + sizeof(ICMP_Header_t));
     7dc:	98 01       	movw	r18, r16
	}

	return NO_RESPONSE;
}
     7de:	c9 01       	movw	r24, r18
     7e0:	df 91       	pop	r29
     7e2:	cf 91       	pop	r28
     7e4:	1f 91       	pop	r17
     7e6:	0f 91       	pop	r16
     7e8:	ff 90       	pop	r15
     7ea:	ef 90       	pop	r14
     7ec:	08 95       	ret

000007ee <TCP_Init>:
 */
void TCP_Init(void)
{
	/* Initialize the port state table with all CLOSED entries */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	  PortStateTable[PTableEntry].State = TCP_Port_Closed;
     7ee:	10 92 f9 13 	sts	0x13F9, r1

	/* Initialize the connection table with all CLOSED entries */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	  ConnectionStateTable[CSTableEntry].State = TCP_Connection_Closed;
     7f2:	8a e0       	ldi	r24, 0x0A	; 10
     7f4:	80 93 ca 0f 	sts	0x0FCA, r24
     7f8:	80 93 e0 11 	sts	0x11E0, r24
     7fc:	80 93 f6 13 	sts	0x13F6, r24
}
     800:	08 95       	ret

00000802 <TCP_SetPortState>:
 *  \return Boolean true if the port state was set, false otherwise (no more space in the port state table)
 */
bool TCP_SetPortState(const uint16_t Port,
                      const uint8_t State,
                      void (*Handler)(TCP_ConnectionState_t*, TCP_ConnectionBuffer_t*))
{
     802:	9c 01       	movw	r18, r24

	/* Check to see if the port entry is already in the port state table */
	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, update it if found */
		if (PortStateTable[PTableEntry].Port == Port)
     804:	80 91 f7 13 	lds	r24, 0x13F7
     808:	90 91 f8 13 	lds	r25, 0x13F8
     80c:	82 17       	cp	r24, r18
     80e:	93 07       	cpc	r25, r19
     810:	39 f4       	brne	.+14     	; 0x820 <TCP_SetPortState+0x1e>
		{
			PortStateTable[PTableEntry].State = State;
     812:	60 93 f9 13 	sts	0x13F9, r22
			PortStateTable[PTableEntry].ApplicationHandler = Handler;
     816:	50 93 fb 13 	sts	0x13FB, r21
     81a:	40 93 fa 13 	sts	0x13FA, r20
     81e:	02 c0       	rjmp	.+4      	; 0x824 <TCP_SetPortState+0x22>
			return true;
		}
	}

	/* Check if trying to open the port -- if so we need to find an unused (closed) entry and replace it */
	if (State == TCP_Port_Open)
     820:	61 30       	cpi	r22, 0x01	; 1
     822:	11 f0       	breq	.+4      	; 0x828 <TCP_SetPortState+0x26>
     824:	81 e0       	ldi	r24, 0x01	; 1
     826:	08 95       	ret
	{
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Find a closed port entry in the table, change it to the given port and state */
			if (PortStateTable[PTableEntry].State == TCP_Port_Closed)
     828:	80 91 f9 13 	lds	r24, 0x13F9
     82c:	88 23       	and	r24, r24
     82e:	11 f0       	breq	.+4      	; 0x834 <TCP_SetPortState+0x32>
     830:	80 e0       	ldi	r24, 0x00	; 0
     832:	08 95       	ret
			{
				PortStateTable[PTableEntry].Port  = Port;
     834:	30 93 f8 13 	sts	0x13F8, r19
     838:	20 93 f7 13 	sts	0x13F7, r18
				PortStateTable[PTableEntry].State = State;
     83c:	60 93 f9 13 	sts	0x13F9, r22
				PortStateTable[PTableEntry].ApplicationHandler = Handler;
     840:	50 93 fb 13 	sts	0x13FB, r21
     844:	40 93 fa 13 	sts	0x13FA, r20
     848:	81 e0       	ldi	r24, 0x01	; 1
	else
	{
		/* Port not in table but trying to close it, so operation successful */
		return true;
	}
}
     84a:	08 95       	ret

0000084c <TCP_GetPortState>:
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
	{
		/* Find existing entry for the port in the table, return the port status if found */
		if (PortStateTable[PTableEntry].Port == Port)
     84c:	20 91 f7 13 	lds	r18, 0x13F7
     850:	30 91 f8 13 	lds	r19, 0x13F8
     854:	28 17       	cp	r18, r24
     856:	39 07       	cpc	r19, r25
     858:	11 f0       	breq	.+4      	; 0x85e <TCP_GetPortState+0x12>
     85a:	80 e0       	ldi	r24, 0x00	; 0
     85c:	08 95       	ret
		  return PortStateTable[PTableEntry].State;
     85e:	80 91 f9 13 	lds	r24, 0x13F9
	}

	/* Port not in table, assume closed */
	return TCP_Port_Closed;
}
     862:	08 95       	ret

00000864 <SwapEndian_32>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint32_t SwapEndian_32(const uint32_t DWord) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint32_t SwapEndian_32(const uint32_t DWord)
			{
     864:	36 2f       	mov	r19, r22
     866:	27 2f       	mov	r18, r23
				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
			}
     868:	69 2f       	mov	r22, r25
     86a:	78 2f       	mov	r23, r24
     86c:	c9 01       	movw	r24, r18
     86e:	08 95       	ret

00000870 <TCP_Checksum16>:
 */
static uint16_t TCP_Checksum16(void* TCPHeaderOutStart,
                               const IP_Address_t SourceAddress,
                               const IP_Address_t DestinationAddress,
                               const uint16_t TCPOutSize)
{
     870:	4f 92       	push	r4
     872:	5f 92       	push	r5
     874:	6f 92       	push	r6
     876:	7f 92       	push	r7
     878:	8f 92       	push	r8
     87a:	9f 92       	push	r9
     87c:	af 92       	push	r10
     87e:	bf 92       	push	r11
     880:	cf 92       	push	r12
     882:	df 92       	push	r13
     884:	ef 92       	push	r14
     886:	ff 92       	push	r15
     888:	0f 93       	push	r16
     88a:	1f 93       	push	r17
     88c:	df 93       	push	r29
     88e:	cf 93       	push	r28
     890:	cd b7       	in	r28, 0x3d	; 61
     892:	de b7       	in	r29, 0x3e	; 62
     894:	28 97       	sbiw	r28, 0x08	; 8
     896:	0f b6       	in	r0, 0x3f	; 63
     898:	f8 94       	cli
     89a:	de bf       	out	0x3e, r29	; 62
     89c:	0f be       	out	0x3f, r0	; 63
     89e:	cd bf       	out	0x3d, r28	; 61
     8a0:	2c 01       	movw	r4, r24
     8a2:	fa 01       	movw	r30, r20
     8a4:	49 83       	std	Y+1, r20	; 0x01
     8a6:	5a 83       	std	Y+2, r21	; 0x02
     8a8:	6b 83       	std	Y+3, r22	; 0x03
     8aa:	7c 83       	std	Y+4, r23	; 0x04
     8ac:	a8 01       	movw	r20, r16
     8ae:	0d 83       	std	Y+5, r16	; 0x05
     8b0:	1e 83       	std	Y+6, r17	; 0x06
     8b2:	2f 83       	std	Y+7, r18	; 0x07
     8b4:	38 87       	std	Y+8, r19	; 0x08
     8b6:	37 01       	movw	r6, r14

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     8b8:	0b 81       	ldd	r16, Y+3	; 0x03
     8ba:	1c 81       	ldd	r17, Y+4	; 0x04
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     8bc:	cf 80       	ldd	r12, Y+7	; 0x07
     8be:	d8 84       	ldd	r13, Y+8	; 0x08
				} Data;

				Data.Word = Word;

				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
     8c0:	87 2d       	mov	r24, r7
				Data.Bytes[1] = Temp;
     8c2:	9e 2d       	mov	r25, r14

	/* TCP/IP checksums are the addition of the one's compliment of each word including the IP pseudo-header,
	   complimented */

	Checksum += ((uint16_t*)&SourceAddress)[0];
	Checksum += ((uint16_t*)&SourceAddress)[1];
     8c4:	4f 01       	movw	r8, r30
     8c6:	aa 24       	eor	r10, r10
     8c8:	bb 24       	eor	r11, r11
     8ca:	60 e0       	ldi	r22, 0x00	; 0
     8cc:	70 e0       	ldi	r23, 0x00	; 0
     8ce:	84 0e       	add	r8, r20
     8d0:	95 1e       	adc	r9, r21
     8d2:	a6 1e       	adc	r10, r22
     8d4:	b7 1e       	adc	r11, r23
	Checksum += ((uint16_t*)&DestinationAddress)[0];
     8d6:	20 e0       	ldi	r18, 0x00	; 0
     8d8:	36 e0       	ldi	r19, 0x06	; 6
     8da:	40 e0       	ldi	r20, 0x00	; 0
     8dc:	50 e0       	ldi	r21, 0x00	; 0
     8de:	82 0e       	add	r8, r18
     8e0:	93 1e       	adc	r9, r19
     8e2:	a4 1e       	adc	r10, r20
     8e4:	b5 1e       	adc	r11, r21
	Checksum += ((uint16_t*)&DestinationAddress)[1];
     8e6:	20 e0       	ldi	r18, 0x00	; 0
     8e8:	30 e0       	ldi	r19, 0x00	; 0
     8ea:	80 0e       	add	r8, r16
     8ec:	91 1e       	adc	r9, r17
     8ee:	a2 1e       	adc	r10, r18
     8f0:	b3 1e       	adc	r11, r19
	Checksum += SwapEndian_16(PROTOCOL_TCP);
     8f2:	ee 24       	eor	r14, r14
     8f4:	ff 24       	eor	r15, r15
     8f6:	8c 0c       	add	r8, r12
     8f8:	9d 1c       	adc	r9, r13
     8fa:	ae 1c       	adc	r10, r14
     8fc:	bf 1c       	adc	r11, r15
	Checksum += SwapEndian_16(TCPOutSize);
     8fe:	a0 e0       	ldi	r26, 0x00	; 0
     900:	b0 e0       	ldi	r27, 0x00	; 0
     902:	88 0e       	add	r8, r24
     904:	99 1e       	adc	r9, r25
     906:	aa 1e       	adc	r10, r26
     908:	bb 1e       	adc	r11, r27

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     90a:	f3 01       	movw	r30, r6
     90c:	f6 95       	lsr	r31
     90e:	e7 95       	ror	r30
     910:	a2 01       	movw	r20, r4
     912:	20 e0       	ldi	r18, 0x00	; 0
     914:	30 e0       	ldi	r19, 0x00	; 0
     916:	0c c0       	rjmp	.+24     	; 0x930 <TCP_Checksum16+0xc0>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];
     918:	da 01       	movw	r26, r20
     91a:	8d 91       	ld	r24, X+
     91c:	9d 91       	ld	r25, X+
     91e:	ad 01       	movw	r20, r26
     920:	a0 e0       	ldi	r26, 0x00	; 0
     922:	b0 e0       	ldi	r27, 0x00	; 0
     924:	88 0e       	add	r8, r24
     926:	99 1e       	adc	r9, r25
     928:	aa 1e       	adc	r10, r26
     92a:	bb 1e       	adc	r11, r27
	Checksum += ((uint16_t*)&DestinationAddress)[0];
	Checksum += ((uint16_t*)&DestinationAddress)[1];
	Checksum += SwapEndian_16(PROTOCOL_TCP);
	Checksum += SwapEndian_16(TCPOutSize);

	for (uint16_t CurrWord = 0; CurrWord < (TCPOutSize >> 1); CurrWord++)
     92c:	2f 5f       	subi	r18, 0xFF	; 255
     92e:	3f 4f       	sbci	r19, 0xFF	; 255
     930:	2e 17       	cp	r18, r30
     932:	3f 07       	cpc	r19, r31
     934:	88 f3       	brcs	.-30     	; 0x918 <TCP_Checksum16+0xa8>
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
     936:	60 fe       	sbrs	r6, 0
     938:	15 c0       	rjmp	.+42     	; 0x964 <TCP_Checksum16+0xf4>
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);
     93a:	ee 0f       	add	r30, r30
     93c:	ff 1f       	adc	r31, r31
     93e:	e4 0d       	add	r30, r4
     940:	f5 1d       	adc	r31, r5
     942:	80 81       	ld	r24, Z
     944:	88 0e       	add	r8, r24
     946:	91 1c       	adc	r9, r1
     948:	a1 1c       	adc	r10, r1
     94a:	b1 1c       	adc	r11, r1
     94c:	0b c0       	rjmp	.+22     	; 0x964 <TCP_Checksum16+0xf4>

	while (Checksum & 0xFFFF0000)
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));
     94e:	d5 01       	movw	r26, r10
     950:	c4 01       	movw	r24, r8
     952:	a0 70       	andi	r26, 0x00	; 0
     954:	b0 70       	andi	r27, 0x00	; 0
     956:	45 01       	movw	r8, r10
     958:	aa 24       	eor	r10, r10
     95a:	bb 24       	eor	r11, r11
     95c:	88 0e       	add	r8, r24
     95e:	99 1e       	adc	r9, r25
     960:	aa 1e       	adc	r10, r26
     962:	bb 1e       	adc	r11, r27
	  Checksum += ((uint16_t*)TCPHeaderOutStart)[CurrWord];

	if (TCPOutSize & 0x01)
	  Checksum += (((uint16_t*)TCPHeaderOutStart)[TCPOutSize >> 1] & 0x00FF);

	while (Checksum & 0xFFFF0000)
     964:	d5 01       	movw	r26, r10
     966:	c4 01       	movw	r24, r8
     968:	80 70       	andi	r24, 0x00	; 0
     96a:	90 70       	andi	r25, 0x00	; 0
     96c:	00 97       	sbiw	r24, 0x00	; 0
     96e:	a1 05       	cpc	r26, r1
     970:	b1 05       	cpc	r27, r1
     972:	69 f7       	brne	.-38     	; 0x94e <TCP_Checksum16+0xde>
     974:	94 01       	movw	r18, r8
     976:	20 95       	com	r18
     978:	30 95       	com	r19
	  Checksum = ((Checksum & 0xFFFF) + (Checksum >> 16));

	return ~Checksum;
}
     97a:	c9 01       	movw	r24, r18
     97c:	28 96       	adiw	r28, 0x08	; 8
     97e:	0f b6       	in	r0, 0x3f	; 63
     980:	f8 94       	cli
     982:	de bf       	out	0x3e, r29	; 62
     984:	0f be       	out	0x3f, r0	; 63
     986:	cd bf       	out	0x3d, r28	; 61
     988:	cf 91       	pop	r28
     98a:	df 91       	pop	r29
     98c:	1f 91       	pop	r17
     98e:	0f 91       	pop	r16
     990:	ff 90       	pop	r15
     992:	ef 90       	pop	r14
     994:	df 90       	pop	r13
     996:	cf 90       	pop	r12
     998:	bf 90       	pop	r11
     99a:	af 90       	pop	r10
     99c:	9f 90       	pop	r9
     99e:	8f 90       	pop	r8
     9a0:	7f 90       	pop	r7
     9a2:	6f 90       	pop	r6
     9a4:	5f 90       	pop	r5
     9a6:	4f 90       	pop	r4
     9a8:	08 95       	ret

000009aa <TCP_GetConnectionInfo>:
 *  \return ConnectionInfo structure of the connection if found, NULL otherwise
 */
TCP_ConnectionInfo_t* TCP_GetConnectionInfo(const uint16_t Port,
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
     9aa:	4f 92       	push	r4
     9ac:	5f 92       	push	r5
     9ae:	6f 92       	push	r6
     9b0:	7f 92       	push	r7
     9b2:	8f 92       	push	r8
     9b4:	9f 92       	push	r9
     9b6:	af 92       	push	r10
     9b8:	bf 92       	push	r11
     9ba:	cf 92       	push	r12
     9bc:	df 92       	push	r13
     9be:	ef 92       	push	r14
     9c0:	ff 92       	push	r15
     9c2:	0f 93       	push	r16
     9c4:	1f 93       	push	r17
     9c6:	df 93       	push	r29
     9c8:	cf 93       	push	r28
     9ca:	00 d0       	rcall	.+0      	; 0x9cc <TCP_GetConnectionInfo+0x22>
     9cc:	00 d0       	rcall	.+0      	; 0x9ce <TCP_GetConnectionInfo+0x24>
     9ce:	cd b7       	in	r28, 0x3d	; 61
     9d0:	de b7       	in	r29, 0x3e	; 62
     9d2:	4c 01       	movw	r8, r24
     9d4:	49 83       	std	Y+1, r20	; 0x01
     9d6:	5a 83       	std	Y+2, r21	; 0x02
     9d8:	6b 83       	std	Y+3, r22	; 0x03
     9da:	7c 83       	std	Y+4, r23	; 0x04
     9dc:	59 01       	movw	r10, r18
     9de:	65 eb       	ldi	r22, 0xB5	; 181
     9e0:	e6 2e       	mov	r14, r22
     9e2:	6d e0       	ldi	r22, 0x0D	; 13
     9e4:	f6 2e       	mov	r15, r22
     9e6:	00 e0       	ldi	r16, 0x00	; 0
     9e8:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     9ea:	56 e1       	ldi	r21, 0x16	; 22
     9ec:	45 2e       	mov	r4, r21
     9ee:	52 e0       	ldi	r21, 0x02	; 2
     9f0:	55 2e       	mov	r5, r21
     9f2:	3e 01       	movw	r6, r28
     9f4:	08 94       	sec
     9f6:	61 1c       	adc	r6, r1
     9f8:	71 1c       	adc	r7, r1
     9fa:	f7 01       	movw	r30, r14
     9fc:	80 81       	ld	r24, Z
     9fe:	91 81       	ldd	r25, Z+1	; 0x01
     a00:	88 15       	cp	r24, r8
     a02:	99 05       	cpc	r25, r9
     a04:	d9 f4       	brne	.+54     	; 0xa3c <TCP_GetConnectionInfo+0x92>
     a06:	04 9d       	mul	r16, r4
     a08:	60 01       	movw	r12, r0
     a0a:	05 9d       	mul	r16, r5
     a0c:	d0 0c       	add	r13, r0
     a0e:	14 9d       	mul	r17, r4
     a10:	d0 0c       	add	r13, r0
     a12:	11 24       	eor	r1, r1
     a14:	c6 01       	movw	r24, r12
     a16:	87 54       	subi	r24, 0x47	; 71
     a18:	92 4f       	sbci	r25, 0xF2	; 242
     a1a:	b3 01       	movw	r22, r6
     a1c:	44 e0       	ldi	r20, 0x04	; 4
     a1e:	50 e0       	ldi	r21, 0x00	; 0
     a20:	0e 94 ed 16 	call	0x2dda	; 0x2dda <memcmp>
     a24:	00 97       	sbiw	r24, 0x00	; 0
     a26:	51 f4       	brne	.+20     	; 0xa3c <TCP_GetConnectionInfo+0x92>
     a28:	f7 01       	movw	r30, r14
     a2a:	82 81       	ldd	r24, Z+2	; 0x02
     a2c:	93 81       	ldd	r25, Z+3	; 0x03
     a2e:	8a 15       	cp	r24, r10
     a30:	9b 05       	cpc	r25, r11
     a32:	21 f4       	brne	.+8      	; 0xa3c <TCP_GetConnectionInfo+0x92>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			return &ConnectionStateTable[CSTableEntry].Info;
     a34:	96 01       	movw	r18, r12
     a36:	23 54       	subi	r18, 0x43	; 67
     a38:	32 4f       	sbci	r19, 0xF2	; 242
     a3a:	0b c0       	rjmp	.+22     	; 0xa52 <TCP_GetConnectionInfo+0xa8>
     a3c:	0f 5f       	subi	r16, 0xFF	; 255
     a3e:	1f 4f       	sbci	r17, 0xFF	; 255
     a40:	86 e1       	ldi	r24, 0x16	; 22
     a42:	92 e0       	ldi	r25, 0x02	; 2
     a44:	e8 0e       	add	r14, r24
     a46:	f9 1e       	adc	r15, r25
                                            const IP_Address_t RemoteAddress,
                                            const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     a48:	03 30       	cpi	r16, 0x03	; 3
     a4a:	11 05       	cpc	r17, r1
     a4c:	b1 f6       	brne	.-84     	; 0x9fa <TCP_GetConnectionInfo+0x50>
     a4e:	20 e0       	ldi	r18, 0x00	; 0
     a50:	30 e0       	ldi	r19, 0x00	; 0
			return &ConnectionStateTable[CSTableEntry].Info;
		}
	}

	return NULL;
}
     a52:	c9 01       	movw	r24, r18
     a54:	0f 90       	pop	r0
     a56:	0f 90       	pop	r0
     a58:	0f 90       	pop	r0
     a5a:	0f 90       	pop	r0
     a5c:	cf 91       	pop	r28
     a5e:	df 91       	pop	r29
     a60:	1f 91       	pop	r17
     a62:	0f 91       	pop	r16
     a64:	ff 90       	pop	r15
     a66:	ef 90       	pop	r14
     a68:	df 90       	pop	r13
     a6a:	cf 90       	pop	r12
     a6c:	bf 90       	pop	r11
     a6e:	af 90       	pop	r10
     a70:	9f 90       	pop	r9
     a72:	8f 90       	pop	r8
     a74:	7f 90       	pop	r7
     a76:	6f 90       	pop	r6
     a78:	5f 90       	pop	r5
     a7a:	4f 90       	pop	r4
     a7c:	08 95       	ret

00000a7e <TCP_GetConnectionState>:
 *  \return A value from the \ref TCP_ConnectionStates_t enum
 */
uint8_t TCP_GetConnectionState(const uint16_t Port,
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
     a7e:	4f 92       	push	r4
     a80:	5f 92       	push	r5
     a82:	6f 92       	push	r6
     a84:	7f 92       	push	r7
     a86:	8f 92       	push	r8
     a88:	9f 92       	push	r9
     a8a:	af 92       	push	r10
     a8c:	bf 92       	push	r11
     a8e:	cf 92       	push	r12
     a90:	df 92       	push	r13
     a92:	ef 92       	push	r14
     a94:	ff 92       	push	r15
     a96:	0f 93       	push	r16
     a98:	1f 93       	push	r17
     a9a:	df 93       	push	r29
     a9c:	cf 93       	push	r28
     a9e:	00 d0       	rcall	.+0      	; 0xaa0 <TCP_GetConnectionState+0x22>
     aa0:	00 d0       	rcall	.+0      	; 0xaa2 <TCP_GetConnectionState+0x24>
     aa2:	cd b7       	in	r28, 0x3d	; 61
     aa4:	de b7       	in	r29, 0x3e	; 62
     aa6:	4c 01       	movw	r8, r24
     aa8:	49 83       	std	Y+1, r20	; 0x01
     aaa:	5a 83       	std	Y+2, r21	; 0x02
     aac:	6b 83       	std	Y+3, r22	; 0x03
     aae:	7c 83       	std	Y+4, r23	; 0x04
     ab0:	59 01       	movw	r10, r18
     ab2:	e5 eb       	ldi	r30, 0xB5	; 181
     ab4:	ee 2e       	mov	r14, r30
     ab6:	ed e0       	ldi	r30, 0x0D	; 13
     ab8:	fe 2e       	mov	r15, r30
     aba:	00 e0       	ldi	r16, 0x00	; 0
     abc:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     abe:	76 e1       	ldi	r23, 0x16	; 22
     ac0:	47 2e       	mov	r4, r23
     ac2:	72 e0       	ldi	r23, 0x02	; 2
     ac4:	57 2e       	mov	r5, r23
     ac6:	3e 01       	movw	r6, r28
     ac8:	08 94       	sec
     aca:	61 1c       	adc	r6, r1
     acc:	71 1c       	adc	r7, r1
     ace:	f7 01       	movw	r30, r14
     ad0:	80 81       	ld	r24, Z
     ad2:	91 81       	ldd	r25, Z+1	; 0x01
     ad4:	88 15       	cp	r24, r8
     ad6:	99 05       	cpc	r25, r9
     ad8:	e1 f4       	brne	.+56     	; 0xb12 <TCP_GetConnectionState+0x94>
     ada:	04 9d       	mul	r16, r4
     adc:	60 01       	movw	r12, r0
     ade:	05 9d       	mul	r16, r5
     ae0:	d0 0c       	add	r13, r0
     ae2:	14 9d       	mul	r17, r4
     ae4:	d0 0c       	add	r13, r0
     ae6:	11 24       	eor	r1, r1
     ae8:	c6 01       	movw	r24, r12
     aea:	87 54       	subi	r24, 0x47	; 71
     aec:	92 4f       	sbci	r25, 0xF2	; 242
     aee:	b3 01       	movw	r22, r6
     af0:	44 e0       	ldi	r20, 0x04	; 4
     af2:	50 e0       	ldi	r21, 0x00	; 0
     af4:	0e 94 ed 16 	call	0x2dda	; 0x2dda <memcmp>
     af8:	00 97       	sbiw	r24, 0x00	; 0
     afa:	59 f4       	brne	.+22     	; 0xb12 <TCP_GetConnectionState+0x94>
     afc:	f7 01       	movw	r30, r14
     afe:	82 81       	ldd	r24, Z+2	; 0x02
     b00:	93 81       	ldd	r25, Z+3	; 0x03
     b02:	8a 15       	cp	r24, r10
     b04:	9b 05       	cpc	r25, r11
     b06:	29 f4       	brne	.+10     	; 0xb12 <TCP_GetConnectionState+0x94>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)

		{
			return ConnectionStateTable[CSTableEntry].State;
     b08:	f6 01       	movw	r30, r12
     b0a:	e6 53       	subi	r30, 0x36	; 54
     b0c:	f0 4f       	sbci	r31, 0xF0	; 240
     b0e:	80 81       	ld	r24, Z
     b10:	0a c0       	rjmp	.+20     	; 0xb26 <TCP_GetConnectionState+0xa8>
     b12:	0f 5f       	subi	r16, 0xFF	; 255
     b14:	1f 4f       	sbci	r17, 0xFF	; 255
     b16:	86 e1       	ldi	r24, 0x16	; 22
     b18:	92 e0       	ldi	r25, 0x02	; 2
     b1a:	e8 0e       	add	r14, r24
     b1c:	f9 1e       	adc	r15, r25
                               const IP_Address_t RemoteAddress,
                               const uint16_t RemotePort)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     b1e:	03 30       	cpi	r16, 0x03	; 3
     b20:	11 05       	cpc	r17, r1
     b22:	a9 f6       	brne	.-86     	; 0xace <TCP_GetConnectionState+0x50>
     b24:	8a e0       	ldi	r24, 0x0A	; 10
			return ConnectionStateTable[CSTableEntry].State;
		}
	}

	return TCP_Connection_Closed;
}
     b26:	0f 90       	pop	r0
     b28:	0f 90       	pop	r0
     b2a:	0f 90       	pop	r0
     b2c:	0f 90       	pop	r0
     b2e:	cf 91       	pop	r28
     b30:	df 91       	pop	r29
     b32:	1f 91       	pop	r17
     b34:	0f 91       	pop	r16
     b36:	ff 90       	pop	r15
     b38:	ef 90       	pop	r14
     b3a:	df 90       	pop	r13
     b3c:	cf 90       	pop	r12
     b3e:	bf 90       	pop	r11
     b40:	af 90       	pop	r10
     b42:	9f 90       	pop	r9
     b44:	8f 90       	pop	r8
     b46:	7f 90       	pop	r7
     b48:	6f 90       	pop	r6
     b4a:	5f 90       	pop	r5
     b4c:	4f 90       	pop	r4
     b4e:	08 95       	ret

00000b50 <TCP_SetConnectionState>:
 */
bool TCP_SetConnectionState(const uint16_t Port,
                            const IP_Address_t RemoteAddress,
                            const uint16_t RemotePort,
                            const uint8_t State)
{
     b50:	3f 92       	push	r3
     b52:	4f 92       	push	r4
     b54:	5f 92       	push	r5
     b56:	6f 92       	push	r6
     b58:	7f 92       	push	r7
     b5a:	8f 92       	push	r8
     b5c:	9f 92       	push	r9
     b5e:	af 92       	push	r10
     b60:	bf 92       	push	r11
     b62:	cf 92       	push	r12
     b64:	df 92       	push	r13
     b66:	ef 92       	push	r14
     b68:	ff 92       	push	r15
     b6a:	0f 93       	push	r16
     b6c:	1f 93       	push	r17
     b6e:	df 93       	push	r29
     b70:	cf 93       	push	r28
     b72:	00 d0       	rcall	.+0      	; 0xb74 <TCP_SetConnectionState+0x24>
     b74:	00 d0       	rcall	.+0      	; 0xb76 <TCP_SetConnectionState+0x26>
     b76:	cd b7       	in	r28, 0x3d	; 61
     b78:	de b7       	in	r29, 0x3e	; 62
     b7a:	5c 01       	movw	r10, r24
     b7c:	49 83       	std	Y+1, r20	; 0x01
     b7e:	5a 83       	std	Y+2, r21	; 0x02
     b80:	6b 83       	std	Y+3, r22	; 0x03
     b82:	7c 83       	std	Y+4, r23	; 0x04
     b84:	49 01       	movw	r8, r18
     b86:	30 2e       	mov	r3, r16
     b88:	15 eb       	ldi	r17, 0xB5	; 181
     b8a:	e1 2e       	mov	r14, r17
     b8c:	1d e0       	ldi	r17, 0x0D	; 13
     b8e:	f1 2e       	mov	r15, r17
     b90:	00 e0       	ldi	r16, 0x00	; 0
     b92:	10 e0       	ldi	r17, 0x00	; 0
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find port entry in the table */
		if ((ConnectionStateTable[CSTableEntry].Port == Port) &&
     b94:	b6 e1       	ldi	r27, 0x16	; 22
     b96:	4b 2e       	mov	r4, r27
     b98:	b2 e0       	ldi	r27, 0x02	; 2
     b9a:	5b 2e       	mov	r5, r27
     b9c:	3e 01       	movw	r6, r28
     b9e:	08 94       	sec
     ba0:	61 1c       	adc	r6, r1
     ba2:	71 1c       	adc	r7, r1
     ba4:	f7 01       	movw	r30, r14
     ba6:	80 81       	ld	r24, Z
     ba8:	91 81       	ldd	r25, Z+1	; 0x01
     baa:	8a 15       	cp	r24, r10
     bac:	9b 05       	cpc	r25, r11
     bae:	d9 f4       	brne	.+54     	; 0xbe6 <TCP_SetConnectionState+0x96>
     bb0:	04 9d       	mul	r16, r4
     bb2:	60 01       	movw	r12, r0
     bb4:	05 9d       	mul	r16, r5
     bb6:	d0 0c       	add	r13, r0
     bb8:	14 9d       	mul	r17, r4
     bba:	d0 0c       	add	r13, r0
     bbc:	11 24       	eor	r1, r1
     bbe:	c6 01       	movw	r24, r12
     bc0:	87 54       	subi	r24, 0x47	; 71
     bc2:	92 4f       	sbci	r25, 0xF2	; 242
     bc4:	b3 01       	movw	r22, r6
     bc6:	44 e0       	ldi	r20, 0x04	; 4
     bc8:	50 e0       	ldi	r21, 0x00	; 0
     bca:	0e 94 ed 16 	call	0x2dda	; 0x2dda <memcmp>
     bce:	00 97       	sbiw	r24, 0x00	; 0
     bd0:	51 f4       	brne	.+20     	; 0xbe6 <TCP_SetConnectionState+0x96>
     bd2:	f7 01       	movw	r30, r14
     bd4:	82 81       	ldd	r24, Z+2	; 0x02
     bd6:	93 81       	ldd	r25, Z+3	; 0x03
     bd8:	88 15       	cp	r24, r8
     bda:	99 05       	cpc	r25, r9
     bdc:	21 f4       	brne	.+8      	; 0xbe6 <TCP_SetConnectionState+0x96>
		     IP_COMPARE(&ConnectionStateTable[CSTableEntry].RemoteAddress, &RemoteAddress) &&
			 ConnectionStateTable[CSTableEntry].RemotePort == RemotePort)
		{
			ConnectionStateTable[CSTableEntry].State = State;
     bde:	f6 01       	movw	r30, r12
     be0:	e6 53       	subi	r30, 0x36	; 54
     be2:	f0 4f       	sbci	r31, 0xF0	; 240
     be4:	47 c0       	rjmp	.+142    	; 0xc74 <TCP_SetConnectionState+0x124>
			return true;
     be6:	0f 5f       	subi	r16, 0xFF	; 255
     be8:	1f 4f       	sbci	r17, 0xFF	; 255
     bea:	86 e1       	ldi	r24, 0x16	; 22
     bec:	92 e0       	ldi	r25, 0x02	; 2
     bee:	e8 0e       	add	r14, r24
     bf0:	f9 1e       	adc	r15, r25
                            const uint16_t RemotePort,
                            const uint8_t State)
{
	/* Note, Port number should be specified in BIG endian to simplify network code */

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
     bf2:	03 30       	cpi	r16, 0x03	; 3
     bf4:	11 05       	cpc	r17, r1
     bf6:	b1 f6       	brne	.-84     	; 0xba4 <TCP_SetConnectionState+0x54>
	}

	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* Find empty entry in the table */
		if (ConnectionStateTable[CSTableEntry].State == TCP_Connection_Closed)
     bf8:	80 91 ca 0f 	lds	r24, 0x0FCA
     bfc:	8a 30       	cpi	r24, 0x0A	; 10
     bfe:	19 f4       	brne	.+6      	; 0xc06 <TCP_SetConnectionState+0xb6>
     c00:	40 e0       	ldi	r20, 0x00	; 0
     c02:	50 e0       	ldi	r21, 0x00	; 0
     c04:	0f c0       	rjmp	.+30     	; 0xc24 <TCP_SetConnectionState+0xd4>
     c06:	80 91 e0 11 	lds	r24, 0x11E0
     c0a:	8a 30       	cpi	r24, 0x0A	; 10
     c0c:	19 f4       	brne	.+6      	; 0xc14 <TCP_SetConnectionState+0xc4>
     c0e:	41 e0       	ldi	r20, 0x01	; 1
     c10:	50 e0       	ldi	r21, 0x00	; 0
     c12:	08 c0       	rjmp	.+16     	; 0xc24 <TCP_SetConnectionState+0xd4>
     c14:	80 91 f6 13 	lds	r24, 0x13F6
     c18:	8a 30       	cpi	r24, 0x0A	; 10
     c1a:	11 f0       	breq	.+4      	; 0xc20 <TCP_SetConnectionState+0xd0>
     c1c:	80 e0       	ldi	r24, 0x00	; 0
     c1e:	2c c0       	rjmp	.+88     	; 0xc78 <TCP_SetConnectionState+0x128>
     c20:	42 e0       	ldi	r20, 0x02	; 2
     c22:	50 e0       	ldi	r21, 0x00	; 0
		{
			ConnectionStateTable[CSTableEntry].Port          = Port;
     c24:	86 e1       	ldi	r24, 0x16	; 22
     c26:	92 e0       	ldi	r25, 0x02	; 2
     c28:	48 9f       	mul	r20, r24
     c2a:	90 01       	movw	r18, r0
     c2c:	49 9f       	mul	r20, r25
     c2e:	30 0d       	add	r19, r0
     c30:	58 9f       	mul	r21, r24
     c32:	30 0d       	add	r19, r0
     c34:	11 24       	eor	r1, r1
     c36:	2b 54       	subi	r18, 0x4B	; 75
     c38:	32 4f       	sbci	r19, 0xF2	; 242
     c3a:	f9 01       	movw	r30, r18
     c3c:	b1 82       	std	Z+1, r11	; 0x01
     c3e:	a0 82       	st	Z, r10
			ConnectionStateTable[CSTableEntry].RemoteAddress = RemoteAddress;
     c40:	89 81       	ldd	r24, Y+1	; 0x01
     c42:	9a 81       	ldd	r25, Y+2	; 0x02
     c44:	ab 81       	ldd	r26, Y+3	; 0x03
     c46:	bc 81       	ldd	r27, Y+4	; 0x04
     c48:	84 83       	std	Z+4, r24	; 0x04
     c4a:	95 83       	std	Z+5, r25	; 0x05
     c4c:	a6 83       	std	Z+6, r26	; 0x06
     c4e:	b7 83       	std	Z+7, r27	; 0x07
			ConnectionStateTable[CSTableEntry].RemotePort    = RemotePort;
     c50:	8b e0       	ldi	r24, 0x0B	; 11
     c52:	91 e0       	ldi	r25, 0x01	; 1
     c54:	48 9f       	mul	r20, r24
     c56:	f0 01       	movw	r30, r0
     c58:	49 9f       	mul	r20, r25
     c5a:	f0 0d       	add	r31, r0
     c5c:	58 9f       	mul	r21, r24
     c5e:	f0 0d       	add	r31, r0
     c60:	11 24       	eor	r1, r1
     c62:	ee 0f       	add	r30, r30
     c64:	ff 1f       	adc	r31, r31
     c66:	e9 54       	subi	r30, 0x49	; 73
     c68:	f2 4f       	sbci	r31, 0xF2	; 242
     c6a:	91 82       	std	Z+1, r9	; 0x01
     c6c:	80 82       	st	Z, r8
			ConnectionStateTable[CSTableEntry].State         = State;
     c6e:	2b 5e       	subi	r18, 0xEB	; 235
     c70:	3d 4f       	sbci	r19, 0xFD	; 253
     c72:	f9 01       	movw	r30, r18
     c74:	30 82       	st	Z, r3
     c76:	81 e0       	ldi	r24, 0x01	; 1
			return true;
		}
	}

	return false;
}
     c78:	0f 90       	pop	r0
     c7a:	0f 90       	pop	r0
     c7c:	0f 90       	pop	r0
     c7e:	0f 90       	pop	r0
     c80:	cf 91       	pop	r28
     c82:	df 91       	pop	r29
     c84:	1f 91       	pop	r17
     c86:	0f 91       	pop	r16
     c88:	ff 90       	pop	r15
     c8a:	ef 90       	pop	r14
     c8c:	df 90       	pop	r13
     c8e:	cf 90       	pop	r12
     c90:	bf 90       	pop	r11
     c92:	af 90       	pop	r10
     c94:	9f 90       	pop	r9
     c96:	8f 90       	pop	r8
     c98:	7f 90       	pop	r7
     c9a:	6f 90       	pop	r6
     c9c:	5f 90       	pop	r5
     c9e:	4f 90       	pop	r4
     ca0:	3f 90       	pop	r3
     ca2:	08 95       	ret

00000ca4 <TCP_ProcessTCPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t TCP_ProcessTCPPacket(void* IPHeaderInStart,
                             void* TCPHeaderInStart,
                             void* TCPHeaderOutStart)
{
     ca4:	af 92       	push	r10
     ca6:	bf 92       	push	r11
     ca8:	cf 92       	push	r12
     caa:	df 92       	push	r13
     cac:	ef 92       	push	r14
     cae:	ff 92       	push	r15
     cb0:	0f 93       	push	r16
     cb2:	1f 93       	push	r17
     cb4:	cf 93       	push	r28
     cb6:	df 93       	push	r29
     cb8:	7b 01       	movw	r14, r22
	IP_Header_t*  IPHeaderIN   = (IP_Header_t*)IPHeaderInStart;
     cba:	5c 01       	movw	r10, r24
	TCP_Header_t* TCPHeaderIN  = (TCP_Header_t*)TCPHeaderInStart;
	TCP_Header_t* TCPHeaderOUT = (TCP_Header_t*)TCPHeaderOutStart;
     cbc:	6a 01       	movw	r12, r20

	TCP_ConnectionInfo_t* ConnectionInfo;

	DecodeTCPHeader(TCPHeaderInStart);
     cbe:	cb 01       	movw	r24, r22
     cc0:	4e dd       	rcall	.-1380   	; 0x75e <DecodeTCPHeader>

	bool PacketResponse = false;

	/* Check if the destination port is open and allows incoming connections */
	if (TCP_GetPortState(TCPHeaderIN->DestinationPort) == TCP_Port_Open)
     cc2:	d7 01       	movw	r26, r14
     cc4:	12 96       	adiw	r26, 0x02	; 2
     cc6:	8d 91       	ld	r24, X+
     cc8:	9c 91       	ld	r25, X
     cca:	13 97       	sbiw	r26, 0x03	; 3
     ccc:	bf dd       	rcall	.-1154   	; 0x84c <TCP_GetPortState>
     cce:	81 30       	cpi	r24, 0x01	; 1
     cd0:	09 f0       	breq	.+2      	; 0xcd4 <TCP_ProcessTCPPacket+0x30>
     cd2:	02 c2       	rjmp	.+1028   	; 0x10d8 <TCP_ProcessTCPPacket+0x434>
	{
		/* Detect SYN from host to start a connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_SYN)
     cd4:	f7 01       	movw	r30, r14
     cd6:	85 85       	ldd	r24, Z+13	; 0x0d
     cd8:	81 ff       	sbrs	r24, 1
     cda:	0d c0       	rjmp	.+26     	; 0xcf6 <TCP_ProcessTCPPacket+0x52>
		  TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort, TCP_Connection_Listen);
     cdc:	d5 01       	movw	r26, r10
     cde:	1c 96       	adiw	r26, 0x0c	; 12
     ce0:	4d 91       	ld	r20, X+
     ce2:	5d 91       	ld	r21, X+
     ce4:	6d 91       	ld	r22, X+
     ce6:	7c 91       	ld	r23, X
     ce8:	1f 97       	sbiw	r26, 0x0f	; 15
     cea:	20 81       	ld	r18, Z
     cec:	31 81       	ldd	r19, Z+1	; 0x01
     cee:	82 81       	ldd	r24, Z+2	; 0x02
     cf0:	93 81       	ldd	r25, Z+3	; 0x03
     cf2:	00 e0       	ldi	r16, 0x00	; 0
     cf4:	2d df       	rcall	.-422    	; 0xb50 <TCP_SetConnectionState>

		/* Detect RST from host to abort existing connection */
		if (TCPHeaderIN->Flags & TCP_FLAG_RST)
     cf6:	f7 01       	movw	r30, r14
     cf8:	85 85       	ldd	r24, Z+13	; 0x0d
     cfa:	02 80       	ldd	r0, Z+2	; 0x02
     cfc:	f3 81       	ldd	r31, Z+3	; 0x03
     cfe:	e0 2d       	mov	r30, r0
     d00:	d5 01       	movw	r26, r10
     d02:	1c 96       	adiw	r26, 0x0c	; 12
     d04:	4d 91       	ld	r20, X+
     d06:	5d 91       	ld	r21, X+
     d08:	6d 91       	ld	r22, X+
     d0a:	7c 91       	ld	r23, X
     d0c:	1f 97       	sbiw	r26, 0x0f	; 15
     d0e:	d7 01       	movw	r26, r14
     d10:	2d 91       	ld	r18, X+
     d12:	3c 91       	ld	r19, X
     d14:	82 ff       	sbrs	r24, 2
     d16:	07 c0       	rjmp	.+14     	; 0xd26 <TCP_ProcessTCPPacket+0x82>
		{
			if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     d18:	cf 01       	movw	r24, r30
     d1a:	0a e0       	ldi	r16, 0x0A	; 10
     d1c:	19 df       	rcall	.-462    	; 0xb50 <TCP_SetConnectionState>
     d1e:	88 23       	and	r24, r24
     d20:	09 f4       	brne	.+2      	; 0xd24 <TCP_ProcessTCPPacket+0x80>
     d22:	15 c2       	rjmp	.+1066   	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
     d24:	d9 c1       	rjmp	.+946    	; 0x10d8 <TCP_ProcessTCPPacket+0x434>
			}
		}
		else
		{
			/* Process the incoming TCP packet based on the current connection state for the sender and port */
			switch (TCP_GetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort))
     d26:	cf 01       	movw	r24, r30
     d28:	aa de       	rcall	.-684    	; 0xa7e <TCP_GetConnectionState>
     d2a:	84 30       	cpi	r24, 0x04	; 4
     d2c:	09 f4       	brne	.+2      	; 0xd30 <TCP_ProcessTCPPacket+0x8c>
     d2e:	6f c1       	rjmp	.+734    	; 0x100e <TCP_ProcessTCPPacket+0x36a>
     d30:	85 30       	cpi	r24, 0x05	; 5
     d32:	48 f4       	brcc	.+18     	; 0xd46 <TCP_ProcessTCPPacket+0xa2>
     d34:	82 30       	cpi	r24, 0x02	; 2
     d36:	09 f4       	brne	.+2      	; 0xd3a <TCP_ProcessTCPPacket+0x96>
     d38:	56 c0       	rjmp	.+172    	; 0xde6 <TCP_ProcessTCPPacket+0x142>
     d3a:	83 30       	cpi	r24, 0x03	; 3
     d3c:	08 f0       	brcs	.+2      	; 0xd40 <TCP_ProcessTCPPacket+0x9c>
     d3e:	82 c0       	rjmp	.+260    	; 0xe44 <TCP_ProcessTCPPacket+0x1a0>
     d40:	88 23       	and	r24, r24
     d42:	59 f0       	breq	.+22     	; 0xd5a <TCP_ProcessTCPPacket+0xb6>
     d44:	04 c2       	rjmp	.+1032   	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
     d46:	86 30       	cpi	r24, 0x06	; 6
     d48:	09 f4       	brne	.+2      	; 0xd4c <TCP_ProcessTCPPacket+0xa8>
     d4a:	b3 c1       	rjmp	.+870    	; 0x10b2 <TCP_ProcessTCPPacket+0x40e>
     d4c:	86 30       	cpi	r24, 0x06	; 6
     d4e:	08 f4       	brcc	.+2      	; 0xd52 <TCP_ProcessTCPPacket+0xae>
     d50:	74 c1       	rjmp	.+744    	; 0x103a <TCP_ProcessTCPPacket+0x396>
     d52:	87 30       	cpi	r24, 0x07	; 7
     d54:	09 f0       	breq	.+2      	; 0xd58 <TCP_ProcessTCPPacket+0xb4>
     d56:	fb c1       	rjmp	.+1014   	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
     d58:	36 c1       	rjmp	.+620    	; 0xfc6 <TCP_ProcessTCPPacket+0x322>
			{
				case TCP_Connection_Listen:
					if (TCPHeaderIN->Flags == TCP_FLAG_SYN)
     d5a:	d7 01       	movw	r26, r14
     d5c:	1d 96       	adiw	r26, 0x0d	; 13
     d5e:	8c 91       	ld	r24, X
     d60:	1d 97       	sbiw	r26, 0x0d	; 13
     d62:	82 30       	cpi	r24, 0x02	; 2
     d64:	09 f0       	breq	.+2      	; 0xd68 <TCP_ProcessTCPPacket+0xc4>
     d66:	f3 c1       	rjmp	.+998    	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
					{
						/* SYN connection starts a connection with a peer */
						if (TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     d68:	f5 01       	movw	r30, r10
     d6a:	44 85       	ldd	r20, Z+12	; 0x0c
     d6c:	55 85       	ldd	r21, Z+13	; 0x0d
     d6e:	66 85       	ldd	r22, Z+14	; 0x0e
     d70:	77 85       	ldd	r23, Z+15	; 0x0f
     d72:	2d 91       	ld	r18, X+
     d74:	3c 91       	ld	r19, X
     d76:	11 97       	sbiw	r26, 0x01	; 1
     d78:	12 96       	adiw	r26, 0x02	; 2
     d7a:	8d 91       	ld	r24, X+
     d7c:	9c 91       	ld	r25, X
     d7e:	13 97       	sbiw	r26, 0x03	; 3
     d80:	02 e0       	ldi	r16, 0x02	; 2
     d82:	e6 de       	rcall	.-564    	; 0xb50 <TCP_SetConnectionState>
     d84:	88 23       	and	r24, r24
     d86:	69 f1       	breq	.+90     	; 0xde2 <TCP_ProcessTCPPacket+0x13e>
						                           TCPHeaderIN->SourcePort, TCP_Connection_SYNReceived))
						{
							TCPHeaderOUT->Flags = (TCP_FLAG_SYN | TCP_FLAG_ACK);
     d88:	82 e1       	ldi	r24, 0x12	; 18
     d8a:	d6 01       	movw	r26, r12
     d8c:	1d 96       	adiw	r26, 0x0d	; 13
     d8e:	8c 93       	st	X, r24

							ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress, TCPHeaderIN->SourcePort);
     d90:	f5 01       	movw	r30, r10
     d92:	44 85       	ldd	r20, Z+12	; 0x0c
     d94:	55 85       	ldd	r21, Z+13	; 0x0d
     d96:	66 85       	ldd	r22, Z+14	; 0x0e
     d98:	77 85       	ldd	r23, Z+15	; 0x0f
     d9a:	d7 01       	movw	r26, r14
     d9c:	2d 91       	ld	r18, X+
     d9e:	3c 91       	ld	r19, X
     da0:	11 97       	sbiw	r26, 0x01	; 1
     da2:	12 96       	adiw	r26, 0x02	; 2
     da4:	8d 91       	ld	r24, X+
     da6:	9c 91       	ld	r25, X
     da8:	13 97       	sbiw	r26, 0x03	; 3
     daa:	ff dd       	rcall	.-1026   	; 0x9aa <TCP_GetConnectionInfo>
     dac:	8c 01       	movw	r16, r24

							ConnectionInfo->SequenceNumberIn  = (SwapEndian_32(TCPHeaderIN->SequenceNumber) + 1);
     dae:	f7 01       	movw	r30, r14
     db0:	64 81       	ldd	r22, Z+4	; 0x04
     db2:	75 81       	ldd	r23, Z+5	; 0x05
     db4:	86 81       	ldd	r24, Z+6	; 0x06
     db6:	97 81       	ldd	r25, Z+7	; 0x07
     db8:	55 dd       	rcall	.-1366   	; 0x864 <SwapEndian_32>
     dba:	6f 5f       	subi	r22, 0xFF	; 255
     dbc:	7f 4f       	sbci	r23, 0xFF	; 255
     dbe:	8f 4f       	sbci	r24, 0xFF	; 255
     dc0:	9f 4f       	sbci	r25, 0xFF	; 255
     dc2:	d8 01       	movw	r26, r16
     dc4:	6d 93       	st	X+, r22
     dc6:	7d 93       	st	X+, r23
     dc8:	8d 93       	st	X+, r24
     dca:	9c 93       	st	X, r25
     dcc:	13 97       	sbiw	r26, 0x03	; 3
							ConnectionInfo->SequenceNumberOut = 0;
     dce:	f8 01       	movw	r30, r16
     dd0:	14 82       	std	Z+4, r1	; 0x04
     dd2:	15 82       	std	Z+5, r1	; 0x05
     dd4:	16 82       	std	Z+6, r1	; 0x06
     dd6:	17 82       	std	Z+7, r1	; 0x07
							ConnectionInfo->Buffer.InUse      = false;
     dd8:	04 5f       	subi	r16, 0xF4	; 244
     dda:	1d 4f       	sbci	r17, 0xFD	; 253
     ddc:	d8 01       	movw	r26, r16
     dde:	1c 92       	st	X, r1
     de0:	c4 c1       	rjmp	.+904    	; 0x116a <TCP_ProcessTCPPacket+0x4c6>
						}
						else
						{
							TCPHeaderOUT->Flags = TCP_FLAG_RST;
     de2:	84 e0       	ldi	r24, 0x04	; 4
     de4:	ed c0       	rjmp	.+474    	; 0xfc0 <TCP_ProcessTCPPacket+0x31c>
						PacketResponse      = true;
					}

					break;
				case TCP_Connection_SYNReceived:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
     de6:	d7 01       	movw	r26, r14
     de8:	1d 96       	adiw	r26, 0x0d	; 13
     dea:	8c 91       	ld	r24, X
     dec:	1d 97       	sbiw	r26, 0x0d	; 13
     dee:	80 31       	cpi	r24, 0x10	; 16
     df0:	09 f0       	breq	.+2      	; 0xdf4 <TCP_ProcessTCPPacket+0x150>
     df2:	ad c1       	rjmp	.+858    	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
					{
						/* ACK during the connection process completes the connection to a peer */

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     df4:	f5 01       	movw	r30, r10
     df6:	44 85       	ldd	r20, Z+12	; 0x0c
     df8:	55 85       	ldd	r21, Z+13	; 0x0d
     dfa:	66 85       	ldd	r22, Z+14	; 0x0e
     dfc:	77 85       	ldd	r23, Z+15	; 0x0f
     dfe:	2d 91       	ld	r18, X+
     e00:	3c 91       	ld	r19, X
     e02:	11 97       	sbiw	r26, 0x01	; 1
     e04:	12 96       	adiw	r26, 0x02	; 2
     e06:	8d 91       	ld	r24, X+
     e08:	9c 91       	ld	r25, X
     e0a:	13 97       	sbiw	r26, 0x03	; 3
     e0c:	03 e0       	ldi	r16, 0x03	; 3
     e0e:	a0 de       	rcall	.-704    	; 0xb50 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_Established);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e10:	d5 01       	movw	r26, r10
     e12:	1c 96       	adiw	r26, 0x0c	; 12
     e14:	4d 91       	ld	r20, X+
     e16:	5d 91       	ld	r21, X+
     e18:	6d 91       	ld	r22, X+
     e1a:	7c 91       	ld	r23, X
     e1c:	1f 97       	sbiw	r26, 0x0f	; 15
     e1e:	f7 01       	movw	r30, r14
     e20:	20 81       	ld	r18, Z
     e22:	31 81       	ldd	r19, Z+1	; 0x01
     e24:	82 81       	ldd	r24, Z+2	; 0x02
     e26:	93 81       	ldd	r25, Z+3	; 0x03
     e28:	c0 dd       	rcall	.-1152   	; 0x9aa <TCP_GetConnectionInfo>
     e2a:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberOut++;
     e2c:	84 81       	ldd	r24, Z+4	; 0x04
     e2e:	95 81       	ldd	r25, Z+5	; 0x05
     e30:	a6 81       	ldd	r26, Z+6	; 0x06
     e32:	b7 81       	ldd	r27, Z+7	; 0x07
     e34:	01 96       	adiw	r24, 0x01	; 1
     e36:	a1 1d       	adc	r26, r1
     e38:	b1 1d       	adc	r27, r1
     e3a:	84 83       	std	Z+4, r24	; 0x04
     e3c:	95 83       	std	Z+5, r25	; 0x05
     e3e:	a6 83       	std	Z+6, r26	; 0x06
     e40:	b7 83       	std	Z+7, r27	; 0x07
     e42:	85 c1       	rjmp	.+778    	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
					}

					break;
				case TCP_Connection_Established:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
     e44:	d7 01       	movw	r26, r14
     e46:	1d 96       	adiw	r26, 0x0d	; 13
     e48:	8c 91       	ld	r24, X
     e4a:	81 31       	cpi	r24, 0x11	; 17
     e4c:	a9 f5       	brne	.+106    	; 0xeb8 <TCP_ProcessTCPPacket+0x214>
					{
						/* FIN ACK when connected to a peer starts the finalization process */

						TCPHeaderOUT->Flags = (TCP_FLAG_FIN | TCP_FLAG_ACK);
     e4e:	f6 01       	movw	r30, r12
     e50:	85 87       	std	Z+13, r24	; 0x0d
						PacketResponse      = true;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e52:	d5 01       	movw	r26, r10
     e54:	1c 96       	adiw	r26, 0x0c	; 12
     e56:	4d 91       	ld	r20, X+
     e58:	5d 91       	ld	r21, X+
     e5a:	6d 91       	ld	r22, X+
     e5c:	7c 91       	ld	r23, X
     e5e:	1f 97       	sbiw	r26, 0x0f	; 15
     e60:	f7 01       	movw	r30, r14
     e62:	20 81       	ld	r18, Z
     e64:	31 81       	ldd	r19, Z+1	; 0x01
     e66:	82 81       	ldd	r24, Z+2	; 0x02
     e68:	93 81       	ldd	r25, Z+3	; 0x03
     e6a:	06 e0       	ldi	r16, 0x06	; 6
     e6c:	71 de       	rcall	.-798    	; 0xb50 <TCP_SetConnectionState>
											   TCPHeaderIN->SourcePort, TCP_Connection_CloseWait);

						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     e6e:	d5 01       	movw	r26, r10
     e70:	1c 96       	adiw	r26, 0x0c	; 12
     e72:	4d 91       	ld	r20, X+
     e74:	5d 91       	ld	r21, X+
     e76:	6d 91       	ld	r22, X+
     e78:	7c 91       	ld	r23, X
     e7a:	1f 97       	sbiw	r26, 0x0f	; 15
     e7c:	f7 01       	movw	r30, r14
     e7e:	20 81       	ld	r18, Z
     e80:	31 81       	ldd	r19, Z+1	; 0x01
     e82:	82 81       	ldd	r24, Z+2	; 0x02
     e84:	93 81       	ldd	r25, Z+3	; 0x03
     e86:	91 dd       	rcall	.-1246   	; 0x9aa <TCP_GetConnectionInfo>
     e88:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						ConnectionInfo->SequenceNumberIn++;
     e8a:	80 81       	ld	r24, Z
     e8c:	91 81       	ldd	r25, Z+1	; 0x01
     e8e:	a2 81       	ldd	r26, Z+2	; 0x02
     e90:	b3 81       	ldd	r27, Z+3	; 0x03
     e92:	01 96       	adiw	r24, 0x01	; 1
     e94:	a1 1d       	adc	r26, r1
     e96:	b1 1d       	adc	r27, r1
     e98:	80 83       	st	Z, r24
     e9a:	91 83       	std	Z+1, r25	; 0x01
     e9c:	a2 83       	std	Z+2, r26	; 0x02
     e9e:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
     ea0:	84 81       	ldd	r24, Z+4	; 0x04
     ea2:	95 81       	ldd	r25, Z+5	; 0x05
     ea4:	a6 81       	ldd	r26, Z+6	; 0x06
     ea6:	b7 81       	ldd	r27, Z+7	; 0x07
     ea8:	01 96       	adiw	r24, 0x01	; 1
     eaa:	a1 1d       	adc	r26, r1
     eac:	b1 1d       	adc	r27, r1
     eae:	84 83       	std	Z+4, r24	; 0x04
     eb0:	95 83       	std	Z+5, r25	; 0x05
     eb2:	a6 83       	std	Z+6, r26	; 0x06
     eb4:	b7 83       	std	Z+7, r27	; 0x07
     eb6:	59 c1       	rjmp	.+690    	; 0x116a <TCP_ProcessTCPPacket+0x4c6>
					}
					else if ((TCPHeaderIN->Flags == TCP_FLAG_ACK) || (TCPHeaderIN->Flags == (TCP_FLAG_ACK | TCP_FLAG_PSH)))
     eb8:	80 31       	cpi	r24, 0x10	; 16
     eba:	19 f0       	breq	.+6      	; 0xec2 <TCP_ProcessTCPPacket+0x21e>
     ebc:	88 31       	cpi	r24, 0x18	; 24
     ebe:	09 f0       	breq	.+2      	; 0xec2 <TCP_ProcessTCPPacket+0x21e>
     ec0:	46 c1       	rjmp	.+652    	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     ec2:	d5 01       	movw	r26, r10
     ec4:	1c 96       	adiw	r26, 0x0c	; 12
     ec6:	4d 91       	ld	r20, X+
     ec8:	5d 91       	ld	r21, X+
     eca:	6d 91       	ld	r22, X+
     ecc:	7c 91       	ld	r23, X
     ece:	1f 97       	sbiw	r26, 0x0f	; 15
     ed0:	f7 01       	movw	r30, r14
     ed2:	20 81       	ld	r18, Z
     ed4:	31 81       	ldd	r19, Z+1	; 0x01
     ed6:	82 81       	ldd	r24, Z+2	; 0x02
     ed8:	93 81       	ldd	r25, Z+3	; 0x03
     eda:	67 dd       	rcall	.-1330   	; 0x9aa <TCP_GetConnectionInfo>
     edc:	ec 01       	movw	r28, r24
															   TCPHeaderIN->SourcePort);

						/* Check if the buffer is currently in use either by a buffered data to send, or receive */
						if ((ConnectionInfo->Buffer.InUse == false) && (ConnectionInfo->Buffer.Ready == false))
     ede:	fc 01       	movw	r30, r24
     ee0:	e4 5f       	subi	r30, 0xF4	; 244
     ee2:	fd 4f       	sbci	r31, 0xFD	; 253
     ee4:	80 81       	ld	r24, Z
     ee6:	88 23       	and	r24, r24
     ee8:	81 f4       	brne	.+32     	; 0xf0a <TCP_ProcessTCPPacket+0x266>
     eea:	c5 5f       	subi	r28, 0xF5	; 245
     eec:	dd 4f       	sbci	r29, 0xFD	; 253
     eee:	88 81       	ld	r24, Y
     ef0:	cb 50       	subi	r28, 0x0B	; 11
     ef2:	d2 40       	sbci	r29, 0x02	; 2
     ef4:	88 23       	and	r24, r24
     ef6:	49 f4       	brne	.+18     	; 0xf0a <TCP_ProcessTCPPacket+0x266>
						{
							ConnectionInfo->Buffer.Direction = TCP_PACKETDIR_IN;
     ef8:	c6 5f       	subi	r28, 0xF6	; 246
     efa:	dd 4f       	sbci	r29, 0xFD	; 253
     efc:	18 82       	st	Y, r1
     efe:	ca 50       	subi	r28, 0x0A	; 10
     f00:	d2 40       	sbci	r29, 0x02	; 2
							ConnectionInfo->Buffer.InUse     = true;
     f02:	81 e0       	ldi	r24, 0x01	; 1
     f04:	80 83       	st	Z, r24
							ConnectionInfo->Buffer.Length    = 0;
     f06:	19 86       	std	Y+9, r1	; 0x09
     f08:	18 86       	std	Y+8, r1	; 0x08
						}

						/* Check if the buffer has been claimed by us to read in data from the peer */
						if ((ConnectionInfo->Buffer.Direction == TCP_PACKETDIR_IN) &&
     f0a:	c6 5f       	subi	r28, 0xF6	; 246
     f0c:	dd 4f       	sbci	r29, 0xFD	; 253
     f0e:	88 81       	ld	r24, Y
     f10:	ca 50       	subi	r28, 0x0A	; 10
     f12:	d2 40       	sbci	r29, 0x02	; 2
     f14:	88 23       	and	r24, r24
     f16:	09 f0       	breq	.+2      	; 0xf1a <TCP_ProcessTCPPacket+0x276>
     f18:	17 c1       	rjmp	.+558    	; 0x1148 <TCP_ProcessTCPPacket+0x4a4>
     f1a:	68 85       	ldd	r22, Y+8	; 0x08
     f1c:	79 85       	ldd	r23, Y+9	; 0x09
     f1e:	f2 e0       	ldi	r31, 0x02	; 2
     f20:	60 30       	cpi	r22, 0x00	; 0
     f22:	7f 07       	cpc	r23, r31
     f24:	09 f4       	brne	.+2      	; 0xf28 <TCP_ProcessTCPPacket+0x284>
     f26:	10 c1       	rjmp	.+544    	; 0x1148 <TCP_ProcessTCPPacket+0x4a4>
							(ConnectionInfo->Buffer.Length != TCP_WINDOW_SIZE))
						{
							uint16_t IPOffset   = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
     f28:	d5 01       	movw	r26, r10
     f2a:	8c 91       	ld	r24, X
     f2c:	8f 70       	andi	r24, 0x0F	; 15
							uint16_t TCPOffset  = (TCPHeaderIN->DataOffset * sizeof(uint32_t));
     f2e:	f7 01       	movw	r30, r14
     f30:	44 85       	ldd	r20, Z+12	; 0x0c
     f32:	42 95       	swap	r20
     f34:	4f 70       	andi	r20, 0x0F	; 15
     f36:	50 e0       	ldi	r21, 0x00	; 0
     f38:	44 0f       	add	r20, r20
     f3a:	55 1f       	adc	r21, r21
     f3c:	44 0f       	add	r20, r20
     f3e:	55 1f       	adc	r21, r21
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
     f40:	12 96       	adiw	r26, 0x02	; 2
     f42:	0d 91       	ld	r16, X+
     f44:	1c 91       	ld	r17, X
     f46:	13 97       	sbiw	r26, 0x03	; 3

				Temp = Data.Bytes[0];
     f48:	20 2f       	mov	r18, r16
				Data.Bytes[0] = Data.Bytes[1];
     f4a:	01 2f       	mov	r16, r17
				Data.Bytes[1] = Temp;
     f4c:	12 2f       	mov	r17, r18
							uint16_t DataLength = (SwapEndian_16(IPHeaderIN->TotalLength) - IPOffset - TCPOffset);
     f4e:	90 e0       	ldi	r25, 0x00	; 0
     f50:	88 0f       	add	r24, r24
     f52:	99 1f       	adc	r25, r25
     f54:	88 0f       	add	r24, r24
     f56:	99 1f       	adc	r25, r25
     f58:	08 1b       	sub	r16, r24
     f5a:	19 0b       	sbc	r17, r25
     f5c:	04 1b       	sub	r16, r20
     f5e:	15 0b       	sbc	r17, r21

							/* Copy the packet data into the buffer */
							memcpy(&ConnectionInfo->Buffer.Data[ConnectionInfo->Buffer.Length],
     f60:	9b 01       	movw	r18, r22
     f62:	26 5f       	subi	r18, 0xF6	; 246
     f64:	3f 4f       	sbci	r19, 0xFF	; 255
     f66:	2c 0f       	add	r18, r28
     f68:	3d 1f       	adc	r19, r29
     f6a:	4e 0d       	add	r20, r14
     f6c:	5f 1d       	adc	r21, r15
     f6e:	c9 01       	movw	r24, r18
     f70:	ba 01       	movw	r22, r20
     f72:	a8 01       	movw	r20, r16
     f74:	0e 94 fa 16 	call	0x2df4	; 0x2df4 <memcpy>
								   &((uint8_t*)TCPHeaderInStart)[TCPOffset],
								   DataLength);

							ConnectionInfo->SequenceNumberIn += DataLength;
     f78:	98 01       	movw	r18, r16
     f7a:	40 e0       	ldi	r20, 0x00	; 0
     f7c:	50 e0       	ldi	r21, 0x00	; 0
     f7e:	88 81       	ld	r24, Y
     f80:	99 81       	ldd	r25, Y+1	; 0x01
     f82:	aa 81       	ldd	r26, Y+2	; 0x02
     f84:	bb 81       	ldd	r27, Y+3	; 0x03
     f86:	82 0f       	add	r24, r18
     f88:	93 1f       	adc	r25, r19
     f8a:	a4 1f       	adc	r26, r20
     f8c:	b5 1f       	adc	r27, r21
     f8e:	88 83       	st	Y, r24
     f90:	99 83       	std	Y+1, r25	; 0x01
     f92:	aa 83       	std	Y+2, r26	; 0x02
     f94:	bb 83       	std	Y+3, r27	; 0x03
							ConnectionInfo->Buffer.Length    += DataLength;
     f96:	88 85       	ldd	r24, Y+8	; 0x08
     f98:	99 85       	ldd	r25, Y+9	; 0x09
     f9a:	80 0f       	add	r24, r16
     f9c:	91 1f       	adc	r25, r17
     f9e:	99 87       	std	Y+9, r25	; 0x09
     fa0:	88 87       	std	Y+8, r24	; 0x08

							/* Check if the buffer is full or if the PSH flag is set, if so indicate buffer ready */
							if ((!(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length)) || (TCPHeaderIN->Flags & TCP_FLAG_PSH))
     fa2:	80 50       	subi	r24, 0x00	; 0
     fa4:	92 40       	sbci	r25, 0x02	; 2
     fa6:	29 f0       	breq	.+10     	; 0xfb2 <TCP_ProcessTCPPacket+0x30e>
     fa8:	d7 01       	movw	r26, r14
     faa:	1d 96       	adiw	r26, 0x0d	; 13
     fac:	8c 91       	ld	r24, X
     fae:	83 ff       	sbrs	r24, 3
     fb0:	ce c0       	rjmp	.+412    	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
							{
								ConnectionInfo->Buffer.InUse = false;
     fb2:	c4 5f       	subi	r28, 0xF4	; 244
     fb4:	dd 4f       	sbci	r29, 0xFD	; 253
     fb6:	18 82       	st	Y, r1
								ConnectionInfo->Buffer.Ready = true;
     fb8:	fe 01       	movw	r30, r28
     fba:	81 e0       	ldi	r24, 0x01	; 1
     fbc:	82 93       	st	-Z, r24

								TCPHeaderOUT->Flags = TCP_FLAG_ACK;
     fbe:	80 e1       	ldi	r24, 0x10	; 16
     fc0:	f6 01       	movw	r30, r12
     fc2:	85 87       	std	Z+13, r24	; 0x0d
     fc4:	d2 c0       	rjmp	.+420    	; 0x116a <TCP_ProcessTCPPacket+0x4c6>
						}
					}

					break;
				case TCP_Connection_Closing:
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     fc6:	d5 01       	movw	r26, r10
     fc8:	1c 96       	adiw	r26, 0x0c	; 12
     fca:	4d 91       	ld	r20, X+
     fcc:	5d 91       	ld	r21, X+
     fce:	6d 91       	ld	r22, X+
     fd0:	7c 91       	ld	r23, X
     fd2:	1f 97       	sbiw	r26, 0x0f	; 15
     fd4:	f7 01       	movw	r30, r14
     fd6:	20 81       	ld	r18, Z
     fd8:	31 81       	ldd	r19, Z+1	; 0x01
     fda:	82 81       	ldd	r24, Z+2	; 0x02
     fdc:	93 81       	ldd	r25, Z+3	; 0x03
     fde:	e5 dc       	rcall	.-1590   	; 0x9aa <TCP_GetConnectionInfo>
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = (TCP_FLAG_ACK | TCP_FLAG_FIN);
     fe0:	21 e1       	ldi	r18, 0x11	; 17
     fe2:	d6 01       	movw	r26, r12
     fe4:	1d 96       	adiw	r26, 0x0d	; 13
     fe6:	2c 93       	st	X, r18
						PacketResponse      = true;

						ConnectionInfo->Buffer.InUse = false;
     fe8:	fc 01       	movw	r30, r24
     fea:	e4 5f       	subi	r30, 0xF4	; 244
     fec:	fd 4f       	sbci	r31, 0xFD	; 253
     fee:	10 82       	st	Z, r1

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
     ff0:	f5 01       	movw	r30, r10
     ff2:	44 85       	ldd	r20, Z+12	; 0x0c
     ff4:	55 85       	ldd	r21, Z+13	; 0x0d
     ff6:	66 85       	ldd	r22, Z+14	; 0x0e
     ff8:	77 85       	ldd	r23, Z+15	; 0x0f
     ffa:	d7 01       	movw	r26, r14
     ffc:	2d 91       	ld	r18, X+
     ffe:	3c 91       	ld	r19, X
    1000:	11 97       	sbiw	r26, 0x01	; 1
    1002:	12 96       	adiw	r26, 0x02	; 2
    1004:	8d 91       	ld	r24, X+
    1006:	9c 91       	ld	r25, X
    1008:	13 97       	sbiw	r26, 0x03	; 3
    100a:	04 e0       	ldi	r16, 0x04	; 4
    100c:	50 c0       	rjmp	.+160    	; 0x10ae <TCP_ProcessTCPPacket+0x40a>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait1);

					break;
				case TCP_Connection_FINWait1:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    100e:	f7 01       	movw	r30, r14
    1010:	85 85       	ldd	r24, Z+13	; 0x0d
    1012:	81 31       	cpi	r24, 0x11	; 17
    1014:	b9 f0       	breq	.+46     	; 0x1044 <TCP_ProcessTCPPacket+0x3a0>
						ConnectionInfo->SequenceNumberOut++;

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}
					else if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    1016:	80 31       	cpi	r24, 0x10	; 16
    1018:	09 f0       	breq	.+2      	; 0x101c <TCP_ProcessTCPPacket+0x378>
    101a:	99 c0       	rjmp	.+306    	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    101c:	f5 01       	movw	r30, r10
    101e:	44 85       	ldd	r20, Z+12	; 0x0c
    1020:	55 85       	ldd	r21, Z+13	; 0x0d
    1022:	66 85       	ldd	r22, Z+14	; 0x0e
    1024:	77 85       	ldd	r23, Z+15	; 0x0f
    1026:	d7 01       	movw	r26, r14
    1028:	2d 91       	ld	r18, X+
    102a:	3c 91       	ld	r19, X
    102c:	11 97       	sbiw	r26, 0x01	; 1
    102e:	12 96       	adiw	r26, 0x02	; 2
    1030:	8d 91       	ld	r24, X+
    1032:	9c 91       	ld	r25, X
    1034:	13 97       	sbiw	r26, 0x03	; 3
    1036:	05 e0       	ldi	r16, 0x05	; 5
    1038:	4d c0       	rjmp	.+154    	; 0x10d4 <TCP_ProcessTCPPacket+0x430>
											   TCPHeaderIN->SourcePort, TCP_Connection_FINWait2);
					}

					break;
				case TCP_Connection_FINWait2:
					if (TCPHeaderIN->Flags == (TCP_FLAG_FIN | TCP_FLAG_ACK))
    103a:	f7 01       	movw	r30, r14
    103c:	85 85       	ldd	r24, Z+13	; 0x0d
    103e:	81 31       	cpi	r24, 0x11	; 17
    1040:	09 f0       	breq	.+2      	; 0x1044 <TCP_ProcessTCPPacket+0x3a0>
    1042:	85 c0       	rjmp	.+266    	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
					{
						ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1044:	d5 01       	movw	r26, r10
    1046:	1c 96       	adiw	r26, 0x0c	; 12
    1048:	4d 91       	ld	r20, X+
    104a:	5d 91       	ld	r21, X+
    104c:	6d 91       	ld	r22, X+
    104e:	7c 91       	ld	r23, X
    1050:	1f 97       	sbiw	r26, 0x0f	; 15
    1052:	20 81       	ld	r18, Z
    1054:	31 81       	ldd	r19, Z+1	; 0x01
    1056:	82 81       	ldd	r24, Z+2	; 0x02
    1058:	93 81       	ldd	r25, Z+3	; 0x03
    105a:	a7 dc       	rcall	.-1714   	; 0x9aa <TCP_GetConnectionInfo>
    105c:	fc 01       	movw	r30, r24
															   TCPHeaderIN->SourcePort);

						TCPHeaderOUT->Flags = TCP_FLAG_ACK;
    105e:	80 e1       	ldi	r24, 0x10	; 16
    1060:	d6 01       	movw	r26, r12
    1062:	1d 96       	adiw	r26, 0x0d	; 13
    1064:	8c 93       	st	X, r24
						PacketResponse      = true;

						ConnectionInfo->SequenceNumberIn++;
    1066:	80 81       	ld	r24, Z
    1068:	91 81       	ldd	r25, Z+1	; 0x01
    106a:	a2 81       	ldd	r26, Z+2	; 0x02
    106c:	b3 81       	ldd	r27, Z+3	; 0x03
    106e:	01 96       	adiw	r24, 0x01	; 1
    1070:	a1 1d       	adc	r26, r1
    1072:	b1 1d       	adc	r27, r1
    1074:	80 83       	st	Z, r24
    1076:	91 83       	std	Z+1, r25	; 0x01
    1078:	a2 83       	std	Z+2, r26	; 0x02
    107a:	b3 83       	std	Z+3, r27	; 0x03
						ConnectionInfo->SequenceNumberOut++;
    107c:	84 81       	ldd	r24, Z+4	; 0x04
    107e:	95 81       	ldd	r25, Z+5	; 0x05
    1080:	a6 81       	ldd	r26, Z+6	; 0x06
    1082:	b7 81       	ldd	r27, Z+7	; 0x07
    1084:	01 96       	adiw	r24, 0x01	; 1
    1086:	a1 1d       	adc	r26, r1
    1088:	b1 1d       	adc	r27, r1
    108a:	84 83       	std	Z+4, r24	; 0x04
    108c:	95 83       	std	Z+5, r25	; 0x05
    108e:	a6 83       	std	Z+6, r26	; 0x06
    1090:	b7 83       	std	Z+7, r27	; 0x07

						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    1092:	f5 01       	movw	r30, r10
    1094:	44 85       	ldd	r20, Z+12	; 0x0c
    1096:	55 85       	ldd	r21, Z+13	; 0x0d
    1098:	66 85       	ldd	r22, Z+14	; 0x0e
    109a:	77 85       	ldd	r23, Z+15	; 0x0f
    109c:	d7 01       	movw	r26, r14
    109e:	2d 91       	ld	r18, X+
    10a0:	3c 91       	ld	r19, X
    10a2:	11 97       	sbiw	r26, 0x01	; 1
    10a4:	12 96       	adiw	r26, 0x02	; 2
    10a6:	8d 91       	ld	r24, X+
    10a8:	9c 91       	ld	r25, X
    10aa:	13 97       	sbiw	r26, 0x03	; 3
    10ac:	0a e0       	ldi	r16, 0x0A	; 10
    10ae:	50 dd       	rcall	.-1376   	; 0xb50 <TCP_SetConnectionState>
    10b0:	5c c0       	rjmp	.+184    	; 0x116a <TCP_ProcessTCPPacket+0x4c6>
											   TCPHeaderIN->SourcePort, TCP_Connection_Closed);
					}

					break;
				case TCP_Connection_CloseWait:
					if (TCPHeaderIN->Flags == TCP_FLAG_ACK)
    10b2:	f7 01       	movw	r30, r14
    10b4:	85 85       	ldd	r24, Z+13	; 0x0d
    10b6:	80 31       	cpi	r24, 0x10	; 16
    10b8:	09 f0       	breq	.+2      	; 0x10bc <TCP_ProcessTCPPacket+0x418>
    10ba:	49 c0       	rjmp	.+146    	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
					{
						TCP_SetConnectionState(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    10bc:	d5 01       	movw	r26, r10
    10be:	1c 96       	adiw	r26, 0x0c	; 12
    10c0:	4d 91       	ld	r20, X+
    10c2:	5d 91       	ld	r21, X+
    10c4:	6d 91       	ld	r22, X+
    10c6:	7c 91       	ld	r23, X
    10c8:	1f 97       	sbiw	r26, 0x0f	; 15
    10ca:	20 81       	ld	r18, Z
    10cc:	31 81       	ldd	r19, Z+1	; 0x01
    10ce:	82 81       	ldd	r24, Z+2	; 0x02
    10d0:	93 81       	ldd	r25, Z+3	; 0x03
    10d2:	0a e0       	ldi	r16, 0x0A	; 10
    10d4:	3d dd       	rcall	.-1414   	; 0xb50 <TCP_SetConnectionState>
    10d6:	3b c0       	rjmp	.+118    	; 0x114e <TCP_ProcessTCPPacket+0x4aa>
		}
	}
	else
	{
		/* Port is not open, indicate via a RST/ACK response to the sender */
		TCPHeaderOUT->Flags = (TCP_FLAG_RST | TCP_FLAG_ACK);
    10d8:	84 e1       	ldi	r24, 0x14	; 20
    10da:	72 cf       	rjmp	.-284    	; 0xfc0 <TCP_ProcessTCPPacket+0x31c>
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));

		if (!(ConnectionInfo->Buffer.InUse))
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE);
    10dc:	82 e0       	ldi	r24, 0x02	; 2
    10de:	90 e0       	ldi	r25, 0x00	; 0
    10e0:	d6 01       	movw	r26, r12
    10e2:	1f 96       	adiw	r26, 0x0f	; 15
    10e4:	9c 93       	st	X, r25
    10e6:	8e 93       	st	-X, r24
    10e8:	1e 97       	sbiw	r26, 0x0e	; 14
    10ea:	09 c0       	rjmp	.+18     	; 0x10fe <TCP_ProcessTCPPacket+0x45a>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    10ec:	80 e0       	ldi	r24, 0x00	; 0
    10ee:	92 e0       	ldi	r25, 0x02	; 2
    10f0:	28 85       	ldd	r18, Y+8	; 0x08
    10f2:	39 85       	ldd	r19, Y+9	; 0x09
    10f4:	82 1b       	sub	r24, r18
    10f6:	93 0b       	sbc	r25, r19
		else
		  TCPHeaderOUT->WindowSize         = SwapEndian_16(TCP_WINDOW_SIZE - ConnectionInfo->Buffer.Length);
    10f8:	f6 01       	movw	r30, r12
    10fa:	96 87       	std	Z+14, r25	; 0x0e
    10fc:	87 87       	std	Z+15, r24	; 0x0f

		TCPHeaderOUT->UrgentPointer        = 0;
    10fe:	d6 01       	movw	r26, r12
    1100:	53 96       	adiw	r26, 0x13	; 19
    1102:	1c 92       	st	X, r1
    1104:	1e 92       	st	-X, r1
    1106:	52 97       	sbiw	r26, 0x12	; 18
		TCPHeaderOUT->Checksum             = 0;
    1108:	51 96       	adiw	r26, 0x11	; 17
    110a:	1c 92       	st	X, r1
    110c:	1e 92       	st	-X, r1
    110e:	50 97       	sbiw	r26, 0x10	; 16
		TCPHeaderOUT->Reserved             = 0;
    1110:	1c 96       	adiw	r26, 0x0c	; 12
    1112:	8c 91       	ld	r24, X
    1114:	1c 97       	sbiw	r26, 0x0c	; 12
    1116:	80 7f       	andi	r24, 0xF0	; 240
    1118:	1c 96       	adiw	r26, 0x0c	; 12
    111a:	8c 93       	st	X, r24

		TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, IPHeaderIN->DestinationAddress,
    111c:	f5 01       	movw	r30, r10
    111e:	40 89       	ldd	r20, Z+16	; 0x10
    1120:	51 89       	ldd	r21, Z+17	; 0x11
    1122:	62 89       	ldd	r22, Z+18	; 0x12
    1124:	73 89       	ldd	r23, Z+19	; 0x13
    1126:	04 85       	ldd	r16, Z+12	; 0x0c
    1128:	15 85       	ldd	r17, Z+13	; 0x0d
    112a:	26 85       	ldd	r18, Z+14	; 0x0e
    112c:	37 85       	ldd	r19, Z+15	; 0x0f
    112e:	c6 01       	movw	r24, r12
    1130:	e4 e1       	ldi	r30, 0x14	; 20
    1132:	ee 2e       	mov	r14, r30
    1134:	f1 2c       	mov	r15, r1
    1136:	9c db       	rcall	.-2248   	; 0x870 <TCP_Checksum16>
    1138:	d6 01       	movw	r26, r12
    113a:	51 96       	adiw	r26, 0x11	; 17
    113c:	9c 93       	st	X, r25
    113e:	8e 93       	st	-X, r24
    1140:	50 97       	sbiw	r26, 0x10	; 16
    1142:	24 e1       	ldi	r18, 0x14	; 20
    1144:	30 e0       	ldi	r19, 0x00	; 0
    1146:	05 c0       	rjmp	.+10     	; 0x1152 <TCP_ProcessTCPPacket+0x4ae>
		                                                    IPHeaderIN->SourceAddress, sizeof(TCP_Header_t));

		return sizeof(TCP_Header_t);
    1148:	2f ef       	ldi	r18, 0xFF	; 255
    114a:	3f ef       	ldi	r19, 0xFF	; 255
    114c:	02 c0       	rjmp	.+4      	; 0x1152 <TCP_ProcessTCPPacket+0x4ae>
    114e:	20 e0       	ldi	r18, 0x00	; 0
    1150:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    1152:	c9 01       	movw	r24, r18
    1154:	df 91       	pop	r29
    1156:	cf 91       	pop	r28
    1158:	1f 91       	pop	r17
    115a:	0f 91       	pop	r16
    115c:	ff 90       	pop	r15
    115e:	ef 90       	pop	r14
    1160:	df 90       	pop	r13
    1162:	cf 90       	pop	r12
    1164:	bf 90       	pop	r11
    1166:	af 90       	pop	r10
    1168:	08 95       	ret
	}

	/* Check if we need to respond to the sent packet */
	if (PacketResponse)
	{
		ConnectionInfo = TCP_GetConnectionInfo(TCPHeaderIN->DestinationPort, IPHeaderIN->SourceAddress,
    116a:	f5 01       	movw	r30, r10
    116c:	44 85       	ldd	r20, Z+12	; 0x0c
    116e:	55 85       	ldd	r21, Z+13	; 0x0d
    1170:	66 85       	ldd	r22, Z+14	; 0x0e
    1172:	77 85       	ldd	r23, Z+15	; 0x0f
    1174:	d7 01       	movw	r26, r14
    1176:	2d 91       	ld	r18, X+
    1178:	3c 91       	ld	r19, X
    117a:	11 97       	sbiw	r26, 0x01	; 1
    117c:	12 96       	adiw	r26, 0x02	; 2
    117e:	8d 91       	ld	r24, X+
    1180:	9c 91       	ld	r25, X
    1182:	13 97       	sbiw	r26, 0x03	; 3
    1184:	12 dc       	rcall	.-2012   	; 0x9aa <TCP_GetConnectionInfo>
    1186:	ec 01       	movw	r28, r24
		                                       TCPHeaderIN->SourcePort);

		TCPHeaderOUT->SourcePort           = TCPHeaderIN->DestinationPort;
    1188:	f7 01       	movw	r30, r14
    118a:	82 81       	ldd	r24, Z+2	; 0x02
    118c:	93 81       	ldd	r25, Z+3	; 0x03
    118e:	d6 01       	movw	r26, r12
    1190:	11 96       	adiw	r26, 0x01	; 1
    1192:	9c 93       	st	X, r25
    1194:	8e 93       	st	-X, r24
		TCPHeaderOUT->DestinationPort      = TCPHeaderIN->SourcePort;
    1196:	80 81       	ld	r24, Z
    1198:	91 81       	ldd	r25, Z+1	; 0x01
    119a:	13 96       	adiw	r26, 0x03	; 3
    119c:	9c 93       	st	X, r25
    119e:	8e 93       	st	-X, r24
    11a0:	12 97       	sbiw	r26, 0x02	; 2
		TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionInfo->SequenceNumberOut);
    11a2:	6c 81       	ldd	r22, Y+4	; 0x04
    11a4:	7d 81       	ldd	r23, Y+5	; 0x05
    11a6:	8e 81       	ldd	r24, Y+6	; 0x06
    11a8:	9f 81       	ldd	r25, Y+7	; 0x07
    11aa:	5c db       	rcall	.-2376   	; 0x864 <SwapEndian_32>
    11ac:	f6 01       	movw	r30, r12
    11ae:	64 83       	std	Z+4, r22	; 0x04
    11b0:	75 83       	std	Z+5, r23	; 0x05
    11b2:	86 83       	std	Z+6, r24	; 0x06
    11b4:	97 83       	std	Z+7, r25	; 0x07
		TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionInfo->SequenceNumberIn);
    11b6:	68 81       	ld	r22, Y
    11b8:	79 81       	ldd	r23, Y+1	; 0x01
    11ba:	8a 81       	ldd	r24, Y+2	; 0x02
    11bc:	9b 81       	ldd	r25, Y+3	; 0x03
    11be:	52 db       	rcall	.-2396   	; 0x864 <SwapEndian_32>
    11c0:	d6 01       	movw	r26, r12
    11c2:	18 96       	adiw	r26, 0x08	; 8
    11c4:	6d 93       	st	X+, r22
    11c6:	7d 93       	st	X+, r23
    11c8:	8d 93       	st	X+, r24
    11ca:	9c 93       	st	X, r25
    11cc:	1b 97       	sbiw	r26, 0x0b	; 11
		TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
    11ce:	1c 96       	adiw	r26, 0x0c	; 12
    11d0:	8c 91       	ld	r24, X
    11d2:	1c 97       	sbiw	r26, 0x0c	; 12
    11d4:	8f 70       	andi	r24, 0x0F	; 15
    11d6:	80 65       	ori	r24, 0x50	; 80
    11d8:	1c 96       	adiw	r26, 0x0c	; 12
    11da:	8c 93       	st	X, r24

		if (!(ConnectionInfo->Buffer.InUse))
    11dc:	c4 5f       	subi	r28, 0xF4	; 244
    11de:	dd 4f       	sbci	r29, 0xFD	; 253
    11e0:	88 81       	ld	r24, Y
    11e2:	cc 50       	subi	r28, 0x0C	; 12
    11e4:	d2 40       	sbci	r29, 0x02	; 2
    11e6:	88 23       	and	r24, r24
    11e8:	09 f4       	brne	.+2      	; 0x11ec <TCP_ProcessTCPPacket+0x548>
    11ea:	78 cf       	rjmp	.-272    	; 0x10dc <TCP_ProcessTCPPacket+0x438>
    11ec:	7f cf       	rjmp	.-258    	; 0x10ec <TCP_ProcessTCPPacket+0x448>

000011ee <TCP_TCPTask>:
 *  level. If an application produces a response, this task constructs the appropriate Ethernet frame and places it into the Ethernet OUT
 *  buffer for later transmission.
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
    11ee:	2f 92       	push	r2
    11f0:	3f 92       	push	r3
    11f2:	4f 92       	push	r4
    11f4:	5f 92       	push	r5
    11f6:	6f 92       	push	r6
    11f8:	7f 92       	push	r7
    11fa:	8f 92       	push	r8
    11fc:	9f 92       	push	r9
    11fe:	af 92       	push	r10
    1200:	bf 92       	push	r11
    1202:	cf 92       	push	r12
    1204:	df 92       	push	r13
    1206:	ef 92       	push	r14
    1208:	ff 92       	push	r15
    120a:	0f 93       	push	r16
    120c:	1f 93       	push	r17
    120e:	df 93       	push	r29
    1210:	cf 93       	push	r28
    1212:	00 d0       	rcall	.+0      	; 0x1214 <TCP_TCPTask+0x26>
    1214:	00 d0       	rcall	.+0      	; 0x1216 <TCP_TCPTask+0x28>
    1216:	cd b7       	in	r28, 0x3d	; 61
    1218:	de b7       	in	r29, 0x3e	; 62
    121a:	7c 83       	std	Y+4, r23	; 0x04
    121c:	6b 83       	std	Y+3, r22	; 0x03
    121e:	55 eb       	ldi	r21, 0xB5	; 181
    1220:	e5 2e       	mov	r14, r21
    1222:	5d e0       	ldi	r21, 0x0D	; 13
    1224:	f5 2e       	mov	r15, r21
    1226:	00 e0       	ldi	r16, 0x00	; 0
    1228:	10 e0       	ldi	r17, 0x00	; 0
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    122a:	46 e1       	ldi	r20, 0x16	; 22
    122c:	c4 2e       	mov	r12, r20
    122e:	42 e0       	ldi	r20, 0x02	; 2
    1230:	d4 2e       	mov	r13, r20
    1232:	1c c0       	rjmp	.+56     	; 0x126c <TCP_TCPTask+0x7e>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    1234:	80 91 f9 13 	lds	r24, 0x13F9
    1238:	81 30       	cpi	r24, 0x01	; 1
    123a:	79 f4       	brne	.+30     	; 0x125a <TCP_TCPTask+0x6c>
			    (PortStateTable[PTableEntry].State == TCP_Port_Open))
			{
				PortStateTable[PTableEntry].ApplicationHandler(&ConnectionStateTable[CSTableEntry],
    123c:	0c 9d       	mul	r16, r12
    123e:	b0 01       	movw	r22, r0
    1240:	0d 9d       	mul	r16, r13
    1242:	70 0d       	add	r23, r0
    1244:	1c 9d       	mul	r17, r12
    1246:	70 0d       	add	r23, r0
    1248:	11 24       	eor	r1, r1
    124a:	6b 53       	subi	r22, 0x3B	; 59
    124c:	72 4f       	sbci	r23, 0xF2	; 242
    124e:	e0 91 fa 13 	lds	r30, 0x13FA
    1252:	f0 91 fb 13 	lds	r31, 0x13FB
    1256:	c7 01       	movw	r24, r14
    1258:	09 95       	icall
    125a:	0f 5f       	subi	r16, 0xFF	; 255
    125c:	1f 4f       	sbci	r17, 0xFF	; 255
    125e:	26 e1       	ldi	r18, 0x16	; 22
    1260:	32 e0       	ldi	r19, 0x02	; 2
    1262:	e2 0e       	add	r14, r18
    1264:	f3 1e       	adc	r15, r19
 */
void TCP_TCPTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
		         Ethernet_Frame_Info_t* const FrameOUT)
{
	/* Run each application in sequence, to process incoming and generate outgoing packets */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
    1266:	03 30       	cpi	r16, 0x03	; 3
    1268:	11 05       	cpc	r17, r1
    126a:	59 f0       	breq	.+22     	; 0x1282 <TCP_TCPTask+0x94>
	{
		/* Find the corresponding port entry in the port table */
		for (uint8_t PTableEntry = 0; PTableEntry < MAX_OPEN_TCP_PORTS; PTableEntry++)
		{
			/* Run the application handler for the port */
			if ((PortStateTable[PTableEntry].Port  == ConnectionStateTable[CSTableEntry].Port) &&
    126c:	20 91 f7 13 	lds	r18, 0x13F7
    1270:	30 91 f8 13 	lds	r19, 0x13F8
    1274:	d7 01       	movw	r26, r14
    1276:	8d 91       	ld	r24, X+
    1278:	9c 91       	ld	r25, X
    127a:	28 17       	cp	r18, r24
    127c:	39 07       	cpc	r19, r25
    127e:	69 f7       	brne	.-38     	; 0x125a <TCP_TCPTask+0x6c>
    1280:	d9 cf       	rjmp	.-78     	; 0x1234 <TCP_TCPTask+0x46>
			}
		}
	}

	/* Bail out early if there is already a frame waiting to be sent in the Ethernet OUT buffer */
	if (FrameOUT->FrameLength)
    1282:	eb 81       	ldd	r30, Y+3	; 0x03
    1284:	fc 81       	ldd	r31, Y+4	; 0x04
    1286:	e4 52       	subi	r30, 0x24	; 36
    1288:	fa 4f       	sbci	r31, 0xFA	; 250
    128a:	80 81       	ld	r24, Z
    128c:	91 81       	ldd	r25, Z+1	; 0x01
    128e:	ec 5d       	subi	r30, 0xDC	; 220
    1290:	f5 40       	sbci	r31, 0x05	; 5
    1292:	fc 83       	std	Y+4, r31	; 0x04
    1294:	eb 83       	std	Y+3, r30	; 0x03
    1296:	89 2b       	or	r24, r25
    1298:	09 f0       	breq	.+2      	; 0x129c <TCP_TCPTask+0xae>
    129a:	22 c1       	rjmp	.+580    	; 0x14e0 <TCP_TCPTask+0x2f2>

	/* Send response packets from each application as the TCP packet buffers are filled by the applications */
	for (uint8_t CSTableEntry = 0; CSTableEntry < MAX_TCP_CONNECTIONS; CSTableEntry++)
	{
		/* For each completely received packet, pass it along to the listening application */
		if ((ConnectionStateTable[CSTableEntry].Info.Buffer.Direction == TCP_PACKETDIR_OUT) &&
    129c:	80 91 c7 0f 	lds	r24, 0x0FC7
    12a0:	88 23       	and	r24, r24
    12a2:	39 f0       	breq	.+14     	; 0x12b2 <TCP_TCPTask+0xc4>
    12a4:	80 91 c8 0f 	lds	r24, 0x0FC8
    12a8:	88 23       	and	r24, r24
    12aa:	19 f0       	breq	.+6      	; 0x12b2 <TCP_TCPTask+0xc4>
    12ac:	1a 82       	std	Y+2, r1	; 0x02
    12ae:	19 82       	std	Y+1, r1	; 0x01
    12b0:	1b c0       	rjmp	.+54     	; 0x12e8 <TCP_TCPTask+0xfa>
    12b2:	80 91 dd 11 	lds	r24, 0x11DD
    12b6:	88 23       	and	r24, r24
    12b8:	49 f0       	breq	.+18     	; 0x12cc <TCP_TCPTask+0xde>
    12ba:	80 91 de 11 	lds	r24, 0x11DE
    12be:	88 23       	and	r24, r24
    12c0:	29 f0       	breq	.+10     	; 0x12cc <TCP_TCPTask+0xde>
    12c2:	21 e0       	ldi	r18, 0x01	; 1
    12c4:	30 e0       	ldi	r19, 0x00	; 0
    12c6:	3a 83       	std	Y+2, r19	; 0x02
    12c8:	29 83       	std	Y+1, r18	; 0x01
    12ca:	0e c0       	rjmp	.+28     	; 0x12e8 <TCP_TCPTask+0xfa>
    12cc:	80 91 f3 13 	lds	r24, 0x13F3
    12d0:	88 23       	and	r24, r24
    12d2:	09 f4       	brne	.+2      	; 0x12d6 <TCP_TCPTask+0xe8>
    12d4:	05 c1       	rjmp	.+522    	; 0x14e0 <TCP_TCPTask+0x2f2>
    12d6:	80 91 f4 13 	lds	r24, 0x13F4
    12da:	88 23       	and	r24, r24
    12dc:	09 f4       	brne	.+2      	; 0x12e0 <TCP_TCPTask+0xf2>
    12de:	00 c1       	rjmp	.+512    	; 0x14e0 <TCP_TCPTask+0x2f2>
    12e0:	82 e0       	ldi	r24, 0x02	; 2
    12e2:	90 e0       	ldi	r25, 0x00	; 0
    12e4:	9a 83       	std	Y+2, r25	; 0x02
    12e6:	89 83       	std	Y+1, r24	; 0x01
		    (ConnectionStateTable[CSTableEntry].Info.Buffer.Ready))
		{
			Ethernet_Frame_Header_t* FrameOUTHeader = (Ethernet_Frame_Header_t*)&FrameOUT->FrameData;
			IP_Header_t*             IPHeaderOUT    = (IP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t)];
    12e8:	3e e0       	ldi	r19, 0x0E	; 14
    12ea:	a3 2e       	mov	r10, r19
    12ec:	b1 2c       	mov	r11, r1
    12ee:	ab 81       	ldd	r26, Y+3	; 0x03
    12f0:	bc 81       	ldd	r27, Y+4	; 0x04
    12f2:	aa 0e       	add	r10, r26
    12f4:	bb 1e       	adc	r11, r27
			TCP_Header_t*            TCPHeaderOUT   = (TCP_Header_t*)&FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                                              sizeof(IP_Header_t)];
    12f6:	22 e2       	ldi	r18, 0x22	; 34
    12f8:	c2 2e       	mov	r12, r18
    12fa:	d1 2c       	mov	r13, r1
    12fc:	ca 0e       	add	r12, r26
    12fe:	db 1e       	adc	r13, r27
			void*                    TCPDataOUT     = &FrameOUT->FrameData[sizeof(Ethernet_Frame_Header_t) +
			                                                               sizeof(IP_Header_t) +
			                                                               sizeof(TCP_Header_t)];

			uint16_t PacketSize = ConnectionStateTable[CSTableEntry].Info.Buffer.Length;
    1300:	86 e1       	ldi	r24, 0x16	; 22
    1302:	92 e0       	ldi	r25, 0x02	; 2
    1304:	e9 81       	ldd	r30, Y+1	; 0x01
    1306:	fa 81       	ldd	r31, Y+2	; 0x02
    1308:	e8 9f       	mul	r30, r24
    130a:	80 01       	movw	r16, r0
    130c:	e9 9f       	mul	r30, r25
    130e:	10 0d       	add	r17, r0
    1310:	f8 9f       	mul	r31, r24
    1312:	10 0d       	add	r17, r0
    1314:	11 24       	eor	r1, r1
    1316:	95 eb       	ldi	r25, 0xB5	; 181
    1318:	69 2e       	mov	r6, r25
    131a:	9d e0       	ldi	r25, 0x0D	; 13
    131c:	79 2e       	mov	r7, r25
    131e:	60 0e       	add	r6, r16
    1320:	71 1e       	adc	r7, r17
    1322:	d3 01       	movw	r26, r6
    1324:	50 96       	adiw	r26, 0x10	; 16
    1326:	8d 90       	ld	r8, X+
    1328:	9c 90       	ld	r9, X
    132a:	51 97       	sbiw	r26, 0x11	; 17

			/* Fill out the TCP data */
			TCPHeaderOUT->SourcePort           = ConnectionStateTable[CSTableEntry].Port;
    132c:	8d 91       	ld	r24, X+
    132e:	9c 91       	ld	r25, X
    1330:	eb 81       	ldd	r30, Y+3	; 0x03
    1332:	fc 81       	ldd	r31, Y+4	; 0x04
    1334:	93 a3       	std	Z+35, r25	; 0x23
    1336:	82 a3       	std	Z+34, r24	; 0x22
			TCPHeaderOUT->DestinationPort      = ConnectionStateTable[CSTableEntry].RemotePort;
    1338:	8b e0       	ldi	r24, 0x0B	; 11
    133a:	91 e0       	ldi	r25, 0x01	; 1
    133c:	29 81       	ldd	r18, Y+1	; 0x01
    133e:	3a 81       	ldd	r19, Y+2	; 0x02
    1340:	28 9f       	mul	r18, r24
    1342:	f0 01       	movw	r30, r0
    1344:	29 9f       	mul	r18, r25
    1346:	f0 0d       	add	r31, r0
    1348:	38 9f       	mul	r19, r24
    134a:	f0 0d       	add	r31, r0
    134c:	11 24       	eor	r1, r1
    134e:	ee 0f       	add	r30, r30
    1350:	ff 1f       	adc	r31, r31
    1352:	e9 54       	subi	r30, 0x49	; 73
    1354:	f2 4f       	sbci	r31, 0xF2	; 242
    1356:	80 81       	ld	r24, Z
    1358:	91 81       	ldd	r25, Z+1	; 0x01
    135a:	d6 01       	movw	r26, r12
    135c:	13 96       	adiw	r26, 0x03	; 3
    135e:	9c 93       	st	X, r25
    1360:	8e 93       	st	-X, r24
    1362:	12 97       	sbiw	r26, 0x02	; 2
			TCPHeaderOUT->SequenceNumber       = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut);
    1364:	f3 01       	movw	r30, r6
    1366:	64 85       	ldd	r22, Z+12	; 0x0c
    1368:	75 85       	ldd	r23, Z+13	; 0x0d
    136a:	86 85       	ldd	r24, Z+14	; 0x0e
    136c:	97 85       	ldd	r25, Z+15	; 0x0f
    136e:	7a da       	rcall	.-2828   	; 0x864 <SwapEndian_32>
    1370:	d6 01       	movw	r26, r12
    1372:	14 96       	adiw	r26, 0x04	; 4
    1374:	6d 93       	st	X+, r22
    1376:	7d 93       	st	X+, r23
    1378:	8d 93       	st	X+, r24
    137a:	9c 93       	st	X, r25
    137c:	17 97       	sbiw	r26, 0x07	; 7
			TCPHeaderOUT->AcknowledgmentNumber = SwapEndian_32(ConnectionStateTable[CSTableEntry].Info.SequenceNumberIn);
    137e:	f3 01       	movw	r30, r6
    1380:	60 85       	ldd	r22, Z+8	; 0x08
    1382:	71 85       	ldd	r23, Z+9	; 0x09
    1384:	82 85       	ldd	r24, Z+10	; 0x0a
    1386:	93 85       	ldd	r25, Z+11	; 0x0b
    1388:	6d da       	rcall	.-2854   	; 0x864 <SwapEndian_32>
    138a:	d6 01       	movw	r26, r12
    138c:	18 96       	adiw	r26, 0x08	; 8
    138e:	6d 93       	st	X+, r22
    1390:	7d 93       	st	X+, r23
    1392:	8d 93       	st	X+, r24
    1394:	9c 93       	st	X, r25
    1396:	1b 97       	sbiw	r26, 0x0b	; 11
			TCPHeaderOUT->DataOffset           = (sizeof(TCP_Header_t) / sizeof(uint32_t));
			TCPHeaderOUT->WindowSize           = SwapEndian_16(TCP_WINDOW_SIZE);
    1398:	82 e0       	ldi	r24, 0x02	; 2
    139a:	90 e0       	ldi	r25, 0x00	; 0
    139c:	1f 96       	adiw	r26, 0x0f	; 15
    139e:	9c 93       	st	X, r25
    13a0:	8e 93       	st	-X, r24
    13a2:	1e 97       	sbiw	r26, 0x0e	; 14

			TCPHeaderOUT->Flags                = TCP_FLAG_ACK;
    13a4:	80 e1       	ldi	r24, 0x10	; 16
    13a6:	1d 96       	adiw	r26, 0x0d	; 13
    13a8:	8c 93       	st	X, r24
    13aa:	1d 97       	sbiw	r26, 0x0d	; 13
			TCPHeaderOUT->UrgentPointer        = 0;
    13ac:	53 96       	adiw	r26, 0x13	; 19
    13ae:	1c 92       	st	X, r1
    13b0:	1e 92       	st	-X, r1
    13b2:	52 97       	sbiw	r26, 0x12	; 18
			TCPHeaderOUT->Checksum             = 0;
    13b4:	51 96       	adiw	r26, 0x11	; 17
    13b6:	1c 92       	st	X, r1
    13b8:	1e 92       	st	-X, r1
    13ba:	50 97       	sbiw	r26, 0x10	; 16
			TCPHeaderOUT->Reserved             = 0;
    13bc:	80 e5       	ldi	r24, 0x50	; 80
    13be:	1c 96       	adiw	r26, 0x0c	; 12
    13c0:	8c 93       	st	X, r24

			memcpy(TCPDataOUT, ConnectionStateTable[CSTableEntry].Info.Buffer.Data, PacketSize);
    13c2:	2b 81       	ldd	r18, Y+3	; 0x03
    13c4:	3c 81       	ldd	r19, Y+4	; 0x04
    13c6:	2a 5c       	subi	r18, 0xCA	; 202
    13c8:	3f 4f       	sbci	r19, 0xFF	; 255
    13ca:	09 53       	subi	r16, 0x39	; 57
    13cc:	12 4f       	sbci	r17, 0xF2	; 242
    13ce:	c9 01       	movw	r24, r18
    13d0:	b8 01       	movw	r22, r16
    13d2:	a4 01       	movw	r20, r8
    13d4:	0e 94 fa 16 	call	0x2df4	; 0x2df4 <memcpy>

			ConnectionStateTable[CSTableEntry].Info.SequenceNumberOut += PacketSize;
    13d8:	c4 01       	movw	r24, r8
    13da:	a0 e0       	ldi	r26, 0x00	; 0
    13dc:	b0 e0       	ldi	r27, 0x00	; 0
    13de:	f3 01       	movw	r30, r6
    13e0:	24 85       	ldd	r18, Z+12	; 0x0c
    13e2:	35 85       	ldd	r19, Z+13	; 0x0d
    13e4:	46 85       	ldd	r20, Z+14	; 0x0e
    13e6:	57 85       	ldd	r21, Z+15	; 0x0f
    13e8:	82 0f       	add	r24, r18
    13ea:	93 1f       	adc	r25, r19
    13ec:	a4 1f       	adc	r26, r20
    13ee:	b5 1f       	adc	r27, r21
    13f0:	84 87       	std	Z+12, r24	; 0x0c
    13f2:	95 87       	std	Z+13, r25	; 0x0d
    13f4:	a6 87       	std	Z+14, r26	; 0x0e
    13f6:	b7 87       	std	Z+15, r27	; 0x0f

			TCPHeaderOUT->Checksum             = TCP_Checksum16(TCPHeaderOUT, ServerIPAddress,
    13f8:	24 e1       	ldi	r18, 0x14	; 20
    13fa:	30 e0       	ldi	r19, 0x00	; 0
    13fc:	82 0e       	add	r8, r18
    13fe:	93 1e       	adc	r9, r19
    1400:	20 90 b9 01 	lds	r2, 0x01B9
    1404:	30 90 ba 01 	lds	r3, 0x01BA
    1408:	40 90 bb 01 	lds	r4, 0x01BB
    140c:	50 90 bc 01 	lds	r5, 0x01BC
    1410:	04 81       	ldd	r16, Z+4	; 0x04
    1412:	15 81       	ldd	r17, Z+5	; 0x05
    1414:	26 81       	ldd	r18, Z+6	; 0x06
    1416:	37 81       	ldd	r19, Z+7	; 0x07
    1418:	c6 01       	movw	r24, r12
    141a:	b2 01       	movw	r22, r4
    141c:	a1 01       	movw	r20, r2
    141e:	74 01       	movw	r14, r8
    1420:	27 da       	rcall	.-2994   	; 0x870 <TCP_Checksum16>
    1422:	d6 01       	movw	r26, r12
    1424:	51 96       	adiw	r26, 0x11	; 17
    1426:	9c 93       	st	X, r25
    1428:	8e 93       	st	-X, r24
    142a:	50 97       	sbiw	r26, 0x10	; 16
			                                                    (sizeof(TCP_Header_t) + PacketSize));

			PacketSize += sizeof(TCP_Header_t);

			/* Fill out the response IP header */
			IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + PacketSize);
    142c:	84 01       	movw	r16, r8
    142e:	0c 5e       	subi	r16, 0xEC	; 236
    1430:	1f 4f       	sbci	r17, 0xFF	; 255
    1432:	f5 01       	movw	r30, r10
    1434:	12 83       	std	Z+2, r17	; 0x02
    1436:	03 83       	std	Z+3, r16	; 0x03
			IPHeaderOUT->TypeOfService      = 0;
    1438:	11 82       	std	Z+1, r1	; 0x01
			IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
			IPHeaderOUT->Version            = 4;
    143a:	85 e4       	ldi	r24, 0x45	; 69
    143c:	ab 81       	ldd	r26, Y+3	; 0x03
    143e:	bc 81       	ldd	r27, Y+4	; 0x04
    1440:	1e 96       	adiw	r26, 0x0e	; 14
    1442:	8c 93       	st	X, r24
			IPHeaderOUT->Flags              = 0;
			IPHeaderOUT->FragmentOffset     = 0;
    1444:	16 82       	std	Z+6, r1	; 0x06
    1446:	17 82       	std	Z+7, r1	; 0x07
			IPHeaderOUT->Identification     = 0;
    1448:	15 82       	std	Z+5, r1	; 0x05
    144a:	14 82       	std	Z+4, r1	; 0x04
			IPHeaderOUT->HeaderChecksum     = 0;
    144c:	13 86       	std	Z+11, r1	; 0x0b
    144e:	12 86       	std	Z+10, r1	; 0x0a
			IPHeaderOUT->Protocol           = PROTOCOL_TCP;
    1450:	86 e0       	ldi	r24, 0x06	; 6
    1452:	81 87       	std	Z+9, r24	; 0x09
			IPHeaderOUT->TTL                = DEFAULT_TTL;
    1454:	80 e8       	ldi	r24, 0x80	; 128
    1456:	80 87       	std	Z+8, r24	; 0x08
			IPHeaderOUT->SourceAddress      = ServerIPAddress;
    1458:	24 86       	std	Z+12, r2	; 0x0c
    145a:	35 86       	std	Z+13, r3	; 0x0d
    145c:	46 86       	std	Z+14, r4	; 0x0e
    145e:	57 86       	std	Z+15, r5	; 0x0f
			IPHeaderOUT->DestinationAddress = ConnectionStateTable[CSTableEntry].RemoteAddress;
    1460:	f3 01       	movw	r30, r6
    1462:	84 81       	ldd	r24, Z+4	; 0x04
    1464:	95 81       	ldd	r25, Z+5	; 0x05
    1466:	a6 81       	ldd	r26, Z+6	; 0x06
    1468:	b7 81       	ldd	r27, Z+7	; 0x07
    146a:	f5 01       	movw	r30, r10
    146c:	80 8b       	std	Z+16, r24	; 0x10
    146e:	91 8b       	std	Z+17, r25	; 0x11
    1470:	a2 8b       	std	Z+18, r26	; 0x12
    1472:	b3 8b       	std	Z+19, r27	; 0x13

			IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1474:	c5 01       	movw	r24, r10
    1476:	64 e1       	ldi	r22, 0x14	; 20
    1478:	70 e0       	ldi	r23, 0x00	; 0
    147a:	c8 d8       	rcall	.-3696   	; 0x60c <Ethernet_Checksum16>
    147c:	d5 01       	movw	r26, r10
    147e:	1b 96       	adiw	r26, 0x0b	; 11
    1480:	9c 93       	st	X, r25
    1482:	8e 93       	st	-X, r24
    1484:	1a 97       	sbiw	r26, 0x0a	; 10

			PacketSize += sizeof(IP_Header_t);

			/* Fill out the response Ethernet frame header */
			FrameOUTHeader->Source          = ServerMACAddress;
    1486:	ab 81       	ldd	r26, Y+3	; 0x03
    1488:	bc 81       	ldd	r27, Y+4	; 0x04
    148a:	16 96       	adiw	r26, 0x06	; 6
    148c:	e3 eb       	ldi	r30, 0xB3	; 179
    148e:	f1 e0       	ldi	r31, 0x01	; 1
    1490:	86 e0       	ldi	r24, 0x06	; 6
    1492:	01 90       	ld	r0, Z+
    1494:	0d 92       	st	X+, r0
    1496:	81 50       	subi	r24, 0x01	; 1
    1498:	e1 f7       	brne	.-8      	; 0x1492 <TCP_TCPTask+0x2a4>
			FrameOUTHeader->Destination     = (MAC_Address_t){{0x02, 0x00, 0x02, 0x00, 0x02, 0x00}};
    149a:	ab 81       	ldd	r26, Y+3	; 0x03
    149c:	bc 81       	ldd	r27, Y+4	; 0x04
    149e:	eb ec       	ldi	r30, 0xCB	; 203
    14a0:	f1 e0       	ldi	r31, 0x01	; 1
    14a2:	86 e0       	ldi	r24, 0x06	; 6
    14a4:	01 90       	ld	r0, Z+
    14a6:	0d 92       	st	X+, r0
    14a8:	81 50       	subi	r24, 0x01	; 1
    14aa:	e1 f7       	brne	.-8      	; 0x14a4 <TCP_TCPTask+0x2b6>
			FrameOUTHeader->EtherType       = SwapEndian_16(ETHERTYPE_IPV4);
    14ac:	88 e0       	ldi	r24, 0x08	; 8
    14ae:	90 e0       	ldi	r25, 0x00	; 0
    14b0:	eb 81       	ldd	r30, Y+3	; 0x03
    14b2:	fc 81       	ldd	r31, Y+4	; 0x04
    14b4:	95 87       	std	Z+13, r25	; 0x0d
    14b6:	84 87       	std	Z+12, r24	; 0x0c

			PacketSize += sizeof(Ethernet_Frame_Header_t);

			/* Set the response length in the buffer and indicate that a response is ready to be sent */
			FrameOUT->FrameLength           = PacketSize;
    14b8:	e4 52       	subi	r30, 0x24	; 36
    14ba:	fa 4f       	sbci	r31, 0xFA	; 250
    14bc:	02 5f       	subi	r16, 0xF2	; 242
    14be:	1f 4f       	sbci	r17, 0xFF	; 255
    14c0:	11 83       	std	Z+1, r17	; 0x01
    14c2:	00 83       	st	Z, r16

			ConnectionStateTable[CSTableEntry].Info.Buffer.Ready = false;
    14c4:	86 e1       	ldi	r24, 0x16	; 22
    14c6:	92 e0       	ldi	r25, 0x02	; 2
    14c8:	29 81       	ldd	r18, Y+1	; 0x01
    14ca:	3a 81       	ldd	r19, Y+2	; 0x02
    14cc:	28 9f       	mul	r18, r24
    14ce:	f0 01       	movw	r30, r0
    14d0:	29 9f       	mul	r18, r25
    14d2:	f0 0d       	add	r31, r0
    14d4:	38 9f       	mul	r19, r24
    14d6:	f0 0d       	add	r31, r0
    14d8:	11 24       	eor	r1, r1
    14da:	e8 53       	subi	r30, 0x38	; 56
    14dc:	f0 4f       	sbci	r31, 0xF0	; 240
    14de:	10 82       	st	Z, r1

			break;
		}
	}
}
    14e0:	0f 90       	pop	r0
    14e2:	0f 90       	pop	r0
    14e4:	0f 90       	pop	r0
    14e6:	0f 90       	pop	r0
    14e8:	cf 91       	pop	r28
    14ea:	df 91       	pop	r29
    14ec:	1f 91       	pop	r17
    14ee:	0f 91       	pop	r16
    14f0:	ff 90       	pop	r15
    14f2:	ef 90       	pop	r14
    14f4:	df 90       	pop	r13
    14f6:	cf 90       	pop	r12
    14f8:	bf 90       	pop	r11
    14fa:	af 90       	pop	r10
    14fc:	9f 90       	pop	r9
    14fe:	8f 90       	pop	r8
    1500:	7f 90       	pop	r7
    1502:	6f 90       	pop	r6
    1504:	5f 90       	pop	r5
    1506:	4f 90       	pop	r4
    1508:	3f 90       	pop	r3
    150a:	2f 90       	pop	r2
    150c:	08 95       	ret

0000150e <UDP_ProcessUDPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t UDP_ProcessUDPPacket(void* IPHeaderInStart,
                             void* UDPHeaderInStart,
                             void* UDPHeaderOutStart)
{
    150e:	ef 92       	push	r14
    1510:	ff 92       	push	r15
    1512:	0f 93       	push	r16
    1514:	1f 93       	push	r17
    1516:	cf 93       	push	r28
    1518:	df 93       	push	r29
    151a:	7c 01       	movw	r14, r24
    151c:	eb 01       	movw	r28, r22
    151e:	8a 01       	movw	r16, r20
	UDP_Header_t* UDPHeaderIN  = (UDP_Header_t*)UDPHeaderInStart;
	UDP_Header_t* UDPHeaderOUT = (UDP_Header_t*)UDPHeaderOutStart;

	int16_t RetSize = NO_RESPONSE;

	DecodeUDPHeader(UDPHeaderInStart);
    1520:	cb 01       	movw	r24, r22
    1522:	1e d9       	rcall	.-3524   	; 0x760 <DecodeUDPHeader>
    1524:	8a 81       	ldd	r24, Y+2	; 0x02
    1526:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    1528:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    152a:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    152c:	92 2f       	mov	r25, r18

	switch (SwapEndian_16(UDPHeaderIN->DestinationPort))
    152e:	83 34       	cpi	r24, 0x43	; 67
    1530:	91 05       	cpc	r25, r1
    1532:	e9 f4       	brne	.+58     	; 0x156e <UDP_ProcessUDPPacket+0x60>
	{
		case UDP_PORT_DHCP_REQUEST:
			RetSize = DHCP_ProcessDHCPPacket(IPHeaderInStart,
    1534:	be 01       	movw	r22, r28
    1536:	68 5f       	subi	r22, 0xF8	; 248
    1538:	7f 4f       	sbci	r23, 0xFF	; 255
    153a:	a8 01       	movw	r20, r16
    153c:	48 5f       	subi	r20, 0xF8	; 248
    153e:	5f 4f       	sbci	r21, 0xFF	; 255
    1540:	c7 01       	movw	r24, r14
    1542:	1f d0       	rcall	.+62     	; 0x1582 <DHCP_ProcessDHCPPacket>
    1544:	9c 01       	movw	r18, r24
		                                     &((uint8_t*)UDPHeaderOutStart)[sizeof(UDP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    1546:	18 16       	cp	r1, r24
    1548:	19 06       	cpc	r1, r25
    154a:	8c f4       	brge	.+34     	; 0x156e <UDP_ProcessUDPPacket+0x60>
	{
		/* Fill out the response UDP packet header */
		UDPHeaderOUT->SourcePort      = UDPHeaderIN->DestinationPort;
    154c:	8a 81       	ldd	r24, Y+2	; 0x02
    154e:	9b 81       	ldd	r25, Y+3	; 0x03
    1550:	f8 01       	movw	r30, r16
    1552:	91 83       	std	Z+1, r25	; 0x01
    1554:	80 83       	st	Z, r24
		UDPHeaderOUT->DestinationPort = UDPHeaderIN->SourcePort;
    1556:	88 81       	ld	r24, Y
    1558:	99 81       	ldd	r25, Y+1	; 0x01
    155a:	93 83       	std	Z+3, r25	; 0x03
    155c:	82 83       	std	Z+2, r24	; 0x02
		UDPHeaderOUT->Checksum        = 0;
    155e:	17 82       	std	Z+7, r1	; 0x07
    1560:	16 82       	std	Z+6, r1	; 0x06
		UDPHeaderOUT->Length          = SwapEndian_16(sizeof(UDP_Header_t) + RetSize);
    1562:	c9 01       	movw	r24, r18
    1564:	08 96       	adiw	r24, 0x08	; 8
    1566:	94 83       	std	Z+4, r25	; 0x04
    1568:	85 83       	std	Z+5, r24	; 0x05

		/* Return the size of the response so far */
		return (sizeof(UDP_Header_t) + RetSize);
    156a:	9c 01       	movw	r18, r24
    156c:	02 c0       	rjmp	.+4      	; 0x1572 <UDP_ProcessUDPPacket+0x64>
    156e:	20 e0       	ldi	r18, 0x00	; 0
    1570:	30 e0       	ldi	r19, 0x00	; 0
	}

	return NO_RESPONSE;
}
    1572:	c9 01       	movw	r24, r18
    1574:	df 91       	pop	r29
    1576:	cf 91       	pop	r28
    1578:	1f 91       	pop	r17
    157a:	0f 91       	pop	r16
    157c:	ff 90       	pop	r15
    157e:	ef 90       	pop	r14
    1580:	08 95       	ret

00001582 <DHCP_ProcessDHCPPacket>:
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t DHCP_ProcessDHCPPacket(void* IPHeaderInStart,
                               void* DHCPHeaderInStart,
                               void* DHCPHeaderOutStart)
{
    1582:	8f 92       	push	r8
    1584:	9f 92       	push	r9
    1586:	af 92       	push	r10
    1588:	bf 92       	push	r11
    158a:	cf 92       	push	r12
    158c:	df 92       	push	r13
    158e:	ef 92       	push	r14
    1590:	ff 92       	push	r15
    1592:	0f 93       	push	r16
    1594:	1f 93       	push	r17
    1596:	cf 93       	push	r28
    1598:	df 93       	push	r29
    159a:	8b 01       	movw	r16, r22
    159c:	ea 01       	movw	r28, r20
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
    159e:	5c 01       	movw	r10, r24
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
    15a0:	80 ef       	ldi	r24, 0xF0	; 240
    15a2:	88 2e       	mov	r8, r24
    15a4:	91 2c       	mov	r9, r1
    15a6:	86 0e       	add	r8, r22
    15a8:	97 1e       	adc	r9, r23
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));

	DecodeDHCPHeader(DHCPHeaderInStart);
    15aa:	cb 01       	movw	r24, r22
    15ac:	da d8       	rcall	.-3660   	; 0x762 <DecodeDHCPHeader>

	/* Zero out the response DHCP packet, as much of it is legacy and left at 0 */
	memset(DHCPHeaderOUT, 0, sizeof(DHCP_Header_t));
    15ae:	80 ef       	ldi	r24, 0xF0	; 240
    15b0:	fe 01       	movw	r30, r28
    15b2:	11 92       	st	Z+, r1
    15b4:	8a 95       	dec	r24
    15b6:	e9 f7       	brne	.-6      	; 0x15b2 <DHCP_ProcessDHCPPacket+0x30>

	/* Fill out the response DHCP packet */
	DHCPHeaderOUT->HardwareType          = DHCPHeaderIN->HardwareType;
    15b8:	f8 01       	movw	r30, r16
    15ba:	81 81       	ldd	r24, Z+1	; 0x01
    15bc:	89 83       	std	Y+1, r24	; 0x01
	DHCPHeaderOUT->Operation             = DHCP_OP_BOOTREPLY;
    15be:	82 e0       	ldi	r24, 0x02	; 2
    15c0:	88 83       	st	Y, r24
	DHCPHeaderOUT->HardwareAddressLength = DHCPHeaderIN->HardwareAddressLength;
    15c2:	82 81       	ldd	r24, Z+2	; 0x02
    15c4:	8a 83       	std	Y+2, r24	; 0x02
	DHCPHeaderOUT->Hops                  = 0;
    15c6:	1b 82       	std	Y+3, r1	; 0x03
	DHCPHeaderOUT->TransactionID         = DHCPHeaderIN->TransactionID;
    15c8:	84 81       	ldd	r24, Z+4	; 0x04
    15ca:	95 81       	ldd	r25, Z+5	; 0x05
    15cc:	a6 81       	ldd	r26, Z+6	; 0x06
    15ce:	b7 81       	ldd	r27, Z+7	; 0x07
    15d0:	8c 83       	std	Y+4, r24	; 0x04
    15d2:	9d 83       	std	Y+5, r25	; 0x05
    15d4:	ae 83       	std	Y+6, r26	; 0x06
    15d6:	bf 83       	std	Y+7, r27	; 0x07
	DHCPHeaderOUT->ElapsedSeconds        = 0;
    15d8:	19 86       	std	Y+9, r1	; 0x09
    15da:	18 86       	std	Y+8, r1	; 0x08
	DHCPHeaderOUT->Flags                 = DHCPHeaderIN->Flags;
    15dc:	82 85       	ldd	r24, Z+10	; 0x0a
    15de:	93 85       	ldd	r25, Z+11	; 0x0b
    15e0:	9b 87       	std	Y+11, r25	; 0x0b
    15e2:	8a 87       	std	Y+10, r24	; 0x0a
	DHCPHeaderOUT->YourIP                = ClientIPAddress;
    15e4:	c0 90 c7 01 	lds	r12, 0x01C7
    15e8:	d0 90 c8 01 	lds	r13, 0x01C8
    15ec:	e0 90 c9 01 	lds	r14, 0x01C9
    15f0:	f0 90 ca 01 	lds	r15, 0x01CA
    15f4:	c8 8a       	std	Y+16, r12	; 0x10
    15f6:	d9 8a       	std	Y+17, r13	; 0x11
    15f8:	ea 8a       	std	Y+18, r14	; 0x12
    15fa:	fb 8a       	std	Y+19, r15	; 0x13
	memmove(&DHCPHeaderOUT->ClientHardwareAddress, &DHCPHeaderIN->ClientHardwareAddress, sizeof(MAC_Address_t));
    15fc:	04 5e       	subi	r16, 0xE4	; 228
    15fe:	1f 4f       	sbci	r17, 0xFF	; 255
    1600:	ce 01       	movw	r24, r28
    1602:	4c 96       	adiw	r24, 0x1c	; 28
    1604:	b8 01       	movw	r22, r16
    1606:	46 e0       	ldi	r20, 0x06	; 6
    1608:	50 e0       	ldi	r21, 0x00	; 0
    160a:	0e 94 03 17 	call	0x2e06	; 0x2e06 <memmove>
	DHCPHeaderOUT->Cookie                = SwapEndian_32(DHCP_MAGIC_COOKIE);
    160e:	c4 51       	subi	r28, 0x14	; 20
    1610:	df 4f       	sbci	r29, 0xFF	; 255
    1612:	83 e6       	ldi	r24, 0x63	; 99
    1614:	92 e8       	ldi	r25, 0x82	; 130
    1616:	a3 e5       	ldi	r26, 0x53	; 83
    1618:	b3 e6       	ldi	r27, 0x63	; 99
    161a:	88 83       	st	Y, r24
    161c:	99 83       	std	Y+1, r25	; 0x01
    161e:	aa 83       	std	Y+2, r26	; 0x02
    1620:	bb 83       	std	Y+3, r27	; 0x03
    1622:	cc 5e       	subi	r28, 0xEC	; 236
    1624:	d0 40       	sbci	r29, 0x00	; 0

	/* Alter the incoming IP packet header so that the corrected IP source and destinations are used - this means that
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
    1626:	f5 01       	movw	r30, r10
    1628:	c4 86       	std	Z+12, r12	; 0x0c
    162a:	d5 86       	std	Z+13, r13	; 0x0d
    162c:	e6 86       	std	Z+14, r14	; 0x0e
    162e:	f7 86       	std	Z+15, r15	; 0x0f
	IPHeaderIN->DestinationAddress = ServerIPAddress;
    1630:	80 91 b9 01 	lds	r24, 0x01B9
    1634:	90 91 ba 01 	lds	r25, 0x01BA
    1638:	a0 91 bb 01 	lds	r26, 0x01BB
    163c:	b0 91 bc 01 	lds	r27, 0x01BC
    1640:	80 8b       	std	Z+16, r24	; 0x10
    1642:	91 8b       	std	Z+17, r25	; 0x11
    1644:	a2 8b       	std	Z+18, r26	; 0x12
    1646:	b3 8b       	std	Z+19, r27	; 0x13
    1648:	5b c0       	rjmp	.+182    	; 0x1700 <DHCP_ProcessDHCPPacket+0x17e>

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
	{
		/* Find the Message Type DHCP option, to determine the type of DHCP packet */
		if (DHCPOptionsINStart[0] == DHCP_OPTION_MESSAGETYPE)
    164a:	85 33       	cpi	r24, 0x35	; 53
    164c:	09 f0       	breq	.+2      	; 0x1650 <DHCP_ProcessDHCPPacket+0xce>
    164e:	4d c0       	rjmp	.+154    	; 0x16ea <DHCP_ProcessDHCPPacket+0x168>
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
    1650:	94 01       	movw	r18, r8
    1652:	2e 5f       	subi	r18, 0xFE	; 254
    1654:	3f 4f       	sbci	r19, 0xFF	; 255
    1656:	f4 01       	movw	r30, r8
    1658:	82 81       	ldd	r24, Z+2	; 0x02
    165a:	81 30       	cpi	r24, 0x01	; 1
    165c:	19 f0       	breq	.+6      	; 0x1664 <DHCP_ProcessDHCPPacket+0xe2>
    165e:	83 30       	cpi	r24, 0x03	; 3
    1660:	09 f0       	breq	.+2      	; 0x1664 <DHCP_ProcessDHCPPacket+0xe2>
    1662:	48 c0       	rjmp	.+144    	; 0x16f4 <DHCP_ProcessDHCPPacket+0x172>
	IP_Header_t*   IPHeaderIN    = (IP_Header_t*)IPHeaderInStart;
	DHCP_Header_t* DHCPHeaderIN  = (DHCP_Header_t*)DHCPHeaderInStart;
	DHCP_Header_t* DHCPHeaderOUT = (DHCP_Header_t*)DHCPHeaderOutStart;

	uint8_t* DHCPOptionsINStart  = (uint8_t*)(DHCPHeaderInStart  + sizeof(DHCP_Header_t));
	uint8_t* DHCPOptionsOUTStart = (uint8_t*)(DHCPHeaderOutStart + sizeof(DHCP_Header_t));
    1664:	fe 01       	movw	r30, r28
    1666:	e0 51       	subi	r30, 0x10	; 16
    1668:	ff 4f       	sbci	r31, 0xFF	; 255
		{
			if ((DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) || (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_REQUEST))
			{
				/* Fill out the response DHCP packet options for a DHCP OFFER or ACK response */

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_MESSAGETYPE;
    166a:	df 01       	movw	r26, r30
    166c:	85 e3       	ldi	r24, 0x35	; 53
    166e:	8d 93       	st	X+, r24
				*(DHCPOptionsOUTStart++) = 1;
    1670:	81 e0       	ldi	r24, 0x01	; 1
    1672:	81 83       	std	Z+1, r24	; 0x01
    1674:	ed 01       	movw	r28, r26
    1676:	21 96       	adiw	r28, 0x01	; 1
				*(DHCPOptionsOUTStart++) = (DHCPOptionsINStart[2] == DHCP_MESSAGETYPE_DISCOVER) ? DHCP_MESSAGETYPE_OFFER
    1678:	f9 01       	movw	r30, r18
    167a:	80 81       	ld	r24, Z
    167c:	81 30       	cpi	r24, 0x01	; 1
    167e:	11 f0       	breq	.+4      	; 0x1684 <DHCP_ProcessDHCPPacket+0x102>
    1680:	85 e0       	ldi	r24, 0x05	; 5
    1682:	01 c0       	rjmp	.+2      	; 0x1686 <DHCP_ProcessDHCPPacket+0x104>
    1684:	82 e0       	ldi	r24, 0x02	; 2
    1686:	11 96       	adiw	r26, 0x01	; 1
    1688:	8c 93       	st	X, r24
    168a:	fe 01       	movw	r30, r28
    168c:	31 96       	adiw	r30, 0x01	; 1
																								: DHCP_MESSAGETYPE_ACK;

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_SUBNETMASK;
    168e:	81 e0       	ldi	r24, 0x01	; 1
    1690:	89 83       	std	Y+1, r24	; 0x01
    1692:	cf 01       	movw	r24, r30
    1694:	01 96       	adiw	r24, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 4;
    1696:	34 e0       	ldi	r19, 0x04	; 4
    1698:	31 83       	std	Z+1, r19	; 0x01
    169a:	dc 01       	movw	r26, r24
    169c:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    169e:	2f ef       	ldi	r18, 0xFF	; 255
    16a0:	fc 01       	movw	r30, r24
    16a2:	21 83       	std	Z+1, r18	; 0x01
    16a4:	fd 01       	movw	r30, r26
    16a6:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    16a8:	11 96       	adiw	r26, 0x01	; 1
    16aa:	2c 93       	st	X, r18
    16ac:	df 01       	movw	r26, r30
    16ae:	11 96       	adiw	r26, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0xFF;
    16b0:	21 83       	std	Z+1, r18	; 0x01
    16b2:	fd 01       	movw	r30, r26
    16b4:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = 0x00;
    16b6:	11 96       	adiw	r26, 0x01	; 1
    16b8:	1c 92       	st	X, r1
    16ba:	df 01       	movw	r26, r30
    16bc:	11 96       	adiw	r26, 0x01	; 1

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_DHCPSERVER;
    16be:	86 e3       	ldi	r24, 0x36	; 54
    16c0:	81 83       	std	Z+1, r24	; 0x01
    16c2:	fd 01       	movw	r30, r26
    16c4:	31 96       	adiw	r30, 0x01	; 1
				*(DHCPOptionsOUTStart++) = sizeof(IP_Address_t);
    16c6:	11 96       	adiw	r26, 0x01	; 1
    16c8:	3c 93       	st	X, r19
				memcpy(DHCPOptionsOUTStart, &ServerIPAddress, sizeof(IP_Address_t));
    16ca:	80 91 b9 01 	lds	r24, 0x01B9
    16ce:	90 91 ba 01 	lds	r25, 0x01BA
    16d2:	a0 91 bb 01 	lds	r26, 0x01BB
    16d6:	b0 91 bc 01 	lds	r27, 0x01BC
    16da:	81 83       	std	Z+1, r24	; 0x01
    16dc:	92 83       	std	Z+2, r25	; 0x02
    16de:	a3 83       	std	Z+3, r26	; 0x03
    16e0:	b4 83       	std	Z+4, r27	; 0x04
				DHCPOptionsOUTStart     += sizeof(IP_Address_t);

				*(DHCPOptionsOUTStart++) = DHCP_OPTION_END;
    16e2:	25 83       	std	Z+5, r18	; 0x05
    16e4:	20 e0       	ldi	r18, 0x00	; 0
    16e6:	31 e0       	ldi	r19, 0x01	; 1
    16e8:	12 c0       	rjmp	.+36     	; 0x170e <DHCP_ProcessDHCPPacket+0x18c>
				return (sizeof(DHCP_Header_t) + 12 + sizeof(IP_Address_t));
			}
		}

		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
    16ea:	88 23       	and	r24, r24
    16ec:	19 f4       	brne	.+6      	; 0x16f4 <DHCP_ProcessDHCPPacket+0x172>
    16ee:	81 e0       	ldi	r24, 0x01	; 1
    16f0:	90 e0       	ldi	r25, 0x00	; 0
    16f2:	04 c0       	rjmp	.+8      	; 0x16fc <DHCP_ProcessDHCPPacket+0x17a>
    16f4:	f4 01       	movw	r30, r8
    16f6:	81 81       	ldd	r24, Z+1	; 0x01
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	02 96       	adiw	r24, 0x02	; 2
    16fc:	88 0e       	add	r8, r24
    16fe:	99 1e       	adc	r9, r25
	   when the response IP header is generated, it will use the corrected addresses and not the null/broatcast addresses */
	IPHeaderIN->SourceAddress      = ClientIPAddress;
	IPHeaderIN->DestinationAddress = ServerIPAddress;

	/* Process the incoming DHCP packet options */
	while (DHCPOptionsINStart[0] != DHCP_OPTION_END)
    1700:	f4 01       	movw	r30, r8
    1702:	80 81       	ld	r24, Z
    1704:	8f 3f       	cpi	r24, 0xFF	; 255
    1706:	09 f0       	breq	.+2      	; 0x170a <DHCP_ProcessDHCPPacket+0x188>
    1708:	a0 cf       	rjmp	.-192    	; 0x164a <DHCP_ProcessDHCPPacket+0xc8>
    170a:	20 e0       	ldi	r18, 0x00	; 0
    170c:	30 e0       	ldi	r19, 0x00	; 0
		/* Go to the next DHCP option - skip one byte if option is a padding byte, else skip the complete option's size */
		DHCPOptionsINStart += ((DHCPOptionsINStart[0] == DHCP_OPTION_PAD) ? 1 : (DHCPOptionsINStart[1] + 2));
	}

	return NO_RESPONSE;
}
    170e:	c9 01       	movw	r24, r18
    1710:	df 91       	pop	r29
    1712:	cf 91       	pop	r28
    1714:	1f 91       	pop	r17
    1716:	0f 91       	pop	r16
    1718:	ff 90       	pop	r15
    171a:	ef 90       	pop	r14
    171c:	df 90       	pop	r13
    171e:	cf 90       	pop	r12
    1720:	bf 90       	pop	r11
    1722:	af 90       	pop	r10
    1724:	9f 90       	pop	r9
    1726:	8f 90       	pop	r8
    1728:	08 95       	ret

0000172a <ARP_ProcessARPPacket>:
 *
 *  \return The number of bytes written to the out Ethernet frame if any, NO_RESPONSE otherwise
 */
int16_t ARP_ProcessARPPacket(void* InDataStart,
                             void* OutDataStart)
{
    172a:	ef 92       	push	r14
    172c:	ff 92       	push	r15
    172e:	0f 93       	push	r16
    1730:	1f 93       	push	r17
    1732:	cf 93       	push	r28
    1734:	df 93       	push	r29
    1736:	18 2f       	mov	r17, r24
    1738:	09 2f       	mov	r16, r25
    173a:	f6 2e       	mov	r15, r22
    173c:	e7 2e       	mov	r14, r23
	DecodeARPHeader(InDataStart);
    173e:	0c d8       	rcall	.-4072   	; 0x758 <DecodeARPHeader>

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
    1740:	c1 2f       	mov	r28, r17
    1742:	d0 2f       	mov	r29, r16
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1744:	8a 81       	ldd	r24, Y+2	; 0x02
    1746:	9b 81       	ldd	r25, Y+3	; 0x03

				Temp = Data.Bytes[0];
    1748:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    174a:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    174c:	92 2f       	mov	r25, r18
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;

	/* Ensure that the ARP request is a IPv4 request packet */
	if ((SwapEndian_16(ARPHeaderIN->ProtocolType) == ETHERTYPE_IPV4) &&
    174e:	80 50       	subi	r24, 0x00	; 0
    1750:	98 40       	sbci	r25, 0x08	; 8
    1752:	09 f0       	breq	.+2      	; 0x1756 <ARP_ProcessARPPacket+0x2c>
    1754:	5e c0       	rjmp	.+188    	; 0x1812 <ARP_ProcessARPPacket+0xe8>
				{
					uint16_t Word;
					uint8_t  Bytes[2];
				} Data;

				Data.Word = Word;
    1756:	8e 81       	ldd	r24, Y+6	; 0x06
    1758:	9f 81       	ldd	r25, Y+7	; 0x07

				Temp = Data.Bytes[0];
    175a:	28 2f       	mov	r18, r24
				Data.Bytes[0] = Data.Bytes[1];
    175c:	89 2f       	mov	r24, r25
				Data.Bytes[1] = Temp;
    175e:	92 2f       	mov	r25, r18
    1760:	01 97       	sbiw	r24, 0x01	; 1
    1762:	09 f0       	breq	.+2      	; 0x1766 <ARP_ProcessARPPacket+0x3c>
    1764:	56 c0       	rjmp	.+172    	; 0x1812 <ARP_ProcessARPPacket+0xe8>
	    (SwapEndian_16(ARPHeaderIN->Operation) == ARP_OPERATION_REQUEST))
	{
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
    1766:	ce 01       	movw	r24, r28
    1768:	48 96       	adiw	r24, 0x18	; 24
    176a:	69 eb       	ldi	r22, 0xB9	; 185
    176c:	71 e0       	ldi	r23, 0x01	; 1
    176e:	44 e0       	ldi	r20, 0x04	; 4
    1770:	50 e0       	ldi	r21, 0x00	; 0
    1772:	0e 94 ed 16 	call	0x2dda	; 0x2dda <memcmp>
    1776:	00 97       	sbiw	r24, 0x00	; 0
    1778:	59 f0       	breq	.+22     	; 0x1790 <ARP_ProcessARPPacket+0x66>
    177a:	ce 01       	movw	r24, r28
    177c:	42 96       	adiw	r24, 0x12	; 18
    177e:	63 eb       	ldi	r22, 0xB3	; 179
    1780:	71 e0       	ldi	r23, 0x01	; 1
    1782:	46 e0       	ldi	r20, 0x06	; 6
    1784:	50 e0       	ldi	r21, 0x00	; 0
    1786:	0e 94 ed 16 	call	0x2dda	; 0x2dda <memcmp>
    178a:	00 97       	sbiw	r24, 0x00	; 0
    178c:	09 f0       	breq	.+2      	; 0x1790 <ARP_ProcessARPPacket+0x66>
    178e:	41 c0       	rjmp	.+130    	; 0x1812 <ARP_ProcessARPPacket+0xe8>
                             void* OutDataStart)
{
	DecodeARPHeader(InDataStart);

	ARP_Header_t* ARPHeaderIN  = (ARP_Header_t*)InDataStart;
	ARP_Header_t* ARPHeaderOUT = (ARP_Header_t*)OutDataStart;
    1790:	ef 2d       	mov	r30, r15
    1792:	fe 2d       	mov	r31, r14
		/* If the ARP packet is requesting the MAC or IP of the virtual webserver, return the response */
		if (IP_COMPARE(&ARPHeaderIN->TPA, &ServerIPAddress) ||
		    MAC_COMPARE(&ARPHeaderIN->THA, &ServerMACAddress))
		{
			/* Fill out the ARP response header */
			ARPHeaderOUT->HardwareType = ARPHeaderIN->HardwareType;
    1794:	88 81       	ld	r24, Y
    1796:	99 81       	ldd	r25, Y+1	; 0x01
    1798:	91 83       	std	Z+1, r25	; 0x01
    179a:	80 83       	st	Z, r24
			ARPHeaderOUT->ProtocolType = ARPHeaderIN->ProtocolType;
    179c:	8a 81       	ldd	r24, Y+2	; 0x02
    179e:	9b 81       	ldd	r25, Y+3	; 0x03
    17a0:	93 83       	std	Z+3, r25	; 0x03
    17a2:	82 83       	std	Z+2, r24	; 0x02
			ARPHeaderOUT->HLEN         = ARPHeaderIN->HLEN;
    17a4:	8c 81       	ldd	r24, Y+4	; 0x04
    17a6:	84 83       	std	Z+4, r24	; 0x04
			ARPHeaderOUT->PLEN         = ARPHeaderIN->PLEN;
    17a8:	8d 81       	ldd	r24, Y+5	; 0x05
    17aa:	85 83       	std	Z+5, r24	; 0x05
			ARPHeaderOUT->Operation    = SwapEndian_16(ARP_OPERATION_REPLY);
    17ac:	80 e0       	ldi	r24, 0x00	; 0
    17ae:	92 e0       	ldi	r25, 0x02	; 2
    17b0:	97 83       	std	Z+7, r25	; 0x07
    17b2:	86 83       	std	Z+6, r24	; 0x06

			/* Copy over the sender MAC/IP to the target fields for the response */
			ARPHeaderOUT->THA = ARPHeaderIN->SHA;
    17b4:	9f 01       	movw	r18, r30
    17b6:	2e 5e       	subi	r18, 0xEE	; 238
    17b8:	3f 4f       	sbci	r19, 0xFF	; 255
    17ba:	ae 01       	movw	r20, r28
    17bc:	48 5f       	subi	r20, 0xF8	; 248
    17be:	5f 4f       	sbci	r21, 0xFF	; 255
    17c0:	86 e0       	ldi	r24, 0x06	; 6
    17c2:	da 01       	movw	r26, r20
    17c4:	0d 90       	ld	r0, X+
    17c6:	ad 01       	movw	r20, r26
    17c8:	d9 01       	movw	r26, r18
    17ca:	0d 92       	st	X+, r0
    17cc:	9d 01       	movw	r18, r26
    17ce:	81 50       	subi	r24, 0x01	; 1
    17d0:	c1 f7       	brne	.-16     	; 0x17c2 <ARP_ProcessARPPacket+0x98>
			ARPHeaderOUT->TPA = ARPHeaderIN->SPA;
    17d2:	8e 85       	ldd	r24, Y+14	; 0x0e
    17d4:	9f 85       	ldd	r25, Y+15	; 0x0f
    17d6:	a8 89       	ldd	r26, Y+16	; 0x10
    17d8:	b9 89       	ldd	r27, Y+17	; 0x11
    17da:	80 8f       	std	Z+24, r24	; 0x18
    17dc:	91 8f       	std	Z+25, r25	; 0x19
    17de:	a2 8f       	std	Z+26, r26	; 0x1a
    17e0:	b3 8f       	std	Z+27, r27	; 0x1b

			/* Copy over the new sender MAC/IP - MAC and IP addresses of the virtual webserver */
			ARPHeaderOUT->SHA = ServerMACAddress;
    17e2:	ef 01       	movw	r28, r30
    17e4:	28 96       	adiw	r28, 0x08	; 8
    17e6:	a3 eb       	ldi	r26, 0xB3	; 179
    17e8:	b1 e0       	ldi	r27, 0x01	; 1
    17ea:	86 e0       	ldi	r24, 0x06	; 6
    17ec:	0d 90       	ld	r0, X+
    17ee:	09 92       	st	Y+, r0
    17f0:	81 50       	subi	r24, 0x01	; 1
    17f2:	e1 f7       	brne	.-8      	; 0x17ec <ARP_ProcessARPPacket+0xc2>
			ARPHeaderOUT->SPA = ServerIPAddress;
    17f4:	80 91 b9 01 	lds	r24, 0x01B9
    17f8:	90 91 ba 01 	lds	r25, 0x01BA
    17fc:	a0 91 bb 01 	lds	r26, 0x01BB
    1800:	b0 91 bc 01 	lds	r27, 0x01BC
    1804:	86 87       	std	Z+14, r24	; 0x0e
    1806:	97 87       	std	Z+15, r25	; 0x0f
    1808:	a0 8b       	std	Z+16, r26	; 0x10
    180a:	b1 8b       	std	Z+17, r27	; 0x11
    180c:	2c e1       	ldi	r18, 0x1C	; 28
    180e:	30 e0       	ldi	r19, 0x00	; 0
    1810:	02 c0       	rjmp	.+4      	; 0x1816 <ARP_ProcessARPPacket+0xec>

			/* Return the size of the response so far */
			return sizeof(ARP_Header_t);
    1812:	20 e0       	ldi	r18, 0x00	; 0
    1814:	30 e0       	ldi	r19, 0x00	; 0
		}
	}

	return NO_RESPONSE;
}
    1816:	c9 01       	movw	r24, r18
    1818:	df 91       	pop	r29
    181a:	cf 91       	pop	r28
    181c:	1f 91       	pop	r17
    181e:	0f 91       	pop	r16
    1820:	ff 90       	pop	r15
    1822:	ef 90       	pop	r14
    1824:	08 95       	ret

00001826 <IP_ProcessIPPacket>:
 *           next Ethernet packet handler iteration
 */
int16_t IP_ProcessIPPacket(Ethernet_Frame_Info_t* const FrameIN,
                           void* InDataStart,
                           void* OutDataStart)
{
    1826:	af 92       	push	r10
    1828:	bf 92       	push	r11
    182a:	df 92       	push	r13
    182c:	ef 92       	push	r14
    182e:	ff 92       	push	r15
    1830:	0f 93       	push	r16
    1832:	1f 93       	push	r17
    1834:	cf 93       	push	r28
    1836:	df 93       	push	r29
    1838:	5c 01       	movw	r10, r24
    183a:	7b 01       	movw	r14, r22
    183c:	ea 01       	movw	r28, r20
	DecodeIPHeader(InDataStart);
    183e:	cb 01       	movw	r24, r22
    1840:	0e 94 ad 03 	call	0x75a	; 0x75a <DecodeIPHeader>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1844:	f7 01       	movw	r30, r14
    1846:	d0 80       	ld	r13, Z
    1848:	ff e0       	ldi	r31, 0x0F	; 15
    184a:	df 22       	and	r13, r31

	int16_t  RetSize = NO_RESPONSE;

	/* Check to ensure the IP packet is addressed to the virtual webserver's IP or the broadcast IP address */
	if (!(IP_COMPARE(&IPHeaderIN->DestinationAddress, &ServerIPAddress)) &&
    184c:	87 01       	movw	r16, r14
    184e:	00 5f       	subi	r16, 0xF0	; 240
    1850:	1f 4f       	sbci	r17, 0xFF	; 255
    1852:	c8 01       	movw	r24, r16
    1854:	69 eb       	ldi	r22, 0xB9	; 185
    1856:	71 e0       	ldi	r23, 0x01	; 1
    1858:	44 e0       	ldi	r20, 0x04	; 4
    185a:	50 e0       	ldi	r21, 0x00	; 0
    185c:	0e 94 ed 16 	call	0x2dda	; 0x2dda <memcmp>
    1860:	00 97       	sbiw	r24, 0x00	; 0
    1862:	49 f0       	breq	.+18     	; 0x1876 <IP_ProcessIPPacket+0x50>
    1864:	c8 01       	movw	r24, r16
    1866:	63 ec       	ldi	r22, 0xC3	; 195
    1868:	71 e0       	ldi	r23, 0x01	; 1
    186a:	44 e0       	ldi	r20, 0x04	; 4
    186c:	50 e0       	ldi	r21, 0x00	; 0
    186e:	0e 94 ed 16 	call	0x2dda	; 0x2dda <memcmp>
    1872:	00 97       	sbiw	r24, 0x00	; 0
    1874:	71 f4       	brne	.+28     	; 0x1892 <IP_ProcessIPPacket+0x6c>

	IP_Header_t* IPHeaderIN  = (IP_Header_t*)InDataStart;
	IP_Header_t* IPHeaderOUT = (IP_Header_t*)OutDataStart;

	/* Header length is specified in number of longs in the packet header, convert to bytes */
	uint16_t HeaderLengthBytes = (IPHeaderIN->HeaderLength * sizeof(uint32_t));
    1876:	6d 2d       	mov	r22, r13
    1878:	70 e0       	ldi	r23, 0x00	; 0
    187a:	66 0f       	add	r22, r22
    187c:	77 1f       	adc	r23, r23
    187e:	66 0f       	add	r22, r22
    1880:	77 1f       	adc	r23, r23
	{
		return NO_RESPONSE;
	}

	/* Pass off the IP payload to the appropriate protocol processing routine */
	switch (IPHeaderIN->Protocol)
    1882:	f7 01       	movw	r30, r14
    1884:	81 85       	ldd	r24, Z+9	; 0x09
    1886:	86 30       	cpi	r24, 0x06	; 6
    1888:	81 f0       	breq	.+32     	; 0x18aa <IP_ProcessIPPacket+0x84>
    188a:	81 31       	cpi	r24, 0x11	; 17
    188c:	b1 f0       	breq	.+44     	; 0x18ba <IP_ProcessIPPacket+0x94>
    188e:	81 30       	cpi	r24, 0x01	; 1
    1890:	19 f0       	breq	.+6      	; 0x1898 <IP_ProcessIPPacket+0x72>
    1892:	20 e0       	ldi	r18, 0x00	; 0
    1894:	30 e0       	ldi	r19, 0x00	; 0
    1896:	47 c0       	rjmp	.+142    	; 0x1926 <IP_ProcessIPPacket+0x100>
	{
		case PROTOCOL_ICMP:
			RetSize = ICMP_ProcessICMPPacket(FrameIN,
    1898:	6e 0d       	add	r22, r14
    189a:	7f 1d       	adc	r23, r15
    189c:	ae 01       	movw	r20, r28
    189e:	4c 5e       	subi	r20, 0xEC	; 236
    18a0:	5f 4f       	sbci	r21, 0xFF	; 255
    18a2:	c5 01       	movw	r24, r10
    18a4:	0e 94 b2 03 	call	0x764	; 0x764 <ICMP_ProcessICMPPacket>
    18a8:	0f c0       	rjmp	.+30     	; 0x18c8 <IP_ProcessIPPacket+0xa2>
			                                 &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                                 &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_TCP:
			RetSize = TCP_ProcessTCPPacket(InDataStart,
    18aa:	6e 0d       	add	r22, r14
    18ac:	7f 1d       	adc	r23, r15
    18ae:	ae 01       	movw	r20, r28
    18b0:	4c 5e       	subi	r20, 0xEC	; 236
    18b2:	5f 4f       	sbci	r21, 0xFF	; 255
    18b4:	c7 01       	movw	r24, r14
    18b6:	f6 d9       	rcall	.-3092   	; 0xca4 <TCP_ProcessTCPPacket>
    18b8:	07 c0       	rjmp	.+14     	; 0x18c8 <IP_ProcessIPPacket+0xa2>
			                               &((uint8_t*)InDataStart)[HeaderLengthBytes],
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
		case PROTOCOL_UDP:
			RetSize = UDP_ProcessUDPPacket(InDataStart,
    18ba:	6e 0d       	add	r22, r14
    18bc:	7f 1d       	adc	r23, r15
    18be:	ae 01       	movw	r20, r28
    18c0:	4c 5e       	subi	r20, 0xEC	; 236
    18c2:	5f 4f       	sbci	r21, 0xFF	; 255
    18c4:	c7 01       	movw	r24, r14
    18c6:	23 de       	rcall	.-954    	; 0x150e <UDP_ProcessUDPPacket>
    18c8:	9c 01       	movw	r18, r24
			                               &((uint8_t*)OutDataStart)[sizeof(IP_Header_t)]);
			break;
	}

	/* Check to see if the protocol processing routine has filled out a response */
	if (RetSize > 0)
    18ca:	18 16       	cp	r1, r24
    18cc:	19 06       	cpc	r1, r25
    18ce:	5c f5       	brge	.+86     	; 0x1926 <IP_ProcessIPPacket+0x100>
	{
		/* Fill out the response IP packet header */
		IPHeaderOUT->TotalLength        = SwapEndian_16(sizeof(IP_Header_t) + RetSize);
    18d0:	8c 01       	movw	r16, r24
    18d2:	0c 5e       	subi	r16, 0xEC	; 236
    18d4:	1f 4f       	sbci	r17, 0xFF	; 255
    18d6:	1a 83       	std	Y+2, r17	; 0x02
    18d8:	0b 83       	std	Y+3, r16	; 0x03
		IPHeaderOUT->TypeOfService      = 0;
    18da:	19 82       	std	Y+1, r1	; 0x01
		IPHeaderOUT->HeaderLength       = (sizeof(IP_Header_t) / sizeof(uint32_t));
		IPHeaderOUT->Version            = 4;
    18dc:	85 e4       	ldi	r24, 0x45	; 69
    18de:	88 83       	st	Y, r24
		IPHeaderOUT->Flags              = 0;
		IPHeaderOUT->FragmentOffset     = 0;
    18e0:	1e 82       	std	Y+6, r1	; 0x06
    18e2:	1f 82       	std	Y+7, r1	; 0x07
		IPHeaderOUT->Identification     = 0;
    18e4:	1d 82       	std	Y+5, r1	; 0x05
    18e6:	1c 82       	std	Y+4, r1	; 0x04
		IPHeaderOUT->HeaderChecksum     = 0;
    18e8:	1b 86       	std	Y+11, r1	; 0x0b
    18ea:	1a 86       	std	Y+10, r1	; 0x0a
		IPHeaderOUT->Protocol           = IPHeaderIN->Protocol;
    18ec:	f7 01       	movw	r30, r14
    18ee:	81 85       	ldd	r24, Z+9	; 0x09
    18f0:	89 87       	std	Y+9, r24	; 0x09
		IPHeaderOUT->TTL                = DEFAULT_TTL;
    18f2:	80 e8       	ldi	r24, 0x80	; 128
    18f4:	88 87       	std	Y+8, r24	; 0x08
		IPHeaderOUT->SourceAddress      = IPHeaderIN->DestinationAddress;
    18f6:	80 89       	ldd	r24, Z+16	; 0x10
    18f8:	91 89       	ldd	r25, Z+17	; 0x11
    18fa:	a2 89       	ldd	r26, Z+18	; 0x12
    18fc:	b3 89       	ldd	r27, Z+19	; 0x13
    18fe:	8c 87       	std	Y+12, r24	; 0x0c
    1900:	9d 87       	std	Y+13, r25	; 0x0d
    1902:	ae 87       	std	Y+14, r26	; 0x0e
    1904:	bf 87       	std	Y+15, r27	; 0x0f
		IPHeaderOUT->DestinationAddress = IPHeaderIN->SourceAddress;
    1906:	84 85       	ldd	r24, Z+12	; 0x0c
    1908:	95 85       	ldd	r25, Z+13	; 0x0d
    190a:	a6 85       	ldd	r26, Z+14	; 0x0e
    190c:	b7 85       	ldd	r27, Z+15	; 0x0f
    190e:	88 8b       	std	Y+16, r24	; 0x10
    1910:	99 8b       	std	Y+17, r25	; 0x11
    1912:	aa 8b       	std	Y+18, r26	; 0x12
    1914:	bb 8b       	std	Y+19, r27	; 0x13

		IPHeaderOUT->HeaderChecksum     = Ethernet_Checksum16(IPHeaderOUT, sizeof(IP_Header_t));
    1916:	ce 01       	movw	r24, r28
    1918:	64 e1       	ldi	r22, 0x14	; 20
    191a:	70 e0       	ldi	r23, 0x00	; 0
    191c:	0e 94 06 03 	call	0x60c	; 0x60c <Ethernet_Checksum16>
    1920:	9b 87       	std	Y+11, r25	; 0x0b
    1922:	8a 87       	std	Y+10, r24	; 0x0a

		/* Return the size of the response so far */
		return (sizeof(IP_Header_t) + RetSize);
    1924:	98 01       	movw	r18, r16
	}

	return RetSize;
}
    1926:	c9 01       	movw	r24, r18
    1928:	df 91       	pop	r29
    192a:	cf 91       	pop	r28
    192c:	1f 91       	pop	r17
    192e:	0f 91       	pop	r16
    1930:	ff 90       	pop	r15
    1932:	ef 90       	pop	r14
    1934:	df 90       	pop	r13
    1936:	bf 90       	pop	r11
    1938:	af 90       	pop	r10
    193a:	08 95       	ret

0000193c <IsHTTPCommand>:
 */
static bool IsHTTPCommand(uint8_t* RequestHeader,
                          char* Command)
{
	/* Returns true if the non null terminated string in RequestHeader matches the null terminated string Command */
	return (strncmp((char*)RequestHeader, Command, strlen(Command)) == 0);
    193c:	db 01       	movw	r26, r22
    193e:	0d 90       	ld	r0, X+
    1940:	00 20       	and	r0, r0
    1942:	e9 f7       	brne	.-6      	; 0x193e <IsHTTPCommand+0x2>
    1944:	11 97       	sbiw	r26, 0x01	; 1
    1946:	a6 1b       	sub	r26, r22
    1948:	b7 0b       	sbc	r27, r23
    194a:	ad 01       	movw	r20, r26
    194c:	0e 94 14 17 	call	0x2e28	; 0x2e28 <strncmp>
    1950:	9c 01       	movw	r18, r24
    1952:	80 e0       	ldi	r24, 0x00	; 0
    1954:	23 2b       	or	r18, r19
    1956:	09 f4       	brne	.+2      	; 0x195a <IsHTTPCommand+0x1e>
    1958:	81 e0       	ldi	r24, 0x01	; 1
}
    195a:	08 95       	ret

0000195c <Webserver_ApplicationCallback>:
 *  \param[in] ConnectionState  Pointer to a TCP Connection State structure giving connection information
 *  \param[in,out] Buffer       Pointer to the application's send/receive packet buffer
 */
void Webserver_ApplicationCallback(TCP_ConnectionState_t* const ConnectionState,
                                   TCP_ConnectionBuffer_t* const Buffer)
{
    195c:	af 92       	push	r10
    195e:	bf 92       	push	r11
    1960:	cf 92       	push	r12
    1962:	df 92       	push	r13
    1964:	ef 92       	push	r14
    1966:	ff 92       	push	r15
    1968:	0f 93       	push	r16
    196a:	1f 93       	push	r17
    196c:	cf 93       	push	r28
    196e:	df 93       	push	r29
    1970:	5c 01       	movw	r10, r24
    1972:	eb 01       	movw	r28, r22
	char*          BufferDataStr = (char*)Buffer->Data;
    1974:	8b 01       	movw	r16, r22
    1976:	0e 5f       	subi	r16, 0xFE	; 254
    1978:	1f 4f       	sbci	r17, 0xFF	; 255
	static uint8_t PageBlock     = 0;

	/* Check to see if a packet has been received on the HTTP port from a remote host */
	if (TCP_APP_HAS_RECEIVED_PACKET(Buffer))
    197a:	33 e0       	ldi	r19, 0x03	; 3
    197c:	c3 2e       	mov	r12, r19
    197e:	32 e0       	ldi	r19, 0x02	; 2
    1980:	d3 2e       	mov	r13, r19
    1982:	c6 0e       	add	r12, r22
    1984:	d7 1e       	adc	r13, r23
    1986:	f6 01       	movw	r30, r12
    1988:	80 81       	ld	r24, Z
    198a:	88 23       	and	r24, r24
    198c:	09 f4       	brne	.+2      	; 0x1990 <Webserver_ApplicationCallback+0x34>
    198e:	66 c0       	rjmp	.+204    	; 0x1a5c <Webserver_ApplicationCallback+0x100>
    1990:	22 e0       	ldi	r18, 0x02	; 2
    1992:	e2 2e       	mov	r14, r18
    1994:	f2 2e       	mov	r15, r18
    1996:	e6 0e       	add	r14, r22
    1998:	f7 1e       	adc	r15, r23
    199a:	f7 01       	movw	r30, r14
    199c:	80 81       	ld	r24, Z
    199e:	88 23       	and	r24, r24
    19a0:	09 f0       	breq	.+2      	; 0x19a4 <Webserver_ApplicationCallback+0x48>
    19a2:	a7 c0       	rjmp	.+334    	; 0x1af2 <Webserver_ApplicationCallback+0x196>
	{
		if (IsHTTPCommand(Buffer->Data, "GET"))
    19a4:	c8 01       	movw	r24, r16
    19a6:	61 ed       	ldi	r22, 0xD1	; 209
    19a8:	71 e0       	ldi	r23, 0x01	; 1
    19aa:	c8 df       	rcall	.-112    	; 0x193c <IsHTTPCommand>
    19ac:	88 23       	and	r24, r24
    19ae:	f9 f0       	breq	.+62     	; 0x19ee <Webserver_ApplicationCallback+0x92>
		{
			if (IsHTTPCommand(Buffer->Data, "GET / "))
    19b0:	c8 01       	movw	r24, r16
    19b2:	65 ed       	ldi	r22, 0xD5	; 213
    19b4:	71 e0       	ldi	r23, 0x01	; 1
    19b6:	c2 df       	rcall	.-124    	; 0x193c <IsHTTPCommand>
    19b8:	88 23       	and	r24, r24
    19ba:	49 f1       	breq	.+82     	; 0x1a0e <Webserver_ApplicationCallback+0xb2>
			{
				PageBlock = 0;
    19bc:	10 92 b4 0d 	sts	0x0DB4, r1

				/* Copy the HTTP 200 response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    19c0:	c8 01       	movw	r24, r16
    19c2:	60 e3       	ldi	r22, 0x30	; 48
    19c4:	71 e0       	ldi	r23, 0x01	; 1
    19c6:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    19ca:	81 e0       	ldi	r24, 0x01	; 1
    19cc:	f7 01       	movw	r30, r14
    19ce:	80 83       	st	Z, r24
    19d0:	f8 01       	movw	r30, r16
    19d2:	01 90       	ld	r0, Z+
    19d4:	00 20       	and	r0, r0
    19d6:	e9 f7       	brne	.-6      	; 0x19d2 <Webserver_ApplicationCallback+0x76>
    19d8:	31 97       	sbiw	r30, 0x01	; 1
    19da:	e0 1b       	sub	r30, r16
    19dc:	f1 0b       	sbc	r31, r17
    19de:	f9 83       	std	Y+1, r31	; 0x01
    19e0:	e8 83       	st	Y, r30
    19e2:	f6 01       	movw	r30, r12
    19e4:	80 83       	st	Z, r24

				/* Lock the buffer to Device->Host transmissions only while we send the page contents */
				TCP_APP_CAPTURE_BUFFER(Buffer);
    19e6:	cc 5f       	subi	r28, 0xFC	; 252
    19e8:	dd 4f       	sbci	r29, 0xFD	; 253
    19ea:	88 83       	st	Y, r24
    19ec:	82 c0       	rjmp	.+260    	; 0x1af2 <Webserver_ApplicationCallback+0x196>

				/* All data sent, close the connection */
				TCP_APP_CLOSECONNECTION(ConnectionState);
			}
		}
		else if (IsHTTPCommand(Buffer->Data, "HEAD"))
    19ee:	c8 01       	movw	r24, r16
    19f0:	6c ed       	ldi	r22, 0xDC	; 220
    19f2:	71 e0       	ldi	r23, 0x01	; 1
    19f4:	a3 df       	rcall	.-186    	; 0x193c <IsHTTPCommand>
    19f6:	88 23       	and	r24, r24
    19f8:	11 f1       	breq	.+68     	; 0x1a3e <Webserver_ApplicationCallback+0xe2>
		{
			if (IsHTTPCommand(Buffer->Data, "HEAD / "))
    19fa:	c8 01       	movw	r24, r16
    19fc:	61 ee       	ldi	r22, 0xE1	; 225
    19fe:	71 e0       	ldi	r23, 0x01	; 1
    1a00:	9d df       	rcall	.-198    	; 0x193c <IsHTTPCommand>
    1a02:	88 23       	and	r24, r24
    1a04:	21 f0       	breq	.+8      	; 0x1a0e <Webserver_ApplicationCallback+0xb2>
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP200Header);
    1a06:	c8 01       	movw	r24, r16
    1a08:	60 e3       	ldi	r22, 0x30	; 48
    1a0a:	71 e0       	ldi	r23, 0x01	; 1
    1a0c:	03 c0       	rjmp	.+6      	; 0x1a14 <Webserver_ApplicationCallback+0xb8>
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
			}
			else
			{
				/* Copy the HTTP response header into the packet buffer */
				strcpy_P(BufferDataStr, HTTP404Header);
    1a0e:	c8 01       	movw	r24, r16
    1a10:	64 e8       	ldi	r22, 0x84	; 132
    1a12:	71 e0       	ldi	r23, 0x01	; 1
    1a14:	0e 94 ce 16 	call	0x2d9c	; 0x2d9c <strcpy_P>

				/* Send the buffer contents to the host */
				TCP_APP_SEND_BUFFER(Buffer, strlen(BufferDataStr));
    1a18:	81 e0       	ldi	r24, 0x01	; 1
    1a1a:	f7 01       	movw	r30, r14
    1a1c:	80 83       	st	Z, r24
    1a1e:	f8 01       	movw	r30, r16
    1a20:	01 90       	ld	r0, Z+
    1a22:	00 20       	and	r0, r0
    1a24:	e9 f7       	brne	.-6      	; 0x1a20 <Webserver_ApplicationCallback+0xc4>
    1a26:	31 97       	sbiw	r30, 0x01	; 1
    1a28:	e0 1b       	sub	r30, r16
    1a2a:	f1 0b       	sbc	r31, r17
    1a2c:	f9 83       	std	Y+1, r31	; 0x01
    1a2e:	e8 83       	st	Y, r30
    1a30:	f6 01       	movw	r30, r12
    1a32:	80 83       	st	Z, r24
			}

			/* All data sent, close the connection */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1a34:	85 e1       	ldi	r24, 0x15	; 21
    1a36:	92 e0       	ldi	r25, 0x02	; 2
    1a38:	a8 0e       	add	r10, r24
    1a3a:	b9 1e       	adc	r11, r25
    1a3c:	57 c0       	rjmp	.+174    	; 0x1aec <Webserver_ApplicationCallback+0x190>
		}
		else if (IsHTTPCommand(Buffer->Data, "TRACE"))
    1a3e:	c8 01       	movw	r24, r16
    1a40:	69 ee       	ldi	r22, 0xE9	; 233
    1a42:	71 e0       	ldi	r23, 0x01	; 1
    1a44:	7b df       	rcall	.-266    	; 0x193c <IsHTTPCommand>
    1a46:	88 23       	and	r24, r24
    1a48:	21 f0       	breq	.+8      	; 0x1a52 <Webserver_ApplicationCallback+0xf6>
		{
			/* Echo the host's query back to the host */
			TCP_APP_SEND_BUFFER(Buffer, Buffer->Length);
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
    1a4c:	f7 01       	movw	r30, r14
    1a4e:	80 83       	st	Z, r24
    1a50:	ef cf       	rjmp	.-34     	; 0x1a30 <Webserver_ApplicationCallback+0xd4>
			TCP_APP_CLOSECONNECTION(ConnectionState);
		}
		else
		{
			/* Unknown request, just clear the buffer (drop the packet) */
			TCP_APP_CLEAR_BUFFER(Buffer);
    1a52:	f6 01       	movw	r30, r12
    1a54:	10 82       	st	Z, r1
    1a56:	19 82       	std	Y+1, r1	; 0x01
    1a58:	18 82       	st	Y, r1
    1a5a:	4b c0       	rjmp	.+150    	; 0x1af2 <Webserver_ApplicationCallback+0x196>
		}
	}
	else if (TCP_APP_HAVE_CAPTURED_BUFFER(Buffer))
    1a5c:	cc 5f       	subi	r28, 0xFC	; 252
    1a5e:	dd 4f       	sbci	r29, 0xFD	; 253
    1a60:	88 81       	ld	r24, Y
    1a62:	c4 50       	subi	r28, 0x04	; 4
    1a64:	d2 40       	sbci	r29, 0x02	; 2
    1a66:	88 23       	and	r24, r24
    1a68:	09 f4       	brne	.+2      	; 0x1a6c <Webserver_ApplicationCallback+0x110>
    1a6a:	43 c0       	rjmp	.+134    	; 0x1af2 <Webserver_ApplicationCallback+0x196>
    1a6c:	ce 5f       	subi	r28, 0xFE	; 254
    1a6e:	dd 4f       	sbci	r29, 0xFD	; 253
    1a70:	88 81       	ld	r24, Y
    1a72:	c2 50       	subi	r28, 0x02	; 2
    1a74:	d2 40       	sbci	r29, 0x02	; 2
    1a76:	88 23       	and	r24, r24
    1a78:	e1 f1       	breq	.+120    	; 0x1af2 <Webserver_ApplicationCallback+0x196>
	{
		uint16_t RemLength = strlen_P(&HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE]);
    1a7a:	80 91 b4 0d 	lds	r24, 0x0DB4
    1a7e:	c8 2e       	mov	r12, r24
    1a80:	dd 24       	eor	r13, r13
    1a82:	d6 94       	lsr	r13
    1a84:	dc 2c       	mov	r13, r12
    1a86:	cc 24       	eor	r12, r12
    1a88:	d7 94       	ror	r13
    1a8a:	c7 94       	ror	r12
    1a8c:	86 ec       	ldi	r24, 0xC6	; 198
    1a8e:	91 e0       	ldi	r25, 0x01	; 1
    1a90:	c8 0e       	add	r12, r24
    1a92:	d9 1e       	adc	r13, r25
    1a94:	c6 01       	movw	r24, r12
    1a96:	0e 94 d5 16 	call	0x2daa	; 0x2daa <strlen_P>
		uint16_t Length;

		/* Determine the length of the loaded block */
		Length = ((RemLength > HTTP_REPLY_BLOCK_SIZE) ? HTTP_REPLY_BLOCK_SIZE : RemLength);
    1a9a:	7c 01       	movw	r14, r24
    1a9c:	91 e8       	ldi	r25, 0x81	; 129
    1a9e:	e9 16       	cp	r14, r25
    1aa0:	f1 04       	cpc	r15, r1
    1aa2:	18 f0       	brcs	.+6      	; 0x1aaa <Webserver_ApplicationCallback+0x14e>
    1aa4:	80 e8       	ldi	r24, 0x80	; 128
    1aa6:	e8 2e       	mov	r14, r24
    1aa8:	f1 2c       	mov	r15, r1

		/* Copy the next buffer sized block of the page to the packet buffer */
		strncpy_P(BufferDataStr, &HTTPPage[PageBlock * HTTP_REPLY_BLOCK_SIZE], Length);
    1aaa:	c8 01       	movw	r24, r16
    1aac:	b6 01       	movw	r22, r12
    1aae:	a7 01       	movw	r20, r14
    1ab0:	0e 94 de 16 	call	0x2dbc	; 0x2dbc <strncpy_P>

		/* Send the buffer contents to the host */
		TCP_APP_SEND_BUFFER(Buffer, Length);
    1ab4:	ce 5f       	subi	r28, 0xFE	; 254
    1ab6:	dd 4f       	sbci	r29, 0xFD	; 253
    1ab8:	81 e0       	ldi	r24, 0x01	; 1
    1aba:	88 83       	st	Y, r24
    1abc:	c2 50       	subi	r28, 0x02	; 2
    1abe:	d2 40       	sbci	r29, 0x02	; 2
    1ac0:	f9 82       	std	Y+1, r15	; 0x01
    1ac2:	e8 82       	st	Y, r14
    1ac4:	cd 5f       	subi	r28, 0xFD	; 253
    1ac6:	dd 4f       	sbci	r29, 0xFD	; 253
    1ac8:	88 83       	st	Y, r24
    1aca:	c3 50       	subi	r28, 0x03	; 3
    1acc:	d2 40       	sbci	r29, 0x02	; 2

		/* Check to see if the entire page has been sent */
		if (PageBlock++ == (sizeof(HTTPPage) / HTTP_REPLY_BLOCK_SIZE))
    1ace:	80 91 b4 0d 	lds	r24, 0x0DB4
    1ad2:	8f 5f       	subi	r24, 0xFF	; 255
    1ad4:	80 93 b4 0d 	sts	0x0DB4, r24
    1ad8:	81 50       	subi	r24, 0x01	; 1
    1ada:	83 30       	cpi	r24, 0x03	; 3
    1adc:	51 f4       	brne	.+20     	; 0x1af2 <Webserver_ApplicationCallback+0x196>
		{
			/* Unlock the buffer so that the host can fill it with future packets */
			TCP_APP_RELEASE_BUFFER(Buffer);
    1ade:	cc 5f       	subi	r28, 0xFC	; 252
    1ae0:	dd 4f       	sbci	r29, 0xFD	; 253
    1ae2:	18 82       	st	Y, r1

			/* Close the connection to the host */
			TCP_APP_CLOSECONNECTION(ConnectionState);
    1ae4:	e5 e1       	ldi	r30, 0x15	; 21
    1ae6:	f2 e0       	ldi	r31, 0x02	; 2
    1ae8:	ae 0e       	add	r10, r30
    1aea:	bf 1e       	adc	r11, r31
    1aec:	87 e0       	ldi	r24, 0x07	; 7
    1aee:	f5 01       	movw	r30, r10
    1af0:	80 83       	st	Z, r24
		}
	}
}
    1af2:	df 91       	pop	r29
    1af4:	cf 91       	pop	r28
    1af6:	1f 91       	pop	r17
    1af8:	0f 91       	pop	r16
    1afa:	ff 90       	pop	r15
    1afc:	ef 90       	pop	r14
    1afe:	df 90       	pop	r13
    1b00:	cf 90       	pop	r12
    1b02:	bf 90       	pop	r11
    1b04:	af 90       	pop	r10
    1b06:	08 95       	ret

00001b08 <Webserver_Init>:
 *  callback routine for packets sent to the HTTP protocol port.
 */
void Webserver_Init(void)
{
	/* Open the HTTP port in the TCP protocol so that HTTP connections to the device can be established */
	TCP_SetPortState(TCP_PORT_HTTP, TCP_Port_Open, Webserver_ApplicationCallback);
    1b08:	80 e0       	ldi	r24, 0x00	; 0
    1b0a:	90 e5       	ldi	r25, 0x50	; 80
    1b0c:	61 e0       	ldi	r22, 0x01	; 1
    1b0e:	4e ea       	ldi	r20, 0xAE	; 174
    1b10:	5c e0       	ldi	r21, 0x0C	; 12
    1b12:	0c 94 01 04 	jmp	0x802	; 0x802 <TCP_SetPortState>

00001b16 <Endpoint_ConfigureEndpoint_Prv>:
#endif

bool Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
                                    const uint8_t UECFG0XData,
                                    const uint8_t UECFG1XData)
{
    1b16:	38 2f       	mov	r19, r24
    1b18:	28 2f       	mov	r18, r24
    1b1a:	2c c0       	rjmp	.+88     	; 0x1b74 <Endpoint_ConfigureEndpoint_Prv+0x5e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1b1c:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);
		
		if (EPNum == Number)
    1b20:	23 17       	cp	r18, r19
    1b22:	21 f4       	brne	.+8      	; 0x1b2c <Endpoint_ConfigureEndpoint_Prv+0x16>
    1b24:	76 2f       	mov	r23, r22
    1b26:	94 2f       	mov	r25, r20
    1b28:	50 e0       	ldi	r21, 0x00	; 0
    1b2a:	06 c0       	rjmp	.+12     	; 0x1b38 <Endpoint_ConfigureEndpoint_Prv+0x22>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    1b2c:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    1b30:	90 91 ed 00 	lds	r25, 0x00ED
			UEIENXTemp  = UEIENX;
    1b34:	50 91 f0 00 	lds	r21, 0x00F0
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    1b38:	91 ff       	sbrs	r25, 1
    1b3a:	1b c0       	rjmp	.+54     	; 0x1b72 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    1b3c:	80 91 eb 00 	lds	r24, 0x00EB
    1b40:	8e 7f       	andi	r24, 0xFE	; 254
    1b42:	80 93 eb 00 	sts	0x00EB, r24
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    1b46:	80 91 ed 00 	lds	r24, 0x00ED
    1b4a:	8d 7f       	andi	r24, 0xFD	; 253
    1b4c:	80 93 ed 00 	sts	0x00ED, r24
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    1b50:	80 91 eb 00 	lds	r24, 0x00EB
    1b54:	81 60       	ori	r24, 0x01	; 1
    1b56:	80 93 eb 00 	sts	0x00EB, r24

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    1b5a:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    1b5e:	90 93 ed 00 	sts	0x00ED, r25
		UEIENX  = UEIENXTemp;
    1b62:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    1b66:	80 91 ee 00 	lds	r24, 0x00EE
			
		if (!(Endpoint_IsConfigured()))
    1b6a:	87 fd       	sbrc	r24, 7
    1b6c:	02 c0       	rjmp	.+4      	; 0x1b72 <Endpoint_ConfigureEndpoint_Prv+0x5c>
    1b6e:	80 e0       	ldi	r24, 0x00	; 0
    1b70:	08 95       	ret
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else	
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    1b72:	2f 5f       	subi	r18, 0xFF	; 255
    1b74:	27 30       	cpi	r18, 0x07	; 7
    1b76:	90 f2       	brcs	.-92     	; 0x1b1c <Endpoint_ConfigureEndpoint_Prv+0x6>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    1b78:	30 93 e9 00 	sts	0x00E9, r19
    1b7c:	81 e0       	ldi	r24, 0x01	; 1
	}
	
	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    1b7e:	08 95       	ret

00001b80 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    1b80:	80 91 01 14 	lds	r24, 0x1401
    1b84:	88 23       	and	r24, r24
    1b86:	9c f4       	brge	.+38     	; 0x1bae <Endpoint_ClearStatusStage+0x2e>
    1b88:	04 c0       	rjmp	.+8      	; 0x1b92 <Endpoint_ClearStatusStage+0x12>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1b8a:	80 91 00 14 	lds	r24, 0x1400
    1b8e:	88 23       	and	r24, r24
    1b90:	b9 f0       	breq	.+46     	; 0x1bc0 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1b92:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    1b96:	82 ff       	sbrs	r24, 2
    1b98:	f8 cf       	rjmp	.-16     	; 0x1b8a <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1b9a:	80 91 e8 00 	lds	r24, 0x00E8
    1b9e:	8b 77       	andi	r24, 0x7B	; 123
    1ba0:	80 93 e8 00 	sts	0x00E8, r24
    1ba4:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    1ba6:	80 91 00 14 	lds	r24, 0x1400
    1baa:	88 23       	and	r24, r24
    1bac:	49 f0       	breq	.+18     	; 0x1bc0 <Endpoint_ClearStatusStage+0x40>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1bae:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    1bb2:	80 ff       	sbrs	r24, 0
    1bb4:	f8 cf       	rjmp	.-16     	; 0x1ba6 <Endpoint_ClearStatusStage+0x26>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1bb6:	80 91 e8 00 	lds	r24, 0x00E8
    1bba:	8e 77       	andi	r24, 0x7E	; 126
    1bbc:	80 93 e8 00 	sts	0x00E8, r24
    1bc0:	08 95       	ret

00001bc2 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    1bc2:	40 91 e4 00 	lds	r20, 0x00E4
    1bc6:	50 91 e5 00 	lds	r21, 0x00E5
    1bca:	24 e6       	ldi	r18, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    1bcc:	80 91 ec 00 	lds	r24, 0x00EC
    1bd0:	80 ff       	sbrs	r24, 0
    1bd2:	24 c0       	rjmp	.+72     	; 0x1c1c <Endpoint_WaitUntilReady+0x5a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1bd4:	80 91 e8 00 	lds	r24, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    1bd8:	80 fd       	sbrc	r24, 0
    1bda:	1e c0       	rjmp	.+60     	; 0x1c18 <Endpoint_WaitUntilReady+0x56>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}
		
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1bdc:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1be0:	88 23       	and	r24, r24
    1be2:	11 f4       	brne	.+4      	; 0x1be8 <Endpoint_WaitUntilReady+0x26>
    1be4:	82 e0       	ldi	r24, 0x02	; 2
    1be6:	08 95       	ret
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1be8:	85 30       	cpi	r24, 0x05	; 5
    1bea:	11 f4       	brne	.+4      	; 0x1bf0 <Endpoint_WaitUntilReady+0x2e>
    1bec:	83 e0       	ldi	r24, 0x03	; 3
    1bee:	08 95       	ret
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    1bf0:	80 91 eb 00 	lds	r24, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    1bf4:	85 ff       	sbrs	r24, 5
    1bf6:	02 c0       	rjmp	.+4      	; 0x1bfc <Endpoint_WaitUntilReady+0x3a>
    1bf8:	81 e0       	ldi	r24, 0x01	; 1
    1bfa:	08 95       	ret
    1bfc:	80 91 e4 00 	lds	r24, 0x00E4
    1c00:	90 91 e5 00 	lds	r25, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    1c04:	84 17       	cp	r24, r20
    1c06:	95 07       	cpc	r25, r21
    1c08:	09 f3       	breq	.-62     	; 0x1bcc <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    1c0a:	22 23       	and	r18, r18
    1c0c:	11 f4       	brne	.+4      	; 0x1c12 <Endpoint_WaitUntilReady+0x50>
    1c0e:	84 e0       	ldi	r24, 0x04	; 4
    1c10:	08 95       	ret
    1c12:	21 50       	subi	r18, 0x01	; 1
    1c14:	ac 01       	movw	r20, r24
    1c16:	da cf       	rjmp	.-76     	; 0x1bcc <Endpoint_WaitUntilReady+0xa>
    1c18:	80 e0       	ldi	r24, 0x00	; 0
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    1c1a:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1c1c:	80 91 e8 00 	lds	r24, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    1c20:	82 ff       	sbrs	r24, 2
    1c22:	dc cf       	rjmp	.-72     	; 0x1bdc <Endpoint_WaitUntilReady+0x1a>
    1c24:	f9 cf       	rjmp	.-14     	; 0x1c18 <Endpoint_WaitUntilReady+0x56>

00001c26 <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    1c26:	ef 92       	push	r14
    1c28:	ff 92       	push	r15
    1c2a:	0f 93       	push	r16
    1c2c:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
	#endif

	USB_INT_DisableAllInterrupts();
    1c2e:	4d d0       	rcall	.+154    	; 0x1cca <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    1c30:	54 d0       	rcall	.+168    	; 0x1cda <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    1c32:	08 ed       	ldi	r16, 0xD8	; 216
    1c34:	10 e0       	ldi	r17, 0x00	; 0
    1c36:	f8 01       	movw	r30, r16
    1c38:	80 81       	ld	r24, Z
    1c3a:	8f 77       	andi	r24, 0x7F	; 127
    1c3c:	80 83       	st	Z, r24
				USBCON |=  (1 << USBE);
    1c3e:	80 81       	ld	r24, Z
    1c40:	80 68       	ori	r24, 0x80	; 128
    1c42:	80 83       	st	Z, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1c44:	80 81       	ld	r24, Z
    1c46:	8f 7d       	andi	r24, 0xDF	; 223
    1c48:	80 83       	st	Z, r24

	if (USB_CurrentMode == USB_MODE_Device)
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    1c4a:	e7 ed       	ldi	r30, 0xD7	; 215
    1c4c:	f0 e0       	ldi	r31, 0x00	; 0
    1c4e:	80 81       	ld	r24, Z
    1c50:	80 68       	ori	r24, 0x80	; 128
    1c52:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1c54:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    1c56:	10 92 00 14 	sts	0x1400, r1
	USB_Device_ConfigurationNumber  = 0;
    1c5a:	10 92 fc 13 	sts	0x13FC, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    1c5e:	10 92 fe 13 	sts	0x13FE, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    1c62:	10 92 fd 13 	sts	0x13FD, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    1c66:	80 ee       	ldi	r24, 0xE0	; 224
    1c68:	e8 2e       	mov	r14, r24
    1c6a:	f1 2c       	mov	r15, r1
    1c6c:	f7 01       	movw	r30, r14
    1c6e:	80 81       	ld	r24, Z
    1c70:	8b 7f       	andi	r24, 0xFB	; 251
    1c72:	80 83       	st	Z, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    1c74:	f8 01       	movw	r30, r16
    1c76:	80 81       	ld	r24, Z
    1c78:	81 60       	ori	r24, 0x01	; 1
    1c7a:	80 83       	st	Z, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    1c7c:	80 e0       	ldi	r24, 0x00	; 0
    1c7e:	60 e0       	ldi	r22, 0x00	; 0
    1c80:	42 e0       	ldi	r20, 0x02	; 2
    1c82:	49 df       	rcall	.-366    	; 0x1b16 <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1c84:	e1 ee       	ldi	r30, 0xE1	; 225
    1c86:	f0 e0       	ldi	r31, 0x00	; 0
    1c88:	80 81       	ld	r24, Z
    1c8a:	8e 7f       	andi	r24, 0xFE	; 254
    1c8c:	80 83       	st	Z, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1c8e:	e2 ee       	ldi	r30, 0xE2	; 226
    1c90:	f0 e0       	ldi	r31, 0x00	; 0
    1c92:	80 81       	ld	r24, Z
    1c94:	81 60       	ori	r24, 0x01	; 1
    1c96:	80 83       	st	Z, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    1c98:	80 81       	ld	r24, Z
    1c9a:	88 60       	ori	r24, 0x08	; 8
    1c9c:	80 83       	st	Z, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    1c9e:	f7 01       	movw	r30, r14
    1ca0:	80 81       	ld	r24, Z
    1ca2:	8e 7f       	andi	r24, 0xFE	; 254
    1ca4:	80 83       	st	Z, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON  |=  (1 << OTGPADE);
    1ca6:	f8 01       	movw	r30, r16
    1ca8:	80 81       	ld	r24, Z
    1caa:	80 61       	ori	r24, 0x10	; 16
    1cac:	80 83       	st	Z, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    1cae:	1f 91       	pop	r17
    1cb0:	0f 91       	pop	r16
    1cb2:	ff 90       	pop	r15
    1cb4:	ef 90       	pop	r14
    1cb6:	08 95       	ret

00001cb8 <USB_Init>:

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
    1cb8:	e7 ed       	ldi	r30, 0xD7	; 215
    1cba:	f0 e0       	ldi	r31, 0x00	; 0
    1cbc:	80 81       	ld	r24, Z
    1cbe:	81 60       	ori	r24, 0x01	; 1
    1cc0:	80 83       	st	Z, r24
		UHWCON &= ~(1 << UIDE);
		USB_CurrentMode = Mode;
	}
	#endif

	USB_IsInitialized = true;
    1cc2:	81 e0       	ldi	r24, 0x01	; 1
    1cc4:	80 93 ff 13 	sts	0x13FF, r24

	USB_ResetInterface();
}
    1cc8:	ae cf       	rjmp	.-164    	; 0x1c26 <USB_ResetInterface>

00001cca <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    1cca:	e8 ed       	ldi	r30, 0xD8	; 216
    1ccc:	f0 e0       	ldi	r31, 0x00	; 0
    1cce:	80 81       	ld	r24, Z
    1cd0:	8c 7f       	andi	r24, 0xFC	; 252
    1cd2:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    1cd4:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    1cd8:	08 95       	ret

00001cda <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    1cda:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    1cde:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    1ce2:	08 95       	ret

00001ce4 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    1ce4:	1f 92       	push	r1
    1ce6:	0f 92       	push	r0
    1ce8:	0f b6       	in	r0, 0x3f	; 63
    1cea:	0f 92       	push	r0
    1cec:	0b b6       	in	r0, 0x3b	; 59
    1cee:	0f 92       	push	r0
    1cf0:	11 24       	eor	r1, r1
    1cf2:	2f 93       	push	r18
    1cf4:	3f 93       	push	r19
    1cf6:	4f 93       	push	r20
    1cf8:	5f 93       	push	r21
    1cfa:	6f 93       	push	r22
    1cfc:	7f 93       	push	r23
    1cfe:	8f 93       	push	r24
    1d00:	9f 93       	push	r25
    1d02:	af 93       	push	r26
    1d04:	bf 93       	push	r27
    1d06:	ef 93       	push	r30
    1d08:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    1d0a:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    1d0e:	82 ff       	sbrs	r24, 2
    1d10:	0a c0       	rjmp	.+20     	; 0x1d26 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    1d12:	80 91 e2 00 	lds	r24, 0x00E2
    1d16:	82 ff       	sbrs	r24, 2
    1d18:	06 c0       	rjmp	.+12     	; 0x1d26 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    1d1a:	80 91 e1 00 	lds	r24, 0x00E1
    1d1e:	8b 7f       	andi	r24, 0xFB	; 251
    1d20:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    1d24:	bb d3       	rcall	.+1910   	; 0x249c <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    1d26:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    1d2a:	80 ff       	sbrs	r24, 0
    1d2c:	1f c0       	rjmp	.+62     	; 0x1d6c <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    1d2e:	80 91 d8 00 	lds	r24, 0x00D8
    1d32:	80 ff       	sbrs	r24, 0
    1d34:	1b c0       	rjmp	.+54     	; 0x1d6c <__vector_10+0x88>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    1d36:	80 91 da 00 	lds	r24, 0x00DA
    1d3a:	8e 7f       	andi	r24, 0xFE	; 254
    1d3c:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    1d40:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    1d44:	80 ff       	sbrs	r24, 0
    1d46:	0d c0       	rjmp	.+26     	; 0x1d62 <__vector_10+0x7e>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1d48:	8c e0       	ldi	r24, 0x0C	; 12
    1d4a:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1d4c:	8e e0       	ldi	r24, 0x0E	; 14
    1d4e:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    1d50:	09 b4       	in	r0, 0x29	; 41
    1d52:	00 fe       	sbrs	r0, 0
    1d54:	fd cf       	rjmp	.-6      	; 0x1d50 <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    1d56:	81 e0       	ldi	r24, 0x01	; 1
    1d58:	80 93 00 14 	sts	0x1400, r24
			EVENT_USB_Device_Connect();
    1d5c:	0e 94 30 02 	call	0x460	; 0x460 <EVENT_USB_Device_Connect>
    1d60:	05 c0       	rjmp	.+10     	; 0x1d6c <__vector_10+0x88>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1d62:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    1d64:	10 92 00 14 	sts	0x1400, r1
			EVENT_USB_Device_Disconnect();
    1d68:	0e 94 35 02 	call	0x46a	; 0x46a <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    1d6c:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    1d70:	80 ff       	sbrs	r24, 0
    1d72:	18 c0       	rjmp	.+48     	; 0x1da4 <__vector_10+0xc0>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    1d74:	80 91 e2 00 	lds	r24, 0x00E2
    1d78:	80 ff       	sbrs	r24, 0
    1d7a:	14 c0       	rjmp	.+40     	; 0x1da4 <__vector_10+0xc0>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1d7c:	80 91 e2 00 	lds	r24, 0x00E2
    1d80:	8e 7f       	andi	r24, 0xFE	; 254
    1d82:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1d86:	80 91 e2 00 	lds	r24, 0x00E2
    1d8a:	80 61       	ori	r24, 0x10	; 16
    1d8c:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
    1d90:	80 91 d8 00 	lds	r24, 0x00D8
    1d94:	80 62       	ori	r24, 0x20	; 32
    1d96:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    1d9a:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    1d9c:	85 e0       	ldi	r24, 0x05	; 5
    1d9e:	80 93 00 14 	sts	0x1400, r24
		EVENT_USB_Device_Suspend();
    1da2:	7c d3       	rcall	.+1784   	; 0x249c <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    1da4:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    1da8:	84 ff       	sbrs	r24, 4
    1daa:	2d c0       	rjmp	.+90     	; 0x1e06 <__vector_10+0x122>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    1dac:	80 91 e2 00 	lds	r24, 0x00E2
    1db0:	84 ff       	sbrs	r24, 4
    1db2:	29 c0       	rjmp	.+82     	; 0x1e06 <__vector_10+0x122>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    1db4:	8c e0       	ldi	r24, 0x0C	; 12
    1db6:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    1db8:	8e e0       	ldi	r24, 0x0E	; 14
    1dba:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    1dbc:	09 b4       	in	r0, 0x29	; 41
    1dbe:	00 fe       	sbrs	r0, 0
    1dc0:	fd cf       	rjmp	.-6      	; 0x1dbc <__vector_10+0xd8>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
    1dc2:	80 91 d8 00 	lds	r24, 0x00D8
    1dc6:	8f 7d       	andi	r24, 0xDF	; 223
    1dc8:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    1dcc:	80 91 e1 00 	lds	r24, 0x00E1
    1dd0:	8f 7e       	andi	r24, 0xEF	; 239
    1dd2:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    1dd6:	80 91 e2 00 	lds	r24, 0x00E2
    1dda:	8f 7e       	andi	r24, 0xEF	; 239
    1ddc:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    1de0:	80 91 e2 00 	lds	r24, 0x00E2
    1de4:	81 60       	ori	r24, 0x01	; 1
    1de6:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    1dea:	80 91 fc 13 	lds	r24, 0x13FC
    1dee:	88 23       	and	r24, r24
    1df0:	31 f4       	brne	.+12     	; 0x1dfe <__vector_10+0x11a>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    1df2:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    1df6:	87 fd       	sbrc	r24, 7
    1df8:	02 c0       	rjmp	.+4      	; 0x1dfe <__vector_10+0x11a>
    1dfa:	81 e0       	ldi	r24, 0x01	; 1
    1dfc:	01 c0       	rjmp	.+2      	; 0x1e00 <__vector_10+0x11c>
    1dfe:	84 e0       	ldi	r24, 0x04	; 4
    1e00:	80 93 00 14 	sts	0x1400, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    1e04:	4b d3       	rcall	.+1686   	; 0x249c <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    1e06:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    1e0a:	83 ff       	sbrs	r24, 3
    1e0c:	22 c0       	rjmp	.+68     	; 0x1e52 <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    1e0e:	80 91 e2 00 	lds	r24, 0x00E2
    1e12:	83 ff       	sbrs	r24, 3
    1e14:	1e c0       	rjmp	.+60     	; 0x1e52 <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    1e16:	80 91 e1 00 	lds	r24, 0x00E1
    1e1a:	87 7f       	andi	r24, 0xF7	; 247
    1e1c:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    1e20:	82 e0       	ldi	r24, 0x02	; 2
    1e22:	80 93 00 14 	sts	0x1400, r24
		USB_Device_ConfigurationNumber = 0;
    1e26:	10 92 fc 13 	sts	0x13FC, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    1e2a:	80 91 e1 00 	lds	r24, 0x00E1
    1e2e:	8e 7f       	andi	r24, 0xFE	; 254
    1e30:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    1e34:	80 91 e2 00 	lds	r24, 0x00E2
    1e38:	8e 7f       	andi	r24, 0xFE	; 254
    1e3a:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    1e3e:	80 91 e2 00 	lds	r24, 0x00E2
    1e42:	80 61       	ori	r24, 0x10	; 16
    1e44:	80 93 e2 00 	sts	0x00E2, r24
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    1e48:	80 e0       	ldi	r24, 0x00	; 0
    1e4a:	60 e0       	ldi	r22, 0x00	; 0
    1e4c:	42 e0       	ldi	r20, 0x02	; 2
    1e4e:	63 de       	rcall	.-826    	; 0x1b16 <Endpoint_ConfigureEndpoint_Prv>

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    1e50:	25 d3       	rcall	.+1610   	; 0x249c <USB_Event_Stub>
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    1e52:	ff 91       	pop	r31
    1e54:	ef 91       	pop	r30
    1e56:	bf 91       	pop	r27
    1e58:	af 91       	pop	r26
    1e5a:	9f 91       	pop	r25
    1e5c:	8f 91       	pop	r24
    1e5e:	7f 91       	pop	r23
    1e60:	6f 91       	pop	r22
    1e62:	5f 91       	pop	r21
    1e64:	4f 91       	pop	r20
    1e66:	3f 91       	pop	r19
    1e68:	2f 91       	pop	r18
    1e6a:	0f 90       	pop	r0
    1e6c:	0b be       	out	0x3b, r0	; 59
    1e6e:	0f 90       	pop	r0
    1e70:	0f be       	out	0x3f, r0	; 63
    1e72:	0f 90       	pop	r0
    1e74:	1f 90       	pop	r1
    1e76:	18 95       	reti

00001e78 <Endpoint_Write_Control_Stream_LE>:
    1e78:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1e7a:	40 91 07 14 	lds	r20, 0x1407
    1e7e:	50 91 08 14 	lds	r21, 0x1408
    1e82:	46 17       	cp	r20, r22
    1e84:	57 07       	cpc	r21, r23
    1e86:	18 f4       	brcc	.+6      	; 0x1e8e <Endpoint_Write_Control_Stream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1e88:	f9 01       	movw	r30, r18
    1e8a:	90 e0       	ldi	r25, 0x00	; 0
    1e8c:	3d c0       	rjmp	.+122    	; 0x1f08 <Endpoint_Write_Control_Stream_LE+0x90>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1e8e:	61 15       	cp	r22, r1
    1e90:	71 05       	cpc	r23, r1
    1e92:	11 f0       	breq	.+4      	; 0x1e98 <Endpoint_Write_Control_Stream_LE+0x20>
    1e94:	ab 01       	movw	r20, r22
    1e96:	f8 cf       	rjmp	.-16     	; 0x1e88 <Endpoint_Write_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1e98:	80 91 e8 00 	lds	r24, 0x00E8
    1e9c:	8e 77       	andi	r24, 0x7E	; 126
    1e9e:	80 93 e8 00 	sts	0x00E8, r24
    1ea2:	40 e0       	ldi	r20, 0x00	; 0
    1ea4:	50 e0       	ldi	r21, 0x00	; 0
    1ea6:	f0 cf       	rjmp	.-32     	; 0x1e88 <Endpoint_Write_Control_Stream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1ea8:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1eac:	88 23       	and	r24, r24
    1eae:	f1 f1       	breq	.+124    	; 0x1f2c <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1eb0:	85 30       	cpi	r24, 0x05	; 5
    1eb2:	f1 f1       	breq	.+124    	; 0x1f30 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1eb4:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1eb8:	83 ff       	sbrs	r24, 3
    1eba:	02 c0       	rjmp	.+4      	; 0x1ec0 <Endpoint_Write_Control_Stream_LE+0x48>
    1ebc:	81 e0       	ldi	r24, 0x01	; 1
    1ebe:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1ec0:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    1ec4:	82 fd       	sbrc	r24, 2
    1ec6:	2c c0       	rjmp	.+88     	; 0x1f20 <Endpoint_Write_Control_Stream_LE+0xa8>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1ec8:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    1ecc:	80 ff       	sbrs	r24, 0
    1ece:	1c c0       	rjmp	.+56     	; 0x1f08 <Endpoint_Write_Control_Stream_LE+0x90>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    1ed0:	20 91 f2 00 	lds	r18, 0x00F2
    1ed4:	30 91 f3 00 	lds	r19, 0x00F3
    1ed8:	07 c0       	rjmp	.+14     	; 0x1ee8 <Endpoint_Write_Control_Stream_LE+0x70>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1eda:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    1edc:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    1ee0:	41 50       	subi	r20, 0x01	; 1
    1ee2:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    1ee4:	2f 5f       	subi	r18, 0xFF	; 255
    1ee6:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    1ee8:	41 15       	cp	r20, r1
    1eea:	51 05       	cpc	r21, r1
    1eec:	19 f0       	breq	.+6      	; 0x1ef4 <Endpoint_Write_Control_Stream_LE+0x7c>
    1eee:	28 30       	cpi	r18, 0x08	; 8
    1ef0:	31 05       	cpc	r19, r1
    1ef2:	98 f3       	brcs	.-26     	; 0x1eda <Endpoint_Write_Control_Stream_LE+0x62>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    1ef4:	90 e0       	ldi	r25, 0x00	; 0
    1ef6:	28 30       	cpi	r18, 0x08	; 8
    1ef8:	31 05       	cpc	r19, r1
    1efa:	09 f4       	brne	.+2      	; 0x1efe <Endpoint_Write_Control_Stream_LE+0x86>
    1efc:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1efe:	80 91 e8 00 	lds	r24, 0x00E8
    1f02:	8e 77       	andi	r24, 0x7E	; 126
    1f04:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    1f08:	41 15       	cp	r20, r1
    1f0a:	51 05       	cpc	r21, r1
    1f0c:	69 f6       	brne	.-102    	; 0x1ea8 <Endpoint_Write_Control_Stream_LE+0x30>
    1f0e:	99 23       	and	r25, r25
    1f10:	59 f6       	brne	.-106    	; 0x1ea8 <Endpoint_Write_Control_Stream_LE+0x30>
    1f12:	06 c0       	rjmp	.+12     	; 0x1f20 <Endpoint_Write_Control_Stream_LE+0xa8>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1f14:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1f18:	88 23       	and	r24, r24
    1f1a:	41 f0       	breq	.+16     	; 0x1f2c <Endpoint_Write_Control_Stream_LE+0xb4>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1f1c:	85 30       	cpi	r24, 0x05	; 5
    1f1e:	41 f0       	breq	.+16     	; 0x1f30 <Endpoint_Write_Control_Stream_LE+0xb8>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1f20:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    1f24:	82 ff       	sbrs	r24, 2
    1f26:	f6 cf       	rjmp	.-20     	; 0x1f14 <Endpoint_Write_Control_Stream_LE+0x9c>
    1f28:	80 e0       	ldi	r24, 0x00	; 0
    1f2a:	08 95       	ret
    1f2c:	82 e0       	ldi	r24, 0x02	; 2
    1f2e:	08 95       	ret
    1f30:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1f32:	08 95       	ret

00001f34 <Endpoint_Read_Control_Stream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
    1f34:	9c 01       	movw	r18, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    1f36:	61 15       	cp	r22, r1
    1f38:	71 05       	cpc	r23, r1
    1f3a:	29 f4       	brne	.+10     	; 0x1f46 <Endpoint_Read_Control_Stream_LE+0x12>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1f3c:	80 91 e8 00 	lds	r24, 0x00E8
    1f40:	8b 77       	andi	r24, 0x7B	; 123
    1f42:	80 93 e8 00 	sts	0x00E8, r24
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1f46:	f9 01       	movw	r30, r18
    1f48:	22 c0       	rjmp	.+68     	; 0x1f8e <Endpoint_Read_Control_Stream_LE+0x5a>
	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1f4a:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1f4e:	88 23       	and	r24, r24
    1f50:	71 f1       	breq	.+92     	; 0x1fae <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1f52:	85 30       	cpi	r24, 0x05	; 5
    1f54:	71 f1       	breq	.+92     	; 0x1fb2 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1f56:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1f5a:	83 ff       	sbrs	r24, 3
    1f5c:	02 c0       	rjmp	.+4      	; 0x1f62 <Endpoint_Read_Control_Stream_LE+0x2e>
    1f5e:	81 e0       	ldi	r24, 0x01	; 1
    1f60:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    1f62:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    1f66:	82 ff       	sbrs	r24, 2
    1f68:	f0 cf       	rjmp	.-32     	; 0x1f4a <Endpoint_Read_Control_Stream_LE+0x16>
    1f6a:	06 c0       	rjmp	.+12     	; 0x1f78 <Endpoint_Read_Control_Stream_LE+0x44>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    1f6c:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    1f70:	81 93       	st	Z+, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    1f72:	61 50       	subi	r22, 0x01	; 1
    1f74:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    1f76:	31 f0       	breq	.+12     	; 0x1f84 <Endpoint_Read_Control_Stream_LE+0x50>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    1f78:	80 91 f2 00 	lds	r24, 0x00F2
    1f7c:	90 91 f3 00 	lds	r25, 0x00F3
    1f80:	89 2b       	or	r24, r25
    1f82:	a1 f7       	brne	.-24     	; 0x1f6c <Endpoint_Read_Control_Stream_LE+0x38>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    1f84:	80 91 e8 00 	lds	r24, 0x00E8
    1f88:	8b 77       	andi	r24, 0x7B	; 123
    1f8a:	80 93 e8 00 	sts	0x00E8, r24
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    1f8e:	61 15       	cp	r22, r1
    1f90:	71 05       	cpc	r23, r1
    1f92:	d9 f6       	brne	.-74     	; 0x1f4a <Endpoint_Read_Control_Stream_LE+0x16>
    1f94:	06 c0       	rjmp	.+12     	; 0x1fa2 <Endpoint_Read_Control_Stream_LE+0x6e>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1f96:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1f9a:	88 23       	and	r24, r24
    1f9c:	41 f0       	breq	.+16     	; 0x1fae <Endpoint_Read_Control_Stream_LE+0x7a>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1f9e:	85 30       	cpi	r24, 0x05	; 5
    1fa0:	41 f0       	breq	.+16     	; 0x1fb2 <Endpoint_Read_Control_Stream_LE+0x7e>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    1fa2:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    1fa6:	80 ff       	sbrs	r24, 0
    1fa8:	f6 cf       	rjmp	.-20     	; 0x1f96 <Endpoint_Read_Control_Stream_LE+0x62>
    1faa:	80 e0       	ldi	r24, 0x00	; 0
    1fac:	08 95       	ret
    1fae:	82 e0       	ldi	r24, 0x02	; 2
    1fb0:	08 95       	ret
    1fb2:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    1fb4:	08 95       	ret

00001fb6 <Endpoint_Write_Control_PStream_LE>:

#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
    1fb6:	9c 01       	movw	r18, r24
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    1fb8:	40 91 07 14 	lds	r20, 0x1407
    1fbc:	50 91 08 14 	lds	r21, 0x1408
    1fc0:	46 17       	cp	r20, r22
    1fc2:	57 07       	cpc	r21, r23
    1fc4:	18 f4       	brcc	.+6      	; 0x1fcc <Endpoint_Write_Control_PStream_LE+0x16>
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    1fc6:	f9 01       	movw	r30, r18
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	40 c0       	rjmp	.+128    	; 0x204c <Endpoint_Write_Control_PStream_LE+0x96>
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    1fcc:	61 15       	cp	r22, r1
    1fce:	71 05       	cpc	r23, r1
    1fd0:	11 f0       	breq	.+4      	; 0x1fd6 <Endpoint_Write_Control_PStream_LE+0x20>
    1fd2:	ab 01       	movw	r20, r22
    1fd4:	f8 cf       	rjmp	.-16     	; 0x1fc6 <Endpoint_Write_Control_PStream_LE+0x10>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    1fd6:	80 91 e8 00 	lds	r24, 0x00E8
    1fda:	8e 77       	andi	r24, 0x7E	; 126
    1fdc:	80 93 e8 00 	sts	0x00E8, r24
    1fe0:	40 e0       	ldi	r20, 0x00	; 0
    1fe2:	50 e0       	ldi	r21, 0x00	; 0
    1fe4:	f0 cf       	rjmp	.-32     	; 0x1fc6 <Endpoint_Write_Control_PStream_LE+0x10>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    1fe6:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    1fea:	88 23       	and	r24, r24
    1fec:	09 f4       	brne	.+2      	; 0x1ff0 <Endpoint_Write_Control_PStream_LE+0x3a>
    1fee:	40 c0       	rjmp	.+128    	; 0x2070 <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    1ff0:	85 30       	cpi	r24, 0x05	; 5
    1ff2:	09 f4       	brne	.+2      	; 0x1ff6 <Endpoint_Write_Control_PStream_LE+0x40>
    1ff4:	3f c0       	rjmp	.+126    	; 0x2074 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    1ff6:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    1ffa:	83 ff       	sbrs	r24, 3
    1ffc:	02 c0       	rjmp	.+4      	; 0x2002 <Endpoint_Write_Control_PStream_LE+0x4c>
    1ffe:	81 e0       	ldi	r24, 0x01	; 1
    2000:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2002:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    2006:	82 fd       	sbrc	r24, 2
    2008:	2d c0       	rjmp	.+90     	; 0x2064 <Endpoint_Write_Control_PStream_LE+0xae>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    200a:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    200e:	80 ff       	sbrs	r24, 0
    2010:	1d c0       	rjmp	.+58     	; 0x204c <Endpoint_Write_Control_PStream_LE+0x96>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
    2012:	20 91 f2 00 	lds	r18, 0x00F2
    2016:	30 91 f3 00 	lds	r19, 0x00F3
    201a:	08 c0       	rjmp	.+16     	; 0x202c <Endpoint_Write_Control_PStream_LE+0x76>
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    201c:	84 91       	lpm	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    201e:	80 93 f1 00 	sts	0x00F1, r24
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    2022:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    2024:	41 50       	subi	r20, 0x01	; 1
    2026:	50 40       	sbci	r21, 0x00	; 0
				BytesInEndpoint++;
    2028:	2f 5f       	subi	r18, 0xFF	; 255
    202a:	3f 4f       	sbci	r19, 0xFF	; 255

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    202c:	41 15       	cp	r20, r1
    202e:	51 05       	cpc	r21, r1
    2030:	19 f0       	breq	.+6      	; 0x2038 <Endpoint_Write_Control_PStream_LE+0x82>
    2032:	28 30       	cpi	r18, 0x08	; 8
    2034:	31 05       	cpc	r19, r1
    2036:	90 f3       	brcs	.-28     	; 0x201c <Endpoint_Write_Control_PStream_LE+0x66>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    2038:	90 e0       	ldi	r25, 0x00	; 0
    203a:	28 30       	cpi	r18, 0x08	; 8
    203c:	31 05       	cpc	r19, r1
    203e:	09 f4       	brne	.+2      	; 0x2042 <Endpoint_Write_Control_PStream_LE+0x8c>
    2040:	91 e0       	ldi	r25, 0x01	; 1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2042:	80 91 e8 00 	lds	r24, 0x00E8
    2046:	8e 77       	andi	r24, 0x7E	; 126
    2048:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    204c:	41 15       	cp	r20, r1
    204e:	51 05       	cpc	r21, r1
    2050:	51 f6       	brne	.-108    	; 0x1fe6 <Endpoint_Write_Control_PStream_LE+0x30>
    2052:	99 23       	and	r25, r25
    2054:	41 f6       	brne	.-112    	; 0x1fe6 <Endpoint_Write_Control_PStream_LE+0x30>
    2056:	06 c0       	rjmp	.+12     	; 0x2064 <Endpoint_Write_Control_PStream_LE+0xae>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    2058:	80 91 00 14 	lds	r24, 0x1400

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    205c:	88 23       	and	r24, r24
    205e:	41 f0       	breq	.+16     	; 0x2070 <Endpoint_Write_Control_PStream_LE+0xba>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    2060:	85 30       	cpi	r24, 0x05	; 5
    2062:	41 f0       	breq	.+16     	; 0x2074 <Endpoint_Write_Control_PStream_LE+0xbe>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    2064:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    2068:	82 ff       	sbrs	r24, 2
    206a:	f6 cf       	rjmp	.-20     	; 0x2058 <Endpoint_Write_Control_PStream_LE+0xa2>
    206c:	80 e0       	ldi	r24, 0x00	; 0
    206e:	08 95       	ret
    2070:	82 e0       	ldi	r24, 0x02	; 2
    2072:	08 95       	ret
    2074:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    2076:	08 95       	ret

00002078 <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    2078:	bf 92       	push	r11
    207a:	cf 92       	push	r12
    207c:	df 92       	push	r13
    207e:	ef 92       	push	r14
    2080:	ff 92       	push	r15
    2082:	0f 93       	push	r16
    2084:	1f 93       	push	r17
    2086:	cf 93       	push	r28
    2088:	df 93       	push	r29
    208a:	18 2f       	mov	r17, r24
    208c:	09 2f       	mov	r16, r25
    208e:	7b 01       	movw	r14, r22
    2090:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2092:	97 dd       	rcall	.-1234   	; 0x1bc2 <Endpoint_WaitUntilReady>
    2094:	b8 2e       	mov	r11, r24
    2096:	88 23       	and	r24, r24
    2098:	b1 f5       	brne	.+108    	; 0x2106 <__stack+0x7>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    209a:	81 2f       	mov	r24, r17
    209c:	90 2f       	mov	r25, r16
    209e:	9c 01       	movw	r18, r24
    20a0:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    20a2:	c1 14       	cp	r12, r1
    20a4:	d1 04       	cpc	r13, r1
    20a6:	39 f0       	breq	.+14     	; 0x20b6 <Endpoint_Read_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    20a8:	f6 01       	movw	r30, r12
    20aa:	80 81       	ld	r24, Z
    20ac:	91 81       	ldd	r25, Z+1	; 0x01
    20ae:	e8 1a       	sub	r14, r24
    20b0:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    20b2:	c8 0f       	add	r28, r24
    20b4:	d9 1f       	adc	r29, r25
    20b6:	00 e0       	ldi	r16, 0x00	; 0
    20b8:	10 e0       	ldi	r17, 0x00	; 0
    20ba:	22 c0       	rjmp	.+68     	; 0x2100 <__stack+0x1>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    20bc:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    20c0:	85 fd       	sbrc	r24, 5
    20c2:	16 c0       	rjmp	.+44     	; 0x20f0 <Endpoint_Read_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    20c4:	80 91 e8 00 	lds	r24, 0x00E8
    20c8:	8b 77       	andi	r24, 0x7B	; 123
    20ca:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    20ce:	e7 d1       	rcall	.+974    	; 0x249e <USB_USBTask>
			#endif

			if (BytesProcessed != NULL)
    20d0:	c1 14       	cp	r12, r1
    20d2:	d1 04       	cpc	r13, r1
    20d4:	49 f0       	breq	.+18     	; 0x20e8 <Endpoint_Read_Stream_LE+0x70>
			{
				*BytesProcessed += BytesInTransfer;
    20d6:	f6 01       	movw	r30, r12
    20d8:	80 81       	ld	r24, Z
    20da:	91 81       	ldd	r25, Z+1	; 0x01
    20dc:	80 0f       	add	r24, r16
    20de:	91 1f       	adc	r25, r17
    20e0:	91 83       	std	Z+1, r25	; 0x01
    20e2:	80 83       	st	Z, r24
    20e4:	85 e0       	ldi	r24, 0x05	; 5
    20e6:	10 c0       	rjmp	.+32     	; 0x2108 <__stack+0x9>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    20e8:	6c dd       	rcall	.-1320   	; 0x1bc2 <Endpoint_WaitUntilReady>
    20ea:	88 23       	and	r24, r24
    20ec:	49 f0       	breq	.+18     	; 0x2100 <__stack+0x1>
    20ee:	0c c0       	rjmp	.+24     	; 0x2108 <__stack+0x9>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    20f0:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    20f4:	89 93       	st	Y+, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    20f6:	08 94       	sec
    20f8:	e1 08       	sbc	r14, r1
    20fa:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    20fc:	0f 5f       	subi	r16, 0xFF	; 255
    20fe:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    2100:	e1 14       	cp	r14, r1
    2102:	f1 04       	cpc	r15, r1
    2104:	d9 f6       	brne	.-74     	; 0x20bc <Endpoint_Read_Stream_LE+0x44>
    2106:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    2108:	df 91       	pop	r29
    210a:	cf 91       	pop	r28
    210c:	1f 91       	pop	r17
    210e:	0f 91       	pop	r16
    2110:	ff 90       	pop	r15
    2112:	ef 90       	pop	r14
    2114:	df 90       	pop	r13
    2116:	cf 90       	pop	r12
    2118:	bf 90       	pop	r11
    211a:	08 95       	ret

0000211c <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    211c:	bf 92       	push	r11
    211e:	cf 92       	push	r12
    2120:	df 92       	push	r13
    2122:	ef 92       	push	r14
    2124:	ff 92       	push	r15
    2126:	0f 93       	push	r16
    2128:	1f 93       	push	r17
    212a:	cf 93       	push	r28
    212c:	df 93       	push	r29
    212e:	18 2f       	mov	r17, r24
    2130:	09 2f       	mov	r16, r25
    2132:	7b 01       	movw	r14, r22
    2134:	6a 01       	movw	r12, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    2136:	45 dd       	rcall	.-1398   	; 0x1bc2 <Endpoint_WaitUntilReady>
    2138:	b8 2e       	mov	r11, r24
    213a:	88 23       	and	r24, r24
    213c:	b1 f5       	brne	.+108    	; 0x21aa <Endpoint_Write_Stream_LE+0x8e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    213e:	81 2f       	mov	r24, r17
    2140:	90 2f       	mov	r25, r16
    2142:	9c 01       	movw	r18, r24
    2144:	e9 01       	movw	r28, r18
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    2146:	c1 14       	cp	r12, r1
    2148:	d1 04       	cpc	r13, r1
    214a:	39 f0       	breq	.+14     	; 0x215a <Endpoint_Write_Stream_LE+0x3e>
	{
		Length -= *BytesProcessed;
    214c:	f6 01       	movw	r30, r12
    214e:	80 81       	ld	r24, Z
    2150:	91 81       	ldd	r25, Z+1	; 0x01
    2152:	e8 1a       	sub	r14, r24
    2154:	f9 0a       	sbc	r15, r25
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    2156:	c8 0f       	add	r28, r24
    2158:	d9 1f       	adc	r29, r25
    215a:	00 e0       	ldi	r16, 0x00	; 0
    215c:	10 e0       	ldi	r17, 0x00	; 0
    215e:	22 c0       	rjmp	.+68     	; 0x21a4 <Endpoint_Write_Stream_LE+0x88>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    2160:	80 91 e8 00 	lds	r24, 0x00E8
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    2164:	85 fd       	sbrc	r24, 5
    2166:	16 c0       	rjmp	.+44     	; 0x2194 <Endpoint_Write_Stream_LE+0x78>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2168:	80 91 e8 00 	lds	r24, 0x00E8
    216c:	8e 77       	andi	r24, 0x7E	; 126
    216e:	80 93 e8 00 	sts	0x00E8, r24
		{
			TEMPLATE_CLEAR_ENDPOINT();

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
    2172:	95 d1       	rcall	.+810    	; 0x249e <USB_USBTask>
			#endif

			if (BytesProcessed != NULL)
    2174:	c1 14       	cp	r12, r1
    2176:	d1 04       	cpc	r13, r1
    2178:	49 f0       	breq	.+18     	; 0x218c <Endpoint_Write_Stream_LE+0x70>
			{
				*BytesProcessed += BytesInTransfer;
    217a:	f6 01       	movw	r30, r12
    217c:	80 81       	ld	r24, Z
    217e:	91 81       	ldd	r25, Z+1	; 0x01
    2180:	80 0f       	add	r24, r16
    2182:	91 1f       	adc	r25, r17
    2184:	91 83       	std	Z+1, r25	; 0x01
    2186:	80 83       	st	Z, r24
    2188:	85 e0       	ldi	r24, 0x05	; 5
    218a:	10 c0       	rjmp	.+32     	; 0x21ac <Endpoint_Write_Stream_LE+0x90>
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    218c:	1a dd       	rcall	.-1484   	; 0x1bc2 <Endpoint_WaitUntilReady>
    218e:	88 23       	and	r24, r24
    2190:	49 f0       	breq	.+18     	; 0x21a4 <Endpoint_Write_Stream_LE+0x88>
    2192:	0c c0       	rjmp	.+24     	; 0x21ac <Endpoint_Write_Stream_LE+0x90>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    2194:	89 91       	ld	r24, Y+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    2196:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    219a:	08 94       	sec
    219c:	e1 08       	sbc	r14, r1
    219e:	f1 08       	sbc	r15, r1
			BytesInTransfer++;
    21a0:	0f 5f       	subi	r16, 0xFF	; 255
    21a2:	1f 4f       	sbci	r17, 0xFF	; 255
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    21a4:	e1 14       	cp	r14, r1
    21a6:	f1 04       	cpc	r15, r1
    21a8:	d9 f6       	brne	.-74     	; 0x2160 <Endpoint_Write_Stream_LE+0x44>
    21aa:	8b 2d       	mov	r24, r11
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    21ac:	df 91       	pop	r29
    21ae:	cf 91       	pop	r28
    21b0:	1f 91       	pop	r17
    21b2:	0f 91       	pop	r16
    21b4:	ff 90       	pop	r15
    21b6:	ef 90       	pop	r14
    21b8:	df 90       	pop	r13
    21ba:	cf 90       	pop	r12
    21bc:	bf 90       	pop	r11
    21be:	08 95       	ret

000021c0 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    21c0:	0f 93       	push	r16
    21c2:	1f 93       	push	r17
    21c4:	df 93       	push	r29
    21c6:	cf 93       	push	r28
    21c8:	cd b7       	in	r28, 0x3d	; 61
    21ca:	de b7       	in	r29, 0x3e	; 62
    21cc:	ac 97       	sbiw	r28, 0x2c	; 44
    21ce:	0f b6       	in	r0, 0x3f	; 63
    21d0:	f8 94       	cli
    21d2:	de bf       	out	0x3e, r29	; 62
    21d4:	0f be       	out	0x3f, r0	; 63
    21d6:	cd bf       	out	0x3d, r28	; 61
    21d8:	e1 e0       	ldi	r30, 0x01	; 1
    21da:	f4 e1       	ldi	r31, 0x14	; 20
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    21dc:	80 91 f1 00 	lds	r24, 0x00F1
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    21e0:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    21e2:	24 e1       	ldi	r18, 0x14	; 20
    21e4:	e9 30       	cpi	r30, 0x09	; 9
    21e6:	f2 07       	cpc	r31, r18
    21e8:	c9 f7       	brne	.-14     	; 0x21dc <USB_Device_ProcessControlRequest+0x1c>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    21ea:	0e 94 3a 02 	call	0x474	; 0x474 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    21ee:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    21f2:	83 ff       	sbrs	r24, 3
    21f4:	3a c1       	rjmp	.+628    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    21f6:	80 91 01 14 	lds	r24, 0x1401

		switch (USB_ControlRequest.bRequest)
    21fa:	30 91 02 14 	lds	r19, 0x1402
    21fe:	35 30       	cpi	r19, 0x05	; 5
    2200:	09 f4       	brne	.+2      	; 0x2204 <USB_Device_ProcessControlRequest+0x44>
    2202:	87 c0       	rjmp	.+270    	; 0x2312 <USB_Device_ProcessControlRequest+0x152>
    2204:	36 30       	cpi	r19, 0x06	; 6
    2206:	40 f4       	brcc	.+16     	; 0x2218 <USB_Device_ProcessControlRequest+0x58>
    2208:	31 30       	cpi	r19, 0x01	; 1
    220a:	c9 f1       	breq	.+114    	; 0x227e <USB_Device_ProcessControlRequest+0xbe>
    220c:	31 30       	cpi	r19, 0x01	; 1
    220e:	70 f0       	brcs	.+28     	; 0x222c <USB_Device_ProcessControlRequest+0x6c>
    2210:	33 30       	cpi	r19, 0x03	; 3
    2212:	09 f0       	breq	.+2      	; 0x2216 <USB_Device_ProcessControlRequest+0x56>
    2214:	2a c1       	rjmp	.+596    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
    2216:	33 c0       	rjmp	.+102    	; 0x227e <USB_Device_ProcessControlRequest+0xbe>
    2218:	38 30       	cpi	r19, 0x08	; 8
    221a:	09 f4       	brne	.+2      	; 0x221e <USB_Device_ProcessControlRequest+0x5e>
    221c:	f7 c0       	rjmp	.+494    	; 0x240c <USB_Device_ProcessControlRequest+0x24c>
    221e:	39 30       	cpi	r19, 0x09	; 9
    2220:	09 f4       	brne	.+2      	; 0x2224 <USB_Device_ProcessControlRequest+0x64>
    2222:	06 c1       	rjmp	.+524    	; 0x2430 <USB_Device_ProcessControlRequest+0x270>
    2224:	36 30       	cpi	r19, 0x06	; 6
    2226:	09 f0       	breq	.+2      	; 0x222a <USB_Device_ProcessControlRequest+0x6a>
    2228:	20 c1       	rjmp	.+576    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
    222a:	97 c0       	rjmp	.+302    	; 0x235a <USB_Device_ProcessControlRequest+0x19a>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    222c:	80 38       	cpi	r24, 0x80	; 128
    222e:	21 f0       	breq	.+8      	; 0x2238 <USB_Device_ProcessControlRequest+0x78>
    2230:	82 38       	cpi	r24, 0x82	; 130
    2232:	09 f0       	breq	.+2      	; 0x2236 <USB_Device_ProcessControlRequest+0x76>
    2234:	1a c1       	rjmp	.+564    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
    2236:	08 c0       	rjmp	.+16     	; 0x2248 <USB_Device_ProcessControlRequest+0x88>
    2238:	90 91 fd 13 	lds	r25, 0x13FD
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    223c:	80 91 fe 13 	lds	r24, 0x13FE
    2240:	88 23       	and	r24, r24
    2242:	99 f0       	breq	.+38     	; 0x226a <USB_Device_ProcessControlRequest+0xaa>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    2244:	92 60       	ori	r25, 0x02	; 2
    2246:	11 c0       	rjmp	.+34     	; 0x226a <USB_Device_ProcessControlRequest+0xaa>
			#endif
			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    2248:	80 91 05 14 	lds	r24, 0x1405
    224c:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    224e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    2252:	80 91 eb 00 	lds	r24, 0x00EB

			CurrentStatus = Endpoint_IsStalled();
    2256:	90 e0       	ldi	r25, 0x00	; 0
    2258:	25 e0       	ldi	r18, 0x05	; 5
    225a:	96 95       	lsr	r25
    225c:	87 95       	ror	r24
    225e:	2a 95       	dec	r18
    2260:	e1 f7       	brne	.-8      	; 0x225a <USB_Device_ProcessControlRequest+0x9a>
    2262:	98 2f       	mov	r25, r24
    2264:	91 70       	andi	r25, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2266:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    226a:	80 91 e8 00 	lds	r24, 0x00E8
    226e:	87 7f       	andi	r24, 0xF7	; 247
    2270:	80 93 e8 00 	sts	0x00E8, r24
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    2274:	90 93 f1 00 	sts	0x00F1, r25
				UEDATX = (Data >> 8);
    2278:	10 92 f1 00 	sts	0x00F1, r1
    227c:	d2 c0       	rjmp	.+420    	; 0x2422 <USB_Device_ProcessControlRequest+0x262>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    227e:	88 23       	and	r24, r24
    2280:	19 f0       	breq	.+6      	; 0x2288 <USB_Device_ProcessControlRequest+0xc8>
    2282:	82 30       	cpi	r24, 0x02	; 2
    2284:	09 f0       	breq	.+2      	; 0x2288 <USB_Device_ProcessControlRequest+0xc8>
    2286:	f1 c0       	rjmp	.+482    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    2288:	90 e0       	ldi	r25, 0x00	; 0
    228a:	8f 71       	andi	r24, 0x1F	; 31
    228c:	90 70       	andi	r25, 0x00	; 0
    228e:	00 97       	sbiw	r24, 0x00	; 0
    2290:	21 f0       	breq	.+8      	; 0x229a <USB_Device_ProcessControlRequest+0xda>
    2292:	02 97       	sbiw	r24, 0x02	; 2
    2294:	09 f0       	breq	.+2      	; 0x2298 <USB_Device_ProcessControlRequest+0xd8>
    2296:	e9 c0       	rjmp	.+466    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
    2298:	0c c0       	rjmp	.+24     	; 0x22b2 <USB_Device_ProcessControlRequest+0xf2>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    229a:	80 91 03 14 	lds	r24, 0x1403
    229e:	81 30       	cpi	r24, 0x01	; 1
    22a0:	09 f0       	breq	.+2      	; 0x22a4 <USB_Device_ProcessControlRequest+0xe4>
    22a2:	e3 c0       	rjmp	.+454    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    22a4:	10 92 fe 13 	sts	0x13FE, r1
    22a8:	33 30       	cpi	r19, 0x03	; 3
    22aa:	69 f5       	brne	.+90     	; 0x2306 <USB_Device_ProcessControlRequest+0x146>
    22ac:	80 93 fe 13 	sts	0x13FE, r24
    22b0:	2a c0       	rjmp	.+84     	; 0x2306 <USB_Device_ProcessControlRequest+0x146>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    22b2:	80 91 03 14 	lds	r24, 0x1403
    22b6:	88 23       	and	r24, r24
    22b8:	31 f5       	brne	.+76     	; 0x2306 <USB_Device_ProcessControlRequest+0x146>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    22ba:	20 91 05 14 	lds	r18, 0x1405
    22be:	27 70       	andi	r18, 0x07	; 7

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    22c0:	09 f4       	brne	.+2      	; 0x22c4 <USB_Device_ProcessControlRequest+0x104>
    22c2:	d3 c0       	rjmp	.+422    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    22c4:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    22c8:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    22cc:	80 ff       	sbrs	r24, 0
    22ce:	1b c0       	rjmp	.+54     	; 0x2306 <USB_Device_ProcessControlRequest+0x146>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    22d0:	33 30       	cpi	r19, 0x03	; 3
    22d2:	21 f4       	brne	.+8      	; 0x22dc <USB_Device_ProcessControlRequest+0x11c>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    22d4:	80 91 eb 00 	lds	r24, 0x00EB
    22d8:	80 62       	ori	r24, 0x20	; 32
    22da:	13 c0       	rjmp	.+38     	; 0x2302 <USB_Device_ProcessControlRequest+0x142>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    22dc:	80 91 eb 00 	lds	r24, 0x00EB
    22e0:	80 61       	ori	r24, 0x10	; 16
    22e2:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
    22e6:	81 e0       	ldi	r24, 0x01	; 1
    22e8:	90 e0       	ldi	r25, 0x00	; 0
    22ea:	02 c0       	rjmp	.+4      	; 0x22f0 <USB_Device_ProcessControlRequest+0x130>
    22ec:	88 0f       	add	r24, r24
    22ee:	99 1f       	adc	r25, r25
    22f0:	2a 95       	dec	r18
    22f2:	e2 f7       	brpl	.-8      	; 0x22ec <USB_Device_ProcessControlRequest+0x12c>
    22f4:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    22f8:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    22fc:	80 91 eb 00 	lds	r24, 0x00EB
    2300:	88 60       	ori	r24, 0x08	; 8
    2302:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2306:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    230a:	80 91 e8 00 	lds	r24, 0x00E8
    230e:	87 7f       	andi	r24, 0xF7	; 247
    2310:	8b c0       	rjmp	.+278    	; 0x2428 <USB_Device_ProcessControlRequest+0x268>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2312:	88 23       	and	r24, r24
    2314:	09 f0       	breq	.+2      	; 0x2318 <USB_Device_ProcessControlRequest+0x158>
    2316:	a9 c0       	rjmp	.+338    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
    2318:	10 91 03 14 	lds	r17, 0x1403
    231c:	1f 77       	andi	r17, 0x7F	; 127
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    231e:	0f b7       	in	r16, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    2320:	f8 94       	cli
    2322:	80 91 e8 00 	lds	r24, 0x00E8
    2326:	87 7f       	andi	r24, 0xF7	; 247
    2328:	80 93 e8 00 	sts	0x00E8, r24
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();
				
	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    232c:	29 dc       	rcall	.-1966   	; 0x1b80 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    232e:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    2332:	80 ff       	sbrs	r24, 0
    2334:	fc cf       	rjmp	.-8      	; 0x232e <USB_Device_ProcessControlRequest+0x16e>
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    2336:	80 91 e3 00 	lds	r24, 0x00E3
    233a:	80 78       	andi	r24, 0x80	; 128
    233c:	81 2b       	or	r24, r17

				UDADDR = Temp;
    233e:	80 93 e3 00 	sts	0x00E3, r24
				UDADDR = Temp | (1 << ADDEN);
    2342:	80 68       	ori	r24, 0x80	; 128
    2344:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    2348:	11 23       	and	r17, r17
    234a:	11 f4       	brne	.+4      	; 0x2350 <USB_Device_ProcessControlRequest+0x190>
    234c:	82 e0       	ldi	r24, 0x02	; 2
    234e:	01 c0       	rjmp	.+2      	; 0x2352 <USB_Device_ProcessControlRequest+0x192>
    2350:	83 e0       	ldi	r24, 0x03	; 3
    2352:	80 93 00 14 	sts	0x1400, r24
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    2356:	0f bf       	out	0x3f, r16	; 63
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;				
				#endif
				
				GCC_MEMORY_BARRIER();
    2358:	88 c0       	rjmp	.+272    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    235a:	80 58       	subi	r24, 0x80	; 128
    235c:	82 30       	cpi	r24, 0x02	; 2
    235e:	08 f0       	brcs	.+2      	; 0x2362 <USB_Device_ProcessControlRequest+0x1a2>
    2360:	84 c0       	rjmp	.+264    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    2362:	80 91 03 14 	lds	r24, 0x1403
    2366:	90 91 04 14 	lds	r25, 0x1404
    236a:	23 e0       	ldi	r18, 0x03	; 3
    236c:	8c 3d       	cpi	r24, 0xDC	; 220
    236e:	92 07       	cpc	r25, r18
    2370:	09 f0       	breq	.+2      	; 0x2374 <USB_Device_ProcessControlRequest+0x1b4>
    2372:	33 c0       	rjmp	.+102    	; 0x23da <USB_Device_ProcessControlRequest+0x21a>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    2374:	83 e0       	ldi	r24, 0x03	; 3
    2376:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    2378:	8a e2       	ldi	r24, 0x2A	; 42
    237a:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    237c:	7f b7       	in	r23, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    237e:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    2380:	de 01       	movw	r26, r28
    2382:	15 96       	adiw	r26, 0x05	; 5
    2384:	6e e0       	ldi	r22, 0x0E	; 14
    2386:	40 e0       	ldi	r20, 0x00	; 0
    2388:	50 e0       	ldi	r21, 0x00	; 0
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    238a:	11 e2       	ldi	r17, 0x21	; 33
    238c:	e6 2f       	mov	r30, r22
    238e:	f0 e0       	ldi	r31, 0x00	; 0
    2390:	10 93 57 00 	sts	0x0057, r17
    2394:	84 91       	lpm	r24, Z+

					if (SerialCharNum & 0x01)
    2396:	40 ff       	sbrs	r20, 0
    2398:	03 c0       	rjmp	.+6      	; 0x23a0 <USB_Device_ProcessControlRequest+0x1e0>
					{
						SerialByte >>= 4;
    239a:	82 95       	swap	r24
    239c:	8f 70       	andi	r24, 0x0F	; 15
						SigReadAddress++;
    239e:	6f 5f       	subi	r22, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    23a0:	8f 70       	andi	r24, 0x0F	; 15
    23a2:	28 2f       	mov	r18, r24
    23a4:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    23a6:	8a 30       	cpi	r24, 0x0A	; 10
    23a8:	18 f0       	brcs	.+6      	; 0x23b0 <USB_Device_ProcessControlRequest+0x1f0>
    23aa:	c9 01       	movw	r24, r18
    23ac:	c7 96       	adiw	r24, 0x37	; 55
    23ae:	02 c0       	rjmp	.+4      	; 0x23b4 <USB_Device_ProcessControlRequest+0x1f4>
    23b0:	c9 01       	movw	r24, r18
    23b2:	c0 96       	adiw	r24, 0x30	; 48
    23b4:	8d 93       	st	X+, r24
    23b6:	9d 93       	st	X+, r25
    23b8:	4f 5f       	subi	r20, 0xFF	; 255
    23ba:	5f 4f       	sbci	r21, 0xFF	; 255
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();
				
				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    23bc:	44 31       	cpi	r20, 0x14	; 20
    23be:	51 05       	cpc	r21, r1
    23c0:	29 f7       	brne	.-54     	; 0x238c <USB_Device_ProcessControlRequest+0x1cc>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    23c2:	7f bf       	out	0x3f, r23	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    23c4:	80 91 e8 00 	lds	r24, 0x00E8
    23c8:	87 7f       	andi	r24, 0xF7	; 247
    23ca:	80 93 e8 00 	sts	0x00E8, r24
	
	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    23ce:	ce 01       	movw	r24, r28
    23d0:	03 96       	adiw	r24, 0x03	; 3
    23d2:	6a e2       	ldi	r22, 0x2A	; 42
    23d4:	70 e0       	ldi	r23, 0x00	; 0
    23d6:	50 dd       	rcall	.-1376   	; 0x1e78 <Endpoint_Write_Control_Stream_LE>
    23d8:	13 c0       	rjmp	.+38     	; 0x2400 <USB_Device_ProcessControlRequest+0x240>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    23da:	60 91 05 14 	lds	r22, 0x1405
    23de:	ae 01       	movw	r20, r28
    23e0:	4f 5f       	subi	r20, 0xFF	; 255
    23e2:	5f 4f       	sbci	r21, 0xFF	; 255
    23e4:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <CALLBACK_USB_GetDescriptor>
    23e8:	bc 01       	movw	r22, r24
    23ea:	00 97       	sbiw	r24, 0x00	; 0
    23ec:	09 f4       	brne	.+2      	; 0x23f0 <USB_Device_ProcessControlRequest+0x230>
    23ee:	3d c0       	rjmp	.+122    	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
    23f0:	80 91 e8 00 	lds	r24, 0x00E8
    23f4:	87 7f       	andi	r24, 0xF7	; 247
    23f6:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    23fa:	89 81       	ldd	r24, Y+1	; 0x01
    23fc:	9a 81       	ldd	r25, Y+2	; 0x02
    23fe:	db dd       	rcall	.-1098   	; 0x1fb6 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2400:	80 91 e8 00 	lds	r24, 0x00E8
    2404:	8b 77       	andi	r24, 0x7B	; 123
    2406:	80 93 e8 00 	sts	0x00E8, r24
    240a:	2f c0       	rjmp	.+94     	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    240c:	80 38       	cpi	r24, 0x80	; 128
    240e:	69 f5       	brne	.+90     	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2410:	80 91 e8 00 	lds	r24, 0x00E8
    2414:	87 7f       	andi	r24, 0xF7	; 247
    2416:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    241a:	80 91 fc 13 	lds	r24, 0x13FC
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    241e:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    2422:	80 91 e8 00 	lds	r24, 0x00E8
    2426:	8e 77       	andi	r24, 0x7E	; 126
    2428:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    242c:	a9 db       	rcall	.-2222   	; 0x1b80 <Endpoint_ClearStatusStage>
    242e:	1d c0       	rjmp	.+58     	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    2430:	88 23       	and	r24, r24
    2432:	d9 f4       	brne	.+54     	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    2434:	90 91 03 14 	lds	r25, 0x1403
    2438:	92 30       	cpi	r25, 0x02	; 2
    243a:	b8 f4       	brcc	.+46     	; 0x246a <USB_Device_ProcessControlRequest+0x2aa>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    243c:	80 91 e8 00 	lds	r24, 0x00E8
    2440:	87 7f       	andi	r24, 0xF7	; 247
    2442:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    2446:	90 93 fc 13 	sts	0x13FC, r25

	Endpoint_ClearStatusStage();
    244a:	9a db       	rcall	.-2252   	; 0x1b80 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    244c:	80 91 fc 13 	lds	r24, 0x13FC
    2450:	88 23       	and	r24, r24
    2452:	31 f4       	brne	.+12     	; 0x2460 <USB_Device_ProcessControlRequest+0x2a0>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    2454:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    2458:	87 fd       	sbrc	r24, 7
    245a:	02 c0       	rjmp	.+4      	; 0x2460 <USB_Device_ProcessControlRequest+0x2a0>
    245c:	81 e0       	ldi	r24, 0x01	; 1
    245e:	01 c0       	rjmp	.+2      	; 0x2462 <USB_Device_ProcessControlRequest+0x2a2>
    2460:	84 e0       	ldi	r24, 0x04	; 4
    2462:	80 93 00 14 	sts	0x1400, r24

	EVENT_USB_Device_ConfigurationChanged();
    2466:	0e 94 3e 02 	call	0x47c	; 0x47c <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    246a:	80 91 e8 00 	lds	r24, 0x00E8

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    246e:	83 ff       	sbrs	r24, 3
    2470:	0a c0       	rjmp	.+20     	; 0x2486 <USB_Device_ProcessControlRequest+0x2c6>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    2472:	80 91 eb 00 	lds	r24, 0x00EB
    2476:	80 62       	ori	r24, 0x20	; 32
    2478:	80 93 eb 00 	sts	0x00EB, r24
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    247c:	80 91 e8 00 	lds	r24, 0x00E8
    2480:	87 7f       	andi	r24, 0xF7	; 247
    2482:	80 93 e8 00 	sts	0x00E8, r24
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
    2486:	ac 96       	adiw	r28, 0x2c	; 44
    2488:	0f b6       	in	r0, 0x3f	; 63
    248a:	f8 94       	cli
    248c:	de bf       	out	0x3e, r29	; 62
    248e:	0f be       	out	0x3f, r0	; 63
    2490:	cd bf       	out	0x3d, r28	; 61
    2492:	cf 91       	pop	r28
    2494:	df 91       	pop	r29
    2496:	1f 91       	pop	r17
    2498:	0f 91       	pop	r16
    249a:	08 95       	ret

0000249c <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    249c:	08 95       	ret

0000249e <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    249e:	1f 93       	push	r17
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
    24a0:	80 91 00 14 	lds	r24, 0x1400
    24a4:	88 23       	and	r24, r24
    24a6:	61 f0       	breq	.+24     	; 0x24c0 <USB_USBTask+0x22>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    24a8:	10 91 e9 00 	lds	r17, 0x00E9
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    24ac:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    24b0:	80 91 e8 00 	lds	r24, 0x00E8
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
    24b4:	83 ff       	sbrs	r24, 3
    24b6:	01 c0       	rjmp	.+2      	; 0x24ba <USB_USBTask+0x1c>
		  USB_Device_ProcessControlRequest();
    24b8:	83 de       	rcall	.-762    	; 0x21c0 <USB_Device_ProcessControlRequest>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
    24ba:	17 70       	andi	r17, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    24bc:	10 93 e9 00 	sts	0x00E9, r17
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
		  USB_HostTask();
	#endif
}
    24c0:	1f 91       	pop	r17
    24c2:	08 95       	ret

000024c4 <RNDIS_Device_IsPacketReceived>:
			return false;
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    24c4:	fc 01       	movw	r30, r24
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    24c6:	80 91 00 14 	lds	r24, 0x1400
    24ca:	84 30       	cpi	r24, 0x04	; 4
    24cc:	99 f4       	brne	.+38     	; 0x24f4 <RNDIS_Device_IsPacketReceived+0x30>
    24ce:	ea 56       	subi	r30, 0x6A	; 106
    24d0:	ff 4f       	sbci	r31, 0xFF	; 255
    24d2:	80 81       	ld	r24, Z
    24d4:	e6 59       	subi	r30, 0x96	; 150
    24d6:	f0 40       	sbci	r31, 0x00	; 0
    24d8:	82 30       	cpi	r24, 0x02	; 2
    24da:	61 f4       	brne	.+24     	; 0x24f4 <RNDIS_Device_IsPacketReceived+0x30>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    24dc:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    24de:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    24e2:	80 91 e8 00 	lds	r24, 0x00E8
    24e6:	90 e0       	ldi	r25, 0x00	; 0
    24e8:	96 95       	lsr	r25
    24ea:	87 95       	ror	r24
    24ec:	96 95       	lsr	r25
    24ee:	87 95       	ror	r24
    24f0:	81 70       	andi	r24, 0x01	; 1
    24f2:	08 95       	ret
	return Endpoint_IsOUTReceived();
    24f4:	80 e0       	ldi	r24, 0x00	; 0
}
    24f6:	08 95       	ret

000024f8 <RNDIS_Device_SendPacket>:
}

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    24f8:	cf 92       	push	r12
    24fa:	df 92       	push	r13
    24fc:	ff 92       	push	r15
    24fe:	0f 93       	push	r16
    2500:	1f 93       	push	r17
    2502:	df 93       	push	r29
    2504:	cf 93       	push	r28
    2506:	cd b7       	in	r28, 0x3d	; 61
    2508:	de b7       	in	r29, 0x3e	; 62
    250a:	ac 97       	sbiw	r28, 0x2c	; 44
    250c:	0f b6       	in	r0, 0x3f	; 63
    250e:	f8 94       	cli
    2510:	de bf       	out	0x3e, r29	; 62
    2512:	0f be       	out	0x3f, r0	; 63
    2514:	cd bf       	out	0x3d, r28	; 61
    2516:	fc 01       	movw	r30, r24
    2518:	6b 01       	movw	r12, r22
    251a:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    251c:	80 91 00 14 	lds	r24, 0x1400
    2520:	84 30       	cpi	r24, 0x04	; 4
    2522:	09 f0       	breq	.+2      	; 0x2526 <RNDIS_Device_SendPacket+0x2e>
    2524:	49 c0       	rjmp	.+146    	; 0x25b8 <RNDIS_Device_SendPacket+0xc0>
    2526:	ea 56       	subi	r30, 0x6A	; 106
    2528:	ff 4f       	sbci	r31, 0xFF	; 255
    252a:	80 81       	ld	r24, Z
    252c:	e6 59       	subi	r30, 0x96	; 150
    252e:	f0 40       	sbci	r31, 0x00	; 0
    2530:	82 30       	cpi	r24, 0x02	; 2
    2532:	09 f0       	breq	.+2      	; 0x2536 <RNDIS_Device_SendPacket+0x3e>
    2534:	41 c0       	rjmp	.+130    	; 0x25b8 <RNDIS_Device_SendPacket+0xc0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpointNumber);
    2536:	81 81       	ldd	r24, Z+1	; 0x01
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2538:	80 93 e9 00 	sts	0x00E9, r24

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    253c:	42 db       	rcall	.-2428   	; 0x1bc2 <Endpoint_WaitUntilReady>
    253e:	f8 2e       	mov	r15, r24
    2540:	88 23       	and	r24, r24
    2542:	e1 f5       	brne	.+120    	; 0x25bc <RNDIS_Device_SendPacket+0xc4>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    2544:	fe 01       	movw	r30, r28
    2546:	31 96       	adiw	r30, 0x01	; 1
    2548:	8c e2       	ldi	r24, 0x2C	; 44
    254a:	df 01       	movw	r26, r30
    254c:	1d 92       	st	X+, r1
    254e:	8a 95       	dec	r24
    2550:	e9 f7       	brne	.-6      	; 0x254c <RNDIS_Device_SendPacket+0x54>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    2552:	81 e0       	ldi	r24, 0x01	; 1
    2554:	90 e0       	ldi	r25, 0x00	; 0
    2556:	a0 e0       	ldi	r26, 0x00	; 0
    2558:	b0 e0       	ldi	r27, 0x00	; 0
    255a:	89 83       	std	Y+1, r24	; 0x01
    255c:	9a 83       	std	Y+2, r25	; 0x02
    255e:	ab 83       	std	Y+3, r26	; 0x03
    2560:	bc 83       	std	Y+4, r27	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    2562:	04 5d       	subi	r16, 0xD4	; 212
    2564:	1f 4f       	sbci	r17, 0xFF	; 255
    2566:	c8 01       	movw	r24, r16
    2568:	a0 e0       	ldi	r26, 0x00	; 0
    256a:	b0 e0       	ldi	r27, 0x00	; 0
    256c:	0c 52       	subi	r16, 0x2C	; 44
    256e:	10 40       	sbci	r17, 0x00	; 0
    2570:	8d 83       	std	Y+5, r24	; 0x05
    2572:	9e 83       	std	Y+6, r25	; 0x06
    2574:	af 83       	std	Y+7, r26	; 0x07
    2576:	b8 87       	std	Y+8, r27	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    2578:	84 e2       	ldi	r24, 0x24	; 36
    257a:	90 e0       	ldi	r25, 0x00	; 0
    257c:	a0 e0       	ldi	r26, 0x00	; 0
    257e:	b0 e0       	ldi	r27, 0x00	; 0
    2580:	89 87       	std	Y+9, r24	; 0x09
    2582:	9a 87       	std	Y+10, r25	; 0x0a
    2584:	ab 87       	std	Y+11, r26	; 0x0b
    2586:	bc 87       	std	Y+12, r27	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    2588:	c8 01       	movw	r24, r16
    258a:	a0 e0       	ldi	r26, 0x00	; 0
    258c:	b0 e0       	ldi	r27, 0x00	; 0
    258e:	8d 87       	std	Y+13, r24	; 0x0d
    2590:	9e 87       	std	Y+14, r25	; 0x0e
    2592:	af 87       	std	Y+15, r26	; 0x0f
    2594:	b8 8b       	std	Y+16, r27	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    2596:	cf 01       	movw	r24, r30
    2598:	6c e2       	ldi	r22, 0x2C	; 44
    259a:	70 e0       	ldi	r23, 0x00	; 0
    259c:	40 e0       	ldi	r20, 0x00	; 0
    259e:	50 e0       	ldi	r21, 0x00	; 0
    25a0:	bd dd       	rcall	.-1158   	; 0x211c <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    25a2:	c6 01       	movw	r24, r12
    25a4:	b8 01       	movw	r22, r16
    25a6:	40 e0       	ldi	r20, 0x00	; 0
    25a8:	50 e0       	ldi	r21, 0x00	; 0
    25aa:	b8 dd       	rcall	.-1168   	; 0x211c <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    25ac:	80 91 e8 00 	lds	r24, 0x00E8
    25b0:	8e 77       	andi	r24, 0x7E	; 126
    25b2:	80 93 e8 00 	sts	0x00E8, r24
    25b6:	02 c0       	rjmp	.+4      	; 0x25bc <RNDIS_Device_SendPacket+0xc4>
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    25b8:	32 e0       	ldi	r19, 0x02	; 2
    25ba:	f3 2e       	mov	r15, r19
}
    25bc:	8f 2d       	mov	r24, r15
    25be:	ac 96       	adiw	r28, 0x2c	; 44
    25c0:	0f b6       	in	r0, 0x3f	; 63
    25c2:	f8 94       	cli
    25c4:	de bf       	out	0x3e, r29	; 62
    25c6:	0f be       	out	0x3f, r0	; 63
    25c8:	cd bf       	out	0x3d, r28	; 61
    25ca:	cf 91       	pop	r28
    25cc:	df 91       	pop	r29
    25ce:	1f 91       	pop	r17
    25d0:	0f 91       	pop	r16
    25d2:	ff 90       	pop	r15
    25d4:	df 90       	pop	r13
    25d6:	cf 90       	pop	r12
    25d8:	08 95       	ret

000025da <RNDIS_Device_USBTask>:

	return true;
}

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    25da:	0f 93       	push	r16
    25dc:	1f 93       	push	r17
    25de:	df 93       	push	r29
    25e0:	cf 93       	push	r28
    25e2:	cd b7       	in	r28, 0x3d	; 61
    25e4:	de b7       	in	r29, 0x3e	; 62
    25e6:	28 97       	sbiw	r28, 0x08	; 8
    25e8:	0f b6       	in	r0, 0x3f	; 63
    25ea:	f8 94       	cli
    25ec:	de bf       	out	0x3e, r29	; 62
    25ee:	0f be       	out	0x3f, r0	; 63
    25f0:	cd bf       	out	0x3d, r28	; 61
    25f2:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    25f4:	80 91 00 14 	lds	r24, 0x1400
    25f8:	84 30       	cpi	r24, 0x04	; 4
    25fa:	49 f5       	brne	.+82     	; 0x264e <RNDIS_Device_USBTask+0x74>
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpointNumber);
    25fc:	f8 01       	movw	r30, r16
    25fe:	81 85       	ldd	r24, Z+9	; 0x09
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    2600:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    2604:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    2608:	80 ff       	sbrs	r24, 0
    260a:	21 c0       	rjmp	.+66     	; 0x264e <RNDIS_Device_USBTask+0x74>
    260c:	0b 56       	subi	r16, 0x6B	; 107
    260e:	1f 4f       	sbci	r17, 0xFF	; 255
    2610:	f8 01       	movw	r30, r16
    2612:	80 81       	ld	r24, Z
    2614:	05 59       	subi	r16, 0x95	; 149
    2616:	10 40       	sbci	r17, 0x00	; 0
    2618:	88 23       	and	r24, r24
    261a:	c9 f0       	breq	.+50     	; 0x264e <RNDIS_Device_USBTask+0x74>
				.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE),
				.bRequest      = RNDIS_NOTIF_ResponseAvailable,
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};
    261c:	de 01       	movw	r26, r28
    261e:	11 96       	adiw	r26, 0x01	; 1
    2620:	ef ee       	ldi	r30, 0xEF	; 239
    2622:	f1 e0       	ldi	r31, 0x01	; 1
    2624:	88 e0       	ldi	r24, 0x08	; 8
    2626:	01 90       	ld	r0, Z+
    2628:	0d 92       	st	X+, r0
    262a:	81 50       	subi	r24, 0x01	; 1
    262c:	e1 f7       	brne	.-8      	; 0x2626 <RNDIS_Device_USBTask+0x4c>

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    262e:	ce 01       	movw	r24, r28
    2630:	01 96       	adiw	r24, 0x01	; 1
    2632:	68 e0       	ldi	r22, 0x08	; 8
    2634:	70 e0       	ldi	r23, 0x00	; 0
    2636:	40 e0       	ldi	r20, 0x00	; 0
    2638:	50 e0       	ldi	r21, 0x00	; 0
    263a:	70 dd       	rcall	.-1312   	; 0x211c <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    263c:	80 91 e8 00 	lds	r24, 0x00E8
    2640:	8e 77       	andi	r24, 0x7E	; 126
    2642:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    2646:	0b 56       	subi	r16, 0x6B	; 107
    2648:	1f 4f       	sbci	r17, 0xFF	; 255
    264a:	f8 01       	movw	r30, r16
    264c:	10 82       	st	Z, r1
	}
}
    264e:	28 96       	adiw	r28, 0x08	; 8
    2650:	0f b6       	in	r0, 0x3f	; 63
    2652:	f8 94       	cli
    2654:	de bf       	out	0x3e, r29	; 62
    2656:	0f be       	out	0x3f, r0	; 63
    2658:	cd bf       	out	0x3d, r28	; 61
    265a:	cf 91       	pop	r28
    265c:	df 91       	pop	r29
    265e:	1f 91       	pop	r17
    2660:	0f 91       	pop	r16
    2662:	08 95       	ret

00002664 <RNDIS_Device_ReadPacket>:
}

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    2664:	ef 92       	push	r14
    2666:	ff 92       	push	r15
    2668:	0f 93       	push	r16
    266a:	1f 93       	push	r17
    266c:	df 93       	push	r29
    266e:	cf 93       	push	r28
    2670:	cd b7       	in	r28, 0x3d	; 61
    2672:	de b7       	in	r29, 0x3e	; 62
    2674:	ac 97       	sbiw	r28, 0x2c	; 44
    2676:	0f b6       	in	r0, 0x3f	; 63
    2678:	f8 94       	cli
    267a:	de bf       	out	0x3e, r29	; 62
    267c:	0f be       	out	0x3f, r0	; 63
    267e:	cd bf       	out	0x3d, r28	; 61
    2680:	fc 01       	movw	r30, r24
    2682:	7b 01       	movw	r14, r22
    2684:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    2686:	80 91 00 14 	lds	r24, 0x1400
    268a:	84 30       	cpi	r24, 0x04	; 4
    268c:	d1 f5       	brne	.+116    	; 0x2702 <RNDIS_Device_ReadPacket+0x9e>
    268e:	ea 56       	subi	r30, 0x6A	; 106
    2690:	ff 4f       	sbci	r31, 0xFF	; 255
    2692:	80 81       	ld	r24, Z
    2694:	e6 59       	subi	r30, 0x96	; 150
    2696:	f0 40       	sbci	r31, 0x00	; 0
    2698:	82 30       	cpi	r24, 0x02	; 2
    269a:	99 f5       	brne	.+102    	; 0x2702 <RNDIS_Device_ReadPacket+0x9e>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}
	
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpointNumber);
    269c:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
    269e:	80 93 e9 00 	sts	0x00E9, r24
	
	*PacketLength = 0;
    26a2:	fa 01       	movw	r30, r20
    26a4:	11 82       	std	Z+1, r1	; 0x01
    26a6:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    26a8:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    26ac:	82 ff       	sbrs	r24, 2
    26ae:	27 c0       	rjmp	.+78     	; 0x26fe <RNDIS_Device_ReadPacket+0x9a>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;	
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    26b0:	ce 01       	movw	r24, r28
    26b2:	01 96       	adiw	r24, 0x01	; 1
    26b4:	6c e2       	ldi	r22, 0x2C	; 44
    26b6:	70 e0       	ldi	r23, 0x00	; 0
    26b8:	40 e0       	ldi	r20, 0x00	; 0
    26ba:	50 e0       	ldi	r21, 0x00	; 0
    26bc:	dd dc       	rcall	.-1606   	; 0x2078 <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    26be:	2d 85       	ldd	r18, Y+13	; 0x0d
    26c0:	3e 85       	ldd	r19, Y+14	; 0x0e
    26c2:	4f 85       	ldd	r20, Y+15	; 0x0f
    26c4:	58 89       	ldd	r21, Y+16	; 0x10
    26c6:	2d 3d       	cpi	r18, 0xDD	; 221
    26c8:	f5 e0       	ldi	r31, 0x05	; 5
    26ca:	3f 07       	cpc	r19, r31
    26cc:	f0 e0       	ldi	r31, 0x00	; 0
    26ce:	4f 07       	cpc	r20, r31
    26d0:	f0 e0       	ldi	r31, 0x00	; 0
    26d2:	5f 07       	cpc	r21, r31
    26d4:	38 f0       	brcs	.+14     	; 0x26e4 <RNDIS_Device_ReadPacket+0x80>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    26d6:	80 91 eb 00 	lds	r24, 0x00EB
    26da:	80 62       	ori	r24, 0x20	; 32
    26dc:	80 93 eb 00 	sts	0x00EB, r24
    26e0:	80 e8       	ldi	r24, 0x80	; 128
    26e2:	10 c0       	rjmp	.+32     	; 0x2704 <RNDIS_Device_ReadPacket+0xa0>
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
	}
	
	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    26e4:	f8 01       	movw	r30, r16
    26e6:	31 83       	std	Z+1, r19	; 0x01
    26e8:	20 83       	st	Z, r18

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    26ea:	c7 01       	movw	r24, r14
    26ec:	b9 01       	movw	r22, r18
    26ee:	40 e0       	ldi	r20, 0x00	; 0
    26f0:	50 e0       	ldi	r21, 0x00	; 0
    26f2:	c2 dc       	rcall	.-1660   	; 0x2078 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    26f4:	80 91 e8 00 	lds	r24, 0x00E8
    26f8:	8b 77       	andi	r24, 0x7B	; 123
    26fa:	80 93 e8 00 	sts	0x00E8, r24
    26fe:	80 e0       	ldi	r24, 0x00	; 0
    2700:	01 c0       	rjmp	.+2      	; 0x2704 <RNDIS_Device_ReadPacket+0xa0>
	Endpoint_ClearOUT();
	
	return ENDPOINT_RWSTREAM_NoError;
    2702:	82 e0       	ldi	r24, 0x02	; 2
}
    2704:	ac 96       	adiw	r28, 0x2c	; 44
    2706:	0f b6       	in	r0, 0x3f	; 63
    2708:	f8 94       	cli
    270a:	de bf       	out	0x3e, r29	; 62
    270c:	0f be       	out	0x3f, r0	; 63
    270e:	cd bf       	out	0x3d, r28	; 61
    2710:	cf 91       	pop	r28
    2712:	df 91       	pop	r29
    2714:	1f 91       	pop	r17
    2716:	0f 91       	pop	r16
    2718:	ff 90       	pop	r15
    271a:	ef 90       	pop	r14
    271c:	08 95       	ret

0000271e <RNDIS_Device_ConfigureEndpoints>:
			break;
	}
}

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    271e:	1f 93       	push	r17
    2720:	cf 93       	push	r28
    2722:	df 93       	push	r29
    2724:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    2726:	45 96       	adiw	r24, 0x15	; 21
    2728:	fc 01       	movw	r30, r24
    272a:	86 e8       	ldi	r24, 0x86	; 134
    272c:	df 01       	movw	r26, r30
    272e:	1d 92       	st	X+, r1
    2730:	8a 95       	dec	r24
    2732:	e9 f7       	brne	.-6      	; 0x272e <RNDIS_Device_ConfigureEndpoints+0x10>
    2734:	11 e0       	ldi	r17, 0x01	; 1
		uint16_t Size;
		uint8_t  Type;
		uint8_t  Direction;
		bool     DoubleBanked;

		if (EndpointNum == RNDISInterfaceInfo->Config.DataINEndpointNumber)
    2736:	89 81       	ldd	r24, Y+1	; 0x01
    2738:	18 17       	cp	r17, r24
    273a:	29 f4       	brne	.+10     	; 0x2746 <RNDIS_Device_ConfigureEndpoints+0x28>
		{
			Size         = RNDISInterfaceInfo->Config.DataINEndpointSize;
    273c:	6a 81       	ldd	r22, Y+2	; 0x02
    273e:	7b 81       	ldd	r23, Y+3	; 0x03
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataINEndpointDoubleBank;
    2740:	8c 81       	ldd	r24, Y+4	; 0x04
    2742:	52 e0       	ldi	r21, 0x02	; 2
    2744:	10 c0       	rjmp	.+32     	; 0x2766 <RNDIS_Device_ConfigureEndpoints+0x48>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.DataOUTEndpointNumber)
    2746:	8d 81       	ldd	r24, Y+5	; 0x05
    2748:	18 17       	cp	r17, r24
    274a:	31 f4       	brne	.+12     	; 0x2758 <RNDIS_Device_ConfigureEndpoints+0x3a>
		{
			Size         = RNDISInterfaceInfo->Config.DataOUTEndpointSize;
    274c:	6e 81       	ldd	r22, Y+6	; 0x06
    274e:	7f 81       	ldd	r23, Y+7	; 0x07
			Direction    = ENDPOINT_DIR_OUT;
			Type         = EP_TYPE_BULK;
			DoubleBanked = RNDISInterfaceInfo->Config.DataOUTEndpointDoubleBank;
    2750:	88 85       	ldd	r24, Y+8	; 0x08
    2752:	52 e0       	ldi	r21, 0x02	; 2
    2754:	30 e0       	ldi	r19, 0x00	; 0
    2756:	08 c0       	rjmp	.+16     	; 0x2768 <RNDIS_Device_ConfigureEndpoints+0x4a>
		}
		else if (EndpointNum == RNDISInterfaceInfo->Config.NotificationEndpointNumber)
    2758:	89 85       	ldd	r24, Y+9	; 0x09
    275a:	18 17       	cp	r17, r24
    275c:	39 f5       	brne	.+78     	; 0x27ac <RNDIS_Device_ConfigureEndpoints+0x8e>
		{
			Size         = RNDISInterfaceInfo->Config.NotificationEndpointSize;
    275e:	6a 85       	ldd	r22, Y+10	; 0x0a
    2760:	7b 85       	ldd	r23, Y+11	; 0x0b
			Direction    = ENDPOINT_DIR_IN;
			Type         = EP_TYPE_INTERRUPT;
			DoubleBanked = RNDISInterfaceInfo->Config.NotificationEndpointDoubleBank;
    2762:	8c 85       	ldd	r24, Y+12	; 0x0c
    2764:	53 e0       	ldi	r21, 0x03	; 3
    2766:	30 e8       	ldi	r19, 0x80	; 128
		else
		{
			continue;
		}

		if (!(Endpoint_ConfigureEndpoint(EndpointNum, Type, Direction, Size,
    2768:	88 23       	and	r24, r24
    276a:	11 f4       	brne	.+4      	; 0x2770 <RNDIS_Device_ConfigureEndpoints+0x52>
    276c:	40 e0       	ldi	r20, 0x00	; 0
    276e:	01 c0       	rjmp	.+2      	; 0x2772 <RNDIS_Device_ConfigureEndpoints+0x54>
    2770:	44 e0       	ldi	r20, 0x04	; 4
    2772:	20 e0       	ldi	r18, 0x00	; 0
    2774:	88 e0       	ldi	r24, 0x08	; 8
    2776:	90 e0       	ldi	r25, 0x00	; 0
    2778:	03 c0       	rjmp	.+6      	; 0x2780 <RNDIS_Device_ConfigureEndpoints+0x62>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    277a:	2f 5f       	subi	r18, 0xFF	; 255
					CheckBytes <<= 1;
    277c:	88 0f       	add	r24, r24
    277e:	99 1f       	adc	r25, r25
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    2780:	86 17       	cp	r24, r22
    2782:	97 07       	cpc	r25, r23
    2784:	d0 f3       	brcs	.-12     	; 0x277a <RNDIS_Device_ConfigureEndpoints+0x5c>
			                                              const uint8_t Type,
			                                              const uint8_t Direction,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, ((Type << EPTYPE0) | (Direction ? (1 << EPDIR) : 0)),
    2786:	85 2f       	mov	r24, r21
    2788:	90 e0       	ldi	r25, 0x00	; 0
    278a:	56 e0       	ldi	r21, 0x06	; 6
    278c:	88 0f       	add	r24, r24
    278e:	99 1f       	adc	r25, r25
    2790:	5a 95       	dec	r21
    2792:	e1 f7       	brne	.-8      	; 0x278c <RNDIS_Device_ConfigureEndpoints+0x6e>
    2794:	60 e0       	ldi	r22, 0x00	; 0
    2796:	31 11       	cpse	r19, r1
    2798:	61 e0       	ldi	r22, 0x01	; 1
    279a:	68 2b       	or	r22, r24
    279c:	42 60       	ori	r20, 0x02	; 2
    279e:	22 95       	swap	r18
    27a0:	20 7f       	andi	r18, 0xF0	; 240
    27a2:	42 2b       	or	r20, r18
    27a4:	81 2f       	mov	r24, r17
    27a6:	b7 d9       	rcall	.-3218   	; 0x1b16 <Endpoint_ConfigureEndpoint_Prv>
    27a8:	88 23       	and	r24, r24
    27aa:	29 f0       	breq	.+10     	; 0x27b6 <RNDIS_Device_ConfigureEndpoints+0x98>

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	for (uint8_t EndpointNum = 1; EndpointNum < ENDPOINT_TOTAL_ENDPOINTS; EndpointNum++)
    27ac:	1f 5f       	subi	r17, 0xFF	; 255
    27ae:	17 30       	cpi	r17, 0x07	; 7
    27b0:	09 f0       	breq	.+2      	; 0x27b4 <RNDIS_Device_ConfigureEndpoints+0x96>
    27b2:	c1 cf       	rjmp	.-126    	; 0x2736 <RNDIS_Device_ConfigureEndpoints+0x18>
    27b4:	81 e0       	ldi	r24, 0x01	; 1
			return false;
		}
	}

	return true;
}
    27b6:	df 91       	pop	r29
    27b8:	cf 91       	pop	r28
    27ba:	1f 91       	pop	r17
    27bc:	08 95       	ret

000027be <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    27be:	ef 92       	push	r14
    27c0:	ff 92       	push	r15
    27c2:	0f 93       	push	r16
    27c4:	1f 93       	push	r17
    27c6:	cf 93       	push	r28
    27c8:	df 93       	push	r29
    27ca:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    27cc:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    27d0:	83 ff       	sbrs	r24, 3
    27d2:	b6 c2       	rjmp	.+1388   	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    27d4:	88 81       	ld	r24, Y
    27d6:	90 e0       	ldi	r25, 0x00	; 0
    27d8:	20 91 05 14 	lds	r18, 0x1405
    27dc:	30 91 06 14 	lds	r19, 0x1406
    27e0:	28 17       	cp	r18, r24
    27e2:	39 07       	cpc	r19, r25
    27e4:	09 f0       	breq	.+2      	; 0x27e8 <RNDIS_Device_ProcessControlRequest+0x2a>
    27e6:	ac c2       	rjmp	.+1368   	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
	  return;

	switch (USB_ControlRequest.bRequest)
    27e8:	80 91 02 14 	lds	r24, 0x1402
    27ec:	88 23       	and	r24, r24
    27ee:	21 f0       	breq	.+8      	; 0x27f8 <RNDIS_Device_ProcessControlRequest+0x3a>
    27f0:	81 30       	cpi	r24, 0x01	; 1
    27f2:	09 f0       	breq	.+2      	; 0x27f6 <RNDIS_Device_ProcessControlRequest+0x38>
    27f4:	a5 c2       	rjmp	.+1354   	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
    27f6:	57 c2       	rjmp	.+1198   	; 0x2ca6 <RNDIS_Device_ProcessControlRequest+0x4e8>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    27f8:	80 91 01 14 	lds	r24, 0x1401
    27fc:	81 32       	cpi	r24, 0x21	; 33
    27fe:	09 f0       	breq	.+2      	; 0x2802 <RNDIS_Device_ProcessControlRequest+0x44>
    2800:	9f c2       	rjmp	.+1342   	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2802:	80 91 e8 00 	lds	r24, 0x00E8
    2806:	87 7f       	andi	r24, 0xF7	; 247
    2808:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    280c:	8e 01       	movw	r16, r28
    280e:	0b 5e       	subi	r16, 0xEB	; 235
    2810:	1f 4f       	sbci	r17, 0xFF	; 255
    2812:	60 91 07 14 	lds	r22, 0x1407
    2816:	70 91 08 14 	lds	r23, 0x1408
    281a:	c8 01       	movw	r24, r16
    281c:	8b db       	rcall	.-2282   	; 0x1f34 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    281e:	80 91 e8 00 	lds	r24, 0x00E8
    2822:	8e 77       	andi	r24, 0x7E	; 126
    2824:	80 93 e8 00 	sts	0x00E8, r24
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    2828:	8d 89       	ldd	r24, Y+21	; 0x15
    282a:	9e 89       	ldd	r25, Y+22	; 0x16
    282c:	af 89       	ldd	r26, Y+23	; 0x17
    282e:	b8 8d       	ldd	r27, Y+24	; 0x18
    2830:	84 30       	cpi	r24, 0x04	; 4
    2832:	91 05       	cpc	r25, r1
    2834:	a1 05       	cpc	r26, r1
    2836:	b1 05       	cpc	r27, r1
    2838:	09 f4       	brne	.+2      	; 0x283c <RNDIS_Device_ProcessControlRequest+0x7e>
    283a:	77 c0       	rjmp	.+238    	; 0x292a <RNDIS_Device_ProcessControlRequest+0x16c>
    283c:	85 30       	cpi	r24, 0x05	; 5
    283e:	91 05       	cpc	r25, r1
    2840:	a1 05       	cpc	r26, r1
    2842:	b1 05       	cpc	r27, r1
    2844:	58 f4       	brcc	.+22     	; 0x285c <RNDIS_Device_ProcessControlRequest+0x9e>
    2846:	82 30       	cpi	r24, 0x02	; 2
    2848:	91 05       	cpc	r25, r1
    284a:	a1 05       	cpc	r26, r1
    284c:	b1 05       	cpc	r27, r1
    284e:	c1 f0       	breq	.+48     	; 0x2880 <RNDIS_Device_ProcessControlRequest+0xc2>
    2850:	03 97       	sbiw	r24, 0x03	; 3
    2852:	a1 05       	cpc	r26, r1
    2854:	b1 05       	cpc	r27, r1
    2856:	09 f0       	breq	.+2      	; 0x285a <RNDIS_Device_ProcessControlRequest+0x9c>
    2858:	73 c2       	rjmp	.+1254   	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
    285a:	5d c0       	rjmp	.+186    	; 0x2916 <RNDIS_Device_ProcessControlRequest+0x158>
    285c:	86 30       	cpi	r24, 0x06	; 6
    285e:	91 05       	cpc	r25, r1
    2860:	a1 05       	cpc	r26, r1
    2862:	b1 05       	cpc	r27, r1
    2864:	09 f4       	brne	.+2      	; 0x2868 <RNDIS_Device_ProcessControlRequest+0xaa>
    2866:	e7 c1       	rjmp	.+974    	; 0x2c36 <RNDIS_Device_ProcessControlRequest+0x478>
    2868:	86 30       	cpi	r24, 0x06	; 6
    286a:	91 05       	cpc	r25, r1
    286c:	a1 05       	cpc	r26, r1
    286e:	b1 05       	cpc	r27, r1
    2870:	08 f4       	brcc	.+2      	; 0x2874 <RNDIS_Device_ProcessControlRequest+0xb6>
    2872:	96 c1       	rjmp	.+812    	; 0x2ba0 <RNDIS_Device_ProcessControlRequest+0x3e2>
    2874:	08 97       	sbiw	r24, 0x08	; 8
    2876:	a1 05       	cpc	r26, r1
    2878:	b1 05       	cpc	r27, r1
    287a:	09 f0       	breq	.+2      	; 0x287e <RNDIS_Device_ProcessControlRequest+0xc0>
    287c:	61 c2       	rjmp	.+1218   	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
    287e:	f7 c1       	rjmp	.+1006   	; 0x2c6e <RNDIS_Device_ProcessControlRequest+0x4b0>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2880:	cb 56       	subi	r28, 0x6B	; 107
    2882:	df 4f       	sbci	r29, 0xFF	; 255
    2884:	21 e0       	ldi	r18, 0x01	; 1
    2886:	28 83       	st	Y, r18
    2888:	c5 59       	subi	r28, 0x95	; 149
    288a:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    288c:	82 e0       	ldi	r24, 0x02	; 2
    288e:	90 e0       	ldi	r25, 0x00	; 0
    2890:	a0 e0       	ldi	r26, 0x00	; 0
    2892:	b0 e8       	ldi	r27, 0x80	; 128
    2894:	8d 8b       	std	Y+21, r24	; 0x15
    2896:	9e 8b       	std	Y+22, r25	; 0x16
    2898:	af 8b       	std	Y+23, r26	; 0x17
    289a:	b8 8f       	std	Y+24, r27	; 0x18
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    289c:	84 e3       	ldi	r24, 0x34	; 52
    289e:	90 e0       	ldi	r25, 0x00	; 0
    28a0:	a0 e0       	ldi	r26, 0x00	; 0
    28a2:	b0 e0       	ldi	r27, 0x00	; 0
    28a4:	f8 01       	movw	r30, r16
    28a6:	84 83       	std	Z+4, r24	; 0x04
    28a8:	95 83       	std	Z+5, r25	; 0x05
    28aa:	a6 83       	std	Z+6, r26	; 0x06
    28ac:	b7 83       	std	Z+7, r27	; 0x07
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    28ae:	14 86       	std	Z+12, r1	; 0x0c
    28b0:	15 86       	std	Z+13, r1	; 0x0d
    28b2:	16 86       	std	Z+14, r1	; 0x0e
    28b4:	17 86       	std	Z+15, r1	; 0x0f

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    28b6:	81 e0       	ldi	r24, 0x01	; 1
    28b8:	90 e0       	ldi	r25, 0x00	; 0
    28ba:	a0 e0       	ldi	r26, 0x00	; 0
    28bc:	b0 e0       	ldi	r27, 0x00	; 0
    28be:	80 8b       	std	Z+16, r24	; 0x10
    28c0:	91 8b       	std	Z+17, r25	; 0x11
    28c2:	a2 8b       	std	Z+18, r26	; 0x12
    28c4:	b3 8b       	std	Z+19, r27	; 0x13
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    28c6:	14 8a       	std	Z+20, r1	; 0x14
    28c8:	15 8a       	std	Z+21, r1	; 0x15
    28ca:	16 8a       	std	Z+22, r1	; 0x16
    28cc:	17 8a       	std	Z+23, r1	; 0x17
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    28ce:	80 8f       	std	Z+24, r24	; 0x18
    28d0:	91 8f       	std	Z+25, r25	; 0x19
    28d2:	a2 8f       	std	Z+26, r26	; 0x1a
    28d4:	b3 8f       	std	Z+27, r27	; 0x1b
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    28d6:	14 8e       	std	Z+28, r1	; 0x1c
    28d8:	15 8e       	std	Z+29, r1	; 0x1d
    28da:	16 8e       	std	Z+30, r1	; 0x1e
    28dc:	17 8e       	std	Z+31, r1	; 0x1f
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    28de:	80 a3       	std	Z+32, r24	; 0x20
    28e0:	91 a3       	std	Z+33, r25	; 0x21
    28e2:	a2 a3       	std	Z+34, r26	; 0x22
    28e4:	b3 a3       	std	Z+35, r27	; 0x23
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    28e6:	88 e0       	ldi	r24, 0x08	; 8
    28e8:	96 e0       	ldi	r25, 0x06	; 6
    28ea:	a0 e0       	ldi	r26, 0x00	; 0
    28ec:	b0 e0       	ldi	r27, 0x00	; 0
    28ee:	84 a3       	std	Z+36, r24	; 0x24
    28f0:	95 a3       	std	Z+37, r25	; 0x25
    28f2:	a6 a3       	std	Z+38, r26	; 0x26
    28f4:	b7 a3       	std	Z+39, r27	; 0x27
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    28f6:	10 a6       	std	Z+40, r1	; 0x28
    28f8:	11 a6       	std	Z+41, r1	; 0x29
    28fa:	12 a6       	std	Z+42, r1	; 0x2a
    28fc:	13 a6       	std	Z+43, r1	; 0x2b
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    28fe:	14 a6       	std	Z+44, r1	; 0x2c
    2900:	15 a6       	std	Z+45, r1	; 0x2d
    2902:	16 a6       	std	Z+46, r1	; 0x2e
    2904:	17 a6       	std	Z+47, r1	; 0x2f
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    2906:	10 aa       	std	Z+48, r1	; 0x30
    2908:	11 aa       	std	Z+49, r1	; 0x31
    290a:	12 aa       	std	Z+50, r1	; 0x32
    290c:	13 aa       	std	Z+51, r1	; 0x33

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    290e:	ca 56       	subi	r28, 0x6A	; 106
    2910:	df 4f       	sbci	r29, 0xFF	; 255
    2912:	28 83       	st	Y, r18
    2914:	15 c2       	rjmp	.+1066   	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    2916:	cb 56       	subi	r28, 0x6B	; 107
    2918:	df 4f       	sbci	r29, 0xFF	; 255
    291a:	19 92       	st	Y+, r1

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    291c:	f8 01       	movw	r30, r16
    291e:	14 82       	std	Z+4, r1	; 0x04
    2920:	15 82       	std	Z+5, r1	; 0x05
    2922:	16 82       	std	Z+6, r1	; 0x06
    2924:	17 82       	std	Z+7, r1	; 0x07

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    2926:	18 82       	st	Y, r1
    2928:	0b c2       	rjmp	.+1046   	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    292a:	cb 56       	subi	r28, 0x6B	; 107
    292c:	df 4f       	sbci	r29, 0xFF	; 255
    292e:	81 e0       	ldi	r24, 0x01	; 1
    2930:	88 83       	st	Y, r24
    2932:	c5 59       	subi	r28, 0x95	; 149
    2934:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    2936:	f8 01       	movw	r30, r16
    2938:	24 85       	ldd	r18, Z+12	; 0x0c
    293a:	35 85       	ldd	r19, Z+13	; 0x0d
    293c:	46 85       	ldd	r20, Z+14	; 0x0e
    293e:	57 85       	ldd	r21, Z+15	; 0x0f

			void*    QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                      le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    2940:	fd e2       	ldi	r31, 0x2D	; 45
    2942:	ef 2e       	mov	r14, r31
    2944:	f1 2c       	mov	r15, r1
    2946:	ec 0e       	add	r14, r28
    2948:	fd 1e       	adc	r15, r29
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    294a:	84 e0       	ldi	r24, 0x04	; 4
    294c:	90 e0       	ldi	r25, 0x00	; 0
    294e:	a0 e0       	ldi	r26, 0x00	; 0
    2950:	b0 e8       	ldi	r27, 0x80	; 128
    2952:	8d 8b       	std	Y+21, r24	; 0x15
    2954:	9e 8b       	std	Y+22, r25	; 0x16
    2956:	af 8b       	std	Y+23, r26	; 0x17
    2958:	b8 8f       	std	Y+24, r27	; 0x18
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    295a:	2e 30       	cpi	r18, 0x0E	; 14
    295c:	f1 e0       	ldi	r31, 0x01	; 1
    295e:	3f 07       	cpc	r19, r31
    2960:	f1 e0       	ldi	r31, 0x01	; 1
    2962:	4f 07       	cpc	r20, r31
    2964:	f0 e0       	ldi	r31, 0x00	; 0
    2966:	5f 07       	cpc	r21, r31
    2968:	09 f4       	brne	.+2      	; 0x296c <RNDIS_Device_ProcessControlRequest+0x1ae>
    296a:	e7 c0       	rjmp	.+462    	; 0x2b3a <RNDIS_Device_ProcessControlRequest+0x37c>
    296c:	2f 30       	cpi	r18, 0x0F	; 15
    296e:	61 e0       	ldi	r22, 0x01	; 1
    2970:	36 07       	cpc	r19, r22
    2972:	61 e0       	ldi	r22, 0x01	; 1
    2974:	46 07       	cpc	r20, r22
    2976:	60 e0       	ldi	r22, 0x00	; 0
    2978:	56 07       	cpc	r21, r22
    297a:	08 f0       	brcs	.+2      	; 0x297e <RNDIS_Device_ProcessControlRequest+0x1c0>
    297c:	58 c0       	rjmp	.+176    	; 0x2a2e <RNDIS_Device_ProcessControlRequest+0x270>
    297e:	26 30       	cpi	r18, 0x06	; 6
    2980:	81 e0       	ldi	r24, 0x01	; 1
    2982:	38 07       	cpc	r19, r24
    2984:	81 e0       	ldi	r24, 0x01	; 1
    2986:	48 07       	cpc	r20, r24
    2988:	80 e0       	ldi	r24, 0x00	; 0
    298a:	58 07       	cpc	r21, r24
    298c:	09 f4       	brne	.+2      	; 0x2990 <RNDIS_Device_ProcessControlRequest+0x1d2>
    298e:	ae c0       	rjmp	.+348    	; 0x2aec <RNDIS_Device_ProcessControlRequest+0x32e>
    2990:	27 30       	cpi	r18, 0x07	; 7
    2992:	e1 e0       	ldi	r30, 0x01	; 1
    2994:	3e 07       	cpc	r19, r30
    2996:	e1 e0       	ldi	r30, 0x01	; 1
    2998:	4e 07       	cpc	r20, r30
    299a:	e0 e0       	ldi	r30, 0x00	; 0
    299c:	5e 07       	cpc	r21, r30
    299e:	f8 f4       	brcc	.+62     	; 0x29de <RNDIS_Device_ProcessControlRequest+0x220>
    29a0:	22 30       	cpi	r18, 0x02	; 2
    29a2:	f1 e0       	ldi	r31, 0x01	; 1
    29a4:	3f 07       	cpc	r19, r31
    29a6:	f1 e0       	ldi	r31, 0x01	; 1
    29a8:	4f 07       	cpc	r20, r31
    29aa:	f0 e0       	ldi	r31, 0x00	; 0
    29ac:	5f 07       	cpc	r21, r31
    29ae:	09 f4       	brne	.+2      	; 0x29b2 <RNDIS_Device_ProcessControlRequest+0x1f4>
    29b0:	cd c0       	rjmp	.+410    	; 0x2b4c <RNDIS_Device_ProcessControlRequest+0x38e>
    29b2:	23 30       	cpi	r18, 0x03	; 3
    29b4:	61 e0       	ldi	r22, 0x01	; 1
    29b6:	36 07       	cpc	r19, r22
    29b8:	61 e0       	ldi	r22, 0x01	; 1
    29ba:	46 07       	cpc	r20, r22
    29bc:	60 e0       	ldi	r22, 0x00	; 0
    29be:	56 07       	cpc	r21, r22
    29c0:	38 f4       	brcc	.+14     	; 0x29d0 <RNDIS_Device_ProcessControlRequest+0x212>
    29c2:	21 50       	subi	r18, 0x01	; 1
    29c4:	31 40       	sbci	r19, 0x01	; 1
    29c6:	41 40       	sbci	r20, 0x01	; 1
    29c8:	50 40       	sbci	r21, 0x00	; 0
    29ca:	09 f0       	breq	.+2      	; 0x29ce <RNDIS_Device_ProcessControlRequest+0x210>
    29cc:	cf c0       	rjmp	.+414    	; 0x2b6c <RNDIS_Device_ProcessControlRequest+0x3ae>
    29ce:	80 c0       	rjmp	.+256    	; 0x2ad0 <RNDIS_Device_ProcessControlRequest+0x312>
    29d0:	25 50       	subi	r18, 0x05	; 5
    29d2:	31 40       	sbci	r19, 0x01	; 1
    29d4:	41 40       	sbci	r20, 0x01	; 1
    29d6:	50 40       	sbci	r21, 0x00	; 0
    29d8:	08 f0       	brcs	.+2      	; 0x29dc <RNDIS_Device_ProcessControlRequest+0x21e>
    29da:	c8 c0       	rjmp	.+400    	; 0x2b6c <RNDIS_Device_ProcessControlRequest+0x3ae>
    29dc:	b7 c0       	rjmp	.+366    	; 0x2b4c <RNDIS_Device_ProcessControlRequest+0x38e>
    29de:	2c 30       	cpi	r18, 0x0C	; 12
    29e0:	f1 e0       	ldi	r31, 0x01	; 1
    29e2:	3f 07       	cpc	r19, r31
    29e4:	f1 e0       	ldi	r31, 0x01	; 1
    29e6:	4f 07       	cpc	r20, r31
    29e8:	f0 e0       	ldi	r31, 0x00	; 0
    29ea:	5f 07       	cpc	r21, r31
    29ec:	80 f4       	brcc	.+32     	; 0x2a0e <RNDIS_Device_ProcessControlRequest+0x250>
    29ee:	2a 30       	cpi	r18, 0x0A	; 10
    29f0:	61 e0       	ldi	r22, 0x01	; 1
    29f2:	36 07       	cpc	r19, r22
    29f4:	61 e0       	ldi	r22, 0x01	; 1
    29f6:	46 07       	cpc	r20, r22
    29f8:	60 e0       	ldi	r22, 0x00	; 0
    29fa:	56 07       	cpc	r21, r22
    29fc:	08 f0       	brcs	.+2      	; 0x2a00 <RNDIS_Device_ProcessControlRequest+0x242>
    29fe:	76 c0       	rjmp	.+236    	; 0x2aec <RNDIS_Device_ProcessControlRequest+0x32e>
    2a00:	27 50       	subi	r18, 0x07	; 7
    2a02:	31 40       	sbci	r19, 0x01	; 1
    2a04:	41 40       	sbci	r20, 0x01	; 1
    2a06:	50 40       	sbci	r21, 0x00	; 0
    2a08:	09 f0       	breq	.+2      	; 0x2a0c <RNDIS_Device_ProcessControlRequest+0x24e>
    2a0a:	b0 c0       	rjmp	.+352    	; 0x2b6c <RNDIS_Device_ProcessControlRequest+0x3ae>
    2a0c:	81 c0       	rjmp	.+258    	; 0x2b10 <RNDIS_Device_ProcessControlRequest+0x352>
    2a0e:	2c 30       	cpi	r18, 0x0C	; 12
    2a10:	e1 e0       	ldi	r30, 0x01	; 1
    2a12:	3e 07       	cpc	r19, r30
    2a14:	e1 e0       	ldi	r30, 0x01	; 1
    2a16:	4e 07       	cpc	r20, r30
    2a18:	e0 e0       	ldi	r30, 0x00	; 0
    2a1a:	5e 07       	cpc	r21, r30
    2a1c:	09 f4       	brne	.+2      	; 0x2a20 <RNDIS_Device_ProcessControlRequest+0x262>
    2a1e:	61 c0       	rjmp	.+194    	; 0x2ae2 <RNDIS_Device_ProcessControlRequest+0x324>
    2a20:	2d 50       	subi	r18, 0x0D	; 13
    2a22:	31 40       	sbci	r19, 0x01	; 1
    2a24:	41 40       	sbci	r20, 0x01	; 1
    2a26:	50 40       	sbci	r21, 0x00	; 0
    2a28:	09 f0       	breq	.+2      	; 0x2a2c <RNDIS_Device_ProcessControlRequest+0x26e>
    2a2a:	a0 c0       	rjmp	.+320    	; 0x2b6c <RNDIS_Device_ProcessControlRequest+0x3ae>
    2a2c:	64 c0       	rjmp	.+200    	; 0x2af6 <RNDIS_Device_ProcessControlRequest+0x338>
    2a2e:	26 30       	cpi	r18, 0x06	; 6
    2a30:	61 e0       	ldi	r22, 0x01	; 1
    2a32:	36 07       	cpc	r19, r22
    2a34:	62 e0       	ldi	r22, 0x02	; 2
    2a36:	46 07       	cpc	r20, r22
    2a38:	60 e0       	ldi	r22, 0x00	; 0
    2a3a:	56 07       	cpc	r21, r22
    2a3c:	10 f5       	brcc	.+68     	; 0x2a82 <RNDIS_Device_ProcessControlRequest+0x2c4>
    2a3e:	21 30       	cpi	r18, 0x01	; 1
    2a40:	81 e0       	ldi	r24, 0x01	; 1
    2a42:	38 07       	cpc	r19, r24
    2a44:	82 e0       	ldi	r24, 0x02	; 2
    2a46:	48 07       	cpc	r20, r24
    2a48:	80 e0       	ldi	r24, 0x00	; 0
    2a4a:	58 07       	cpc	r21, r24
    2a4c:	08 f0       	brcs	.+2      	; 0x2a50 <RNDIS_Device_ProcessControlRequest+0x292>
    2a4e:	7e c0       	rjmp	.+252    	; 0x2b4c <RNDIS_Device_ProcessControlRequest+0x38e>
    2a50:	24 31       	cpi	r18, 0x14	; 20
    2a52:	e1 e0       	ldi	r30, 0x01	; 1
    2a54:	3e 07       	cpc	r19, r30
    2a56:	e1 e0       	ldi	r30, 0x01	; 1
    2a58:	4e 07       	cpc	r20, r30
    2a5a:	e0 e0       	ldi	r30, 0x00	; 0
    2a5c:	5e 07       	cpc	r21, r30
    2a5e:	09 f4       	brne	.+2      	; 0x2a62 <RNDIS_Device_ProcessControlRequest+0x2a4>
    2a60:	75 c0       	rjmp	.+234    	; 0x2b4c <RNDIS_Device_ProcessControlRequest+0x38e>
    2a62:	22 30       	cpi	r18, 0x02	; 2
    2a64:	f2 e0       	ldi	r31, 0x02	; 2
    2a66:	3f 07       	cpc	r19, r31
    2a68:	f1 e0       	ldi	r31, 0x01	; 1
    2a6a:	4f 07       	cpc	r20, r31
    2a6c:	f0 e0       	ldi	r31, 0x00	; 0
    2a6e:	5f 07       	cpc	r21, r31
    2a70:	09 f4       	brne	.+2      	; 0x2a74 <RNDIS_Device_ProcessControlRequest+0x2b6>
    2a72:	6c c0       	rjmp	.+216    	; 0x2b4c <RNDIS_Device_ProcessControlRequest+0x38e>
    2a74:	21 51       	subi	r18, 0x11	; 17
    2a76:	31 40       	sbci	r19, 0x01	; 1
    2a78:	41 40       	sbci	r20, 0x01	; 1
    2a7a:	50 40       	sbci	r21, 0x00	; 0
    2a7c:	09 f0       	breq	.+2      	; 0x2a80 <RNDIS_Device_ProcessControlRequest+0x2c2>
    2a7e:	76 c0       	rjmp	.+236    	; 0x2b6c <RNDIS_Device_ProcessControlRequest+0x3ae>
    2a80:	6a c0       	rjmp	.+212    	; 0x2b56 <RNDIS_Device_ProcessControlRequest+0x398>
    2a82:	24 30       	cpi	r18, 0x04	; 4
    2a84:	81 e0       	ldi	r24, 0x01	; 1
    2a86:	38 07       	cpc	r19, r24
    2a88:	81 e0       	ldi	r24, 0x01	; 1
    2a8a:	48 07       	cpc	r20, r24
    2a8c:	81 e0       	ldi	r24, 0x01	; 1
    2a8e:	58 07       	cpc	r21, r24
    2a90:	09 f4       	brne	.+2      	; 0x2a94 <RNDIS_Device_ProcessControlRequest+0x2d6>
    2a92:	4e c0       	rjmp	.+156    	; 0x2b30 <RNDIS_Device_ProcessControlRequest+0x372>
    2a94:	25 30       	cpi	r18, 0x05	; 5
    2a96:	e1 e0       	ldi	r30, 0x01	; 1
    2a98:	3e 07       	cpc	r19, r30
    2a9a:	e1 e0       	ldi	r30, 0x01	; 1
    2a9c:	4e 07       	cpc	r20, r30
    2a9e:	e1 e0       	ldi	r30, 0x01	; 1
    2aa0:	5e 07       	cpc	r21, r30
    2aa2:	58 f4       	brcc	.+22     	; 0x2aba <RNDIS_Device_ProcessControlRequest+0x2fc>
    2aa4:	21 50       	subi	r18, 0x01	; 1
    2aa6:	31 40       	sbci	r19, 0x01	; 1
    2aa8:	41 40       	sbci	r20, 0x01	; 1
    2aaa:	51 40       	sbci	r21, 0x01	; 1
    2aac:	22 30       	cpi	r18, 0x02	; 2
    2aae:	31 05       	cpc	r19, r1
    2ab0:	41 05       	cpc	r20, r1
    2ab2:	51 05       	cpc	r21, r1
    2ab4:	08 f0       	brcs	.+2      	; 0x2ab8 <RNDIS_Device_ProcessControlRequest+0x2fa>
    2ab6:	5a c0       	rjmp	.+180    	; 0x2b6c <RNDIS_Device_ProcessControlRequest+0x3ae>
    2ab8:	30 c0       	rjmp	.+96     	; 0x2b1a <RNDIS_Device_ProcessControlRequest+0x35c>
    2aba:	21 50       	subi	r18, 0x01	; 1
    2abc:	31 40       	sbci	r19, 0x01	; 1
    2abe:	42 40       	sbci	r20, 0x02	; 2
    2ac0:	51 40       	sbci	r21, 0x01	; 1
    2ac2:	23 30       	cpi	r18, 0x03	; 3
    2ac4:	31 05       	cpc	r19, r1
    2ac6:	41 05       	cpc	r20, r1
    2ac8:	51 05       	cpc	r21, r1
    2aca:	08 f0       	brcs	.+2      	; 0x2ace <RNDIS_Device_ProcessControlRequest+0x310>
    2acc:	4f c0       	rjmp	.+158    	; 0x2b6c <RNDIS_Device_ProcessControlRequest+0x3ae>
    2ace:	3e c0       	rjmp	.+124    	; 0x2b4c <RNDIS_Device_ProcessControlRequest+0x38e>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    2ad0:	c7 01       	movw	r24, r14
    2ad2:	66 eb       	ldi	r22, 0xB6	; 182
    2ad4:	73 e0       	ldi	r23, 0x03	; 3
    2ad6:	4c e6       	ldi	r20, 0x6C	; 108
    2ad8:	50 e0       	ldi	r21, 0x00	; 0
    2ada:	57 d1       	rcall	.+686    	; 0x2d8a <memcpy_P>
    2adc:	cc e6       	ldi	r28, 0x6C	; 108
    2ade:	d0 e0       	ldi	r29, 0x00	; 0
    2ae0:	12 c1       	rjmp	.+548    	; 0x2d06 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    2ae2:	8f ef       	ldi	r24, 0xFF	; 255
    2ae4:	9f ef       	ldi	r25, 0xFF	; 255
    2ae6:	af ef       	ldi	r26, 0xFF	; 255
    2ae8:	b0 e0       	ldi	r27, 0x00	; 0
    2aea:	39 c0       	rjmp	.+114    	; 0x2b5e <RNDIS_Device_ProcessControlRequest+0x3a0>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    2aec:	8c ed       	ldi	r24, 0xDC	; 220
    2aee:	95 e0       	ldi	r25, 0x05	; 5
    2af0:	a0 e0       	ldi	r26, 0x00	; 0
    2af2:	b0 e0       	ldi	r27, 0x00	; 0
    2af4:	34 c0       	rjmp	.+104    	; 0x2b5e <RNDIS_Device_ProcessControlRequest+0x3a0>

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    2af6:	6d 85       	ldd	r22, Y+13	; 0x0d
    2af8:	7e 85       	ldd	r23, Y+14	; 0x0e
    2afa:	fb 01       	movw	r30, r22
    2afc:	ef 01       	movw	r28, r30
    2afe:	09 90       	ld	r0, Y+
    2b00:	00 20       	and	r0, r0
    2b02:	e9 f7       	brne	.-6      	; 0x2afe <RNDIS_Device_ProcessControlRequest+0x340>
    2b04:	ce 1b       	sub	r28, r30
    2b06:	df 0b       	sbc	r29, r31

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    2b08:	c7 01       	movw	r24, r14
    2b0a:	ae 01       	movw	r20, r28
    2b0c:	73 d1       	rcall	.+742    	; 0x2df4 <memcpy>
    2b0e:	fb c0       	rjmp	.+502    	; 0x2d06 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    2b10:	80 ea       	ldi	r24, 0xA0	; 160
    2b12:	96 e8       	ldi	r25, 0x86	; 134
    2b14:	a1 e0       	ldi	r26, 0x01	; 1
    2b16:	b0 e0       	ldi	r27, 0x00	; 0
    2b18:	22 c0       	rjmp	.+68     	; 0x2b5e <RNDIS_Device_ProcessControlRequest+0x3a0>
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    2b1a:	d7 01       	movw	r26, r14
    2b1c:	fe 01       	movw	r30, r28
    2b1e:	3f 96       	adiw	r30, 0x0f	; 15
    2b20:	86 e0       	ldi	r24, 0x06	; 6
    2b22:	01 90       	ld	r0, Z+
    2b24:	0d 92       	st	X+, r0
    2b26:	81 50       	subi	r24, 0x01	; 1
    2b28:	e1 f7       	brne	.-8      	; 0x2b22 <RNDIS_Device_ProcessControlRequest+0x364>
    2b2a:	c6 e0       	ldi	r28, 0x06	; 6
    2b2c:	d0 e0       	ldi	r29, 0x00	; 0
    2b2e:	eb c0       	rjmp	.+470    	; 0x2d06 <RNDIS_Device_ProcessControlRequest+0x548>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    2b30:	81 e0       	ldi	r24, 0x01	; 1
    2b32:	90 e0       	ldi	r25, 0x00	; 0
    2b34:	a0 e0       	ldi	r26, 0x00	; 0
    2b36:	b0 e0       	ldi	r27, 0x00	; 0
    2b38:	12 c0       	rjmp	.+36     	; 0x2b5e <RNDIS_Device_ProcessControlRequest+0x3a0>

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    2b3a:	c9 56       	subi	r28, 0x69	; 105
    2b3c:	df 4f       	sbci	r29, 0xFF	; 255
    2b3e:	88 81       	ld	r24, Y
    2b40:	99 81       	ldd	r25, Y+1	; 0x01
    2b42:	aa 81       	ldd	r26, Y+2	; 0x02
    2b44:	bb 81       	ldd	r27, Y+3	; 0x03
    2b46:	c7 59       	subi	r28, 0x97	; 151
    2b48:	d0 40       	sbci	r29, 0x00	; 0
    2b4a:	09 c0       	rjmp	.+18     	; 0x2b5e <RNDIS_Device_ProcessControlRequest+0x3a0>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    2b4c:	1d a6       	std	Y+45, r1	; 0x2d
    2b4e:	1e a6       	std	Y+46, r1	; 0x2e
    2b50:	1f a6       	std	Y+47, r1	; 0x2f
    2b52:	18 aa       	std	Y+48, r1	; 0x30
    2b54:	08 c0       	rjmp	.+16     	; 0x2b66 <RNDIS_Device_ProcessControlRequest+0x3a8>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    2b56:	8c e5       	ldi	r24, 0x5C	; 92
    2b58:	96 e0       	ldi	r25, 0x06	; 6
    2b5a:	a0 e0       	ldi	r26, 0x00	; 0
    2b5c:	b0 e0       	ldi	r27, 0x00	; 0
    2b5e:	8d a7       	std	Y+45, r24	; 0x2d
    2b60:	9e a7       	std	Y+46, r25	; 0x2e
    2b62:	af a7       	std	Y+47, r26	; 0x2f
    2b64:	b8 ab       	std	Y+48, r27	; 0x30
    2b66:	c4 e0       	ldi	r28, 0x04	; 4
    2b68:	d0 e0       	ldi	r29, 0x00	; 0
    2b6a:	cd c0       	rjmp	.+410    	; 0x2d06 <RNDIS_Device_ProcessControlRequest+0x548>
				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    2b6c:	8b eb       	ldi	r24, 0xBB	; 187
    2b6e:	90 e0       	ldi	r25, 0x00	; 0
    2b70:	a0 e0       	ldi	r26, 0x00	; 0
    2b72:	b0 ec       	ldi	r27, 0xC0	; 192
    2b74:	f8 01       	movw	r30, r16
    2b76:	84 87       	std	Z+12, r24	; 0x0c
    2b78:	95 87       	std	Z+13, r25	; 0x0d
    2b7a:	a6 87       	std	Z+14, r26	; 0x0e
    2b7c:	b7 87       	std	Z+15, r27	; 0x0f
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    2b7e:	88 e1       	ldi	r24, 0x18	; 24
    2b80:	90 e0       	ldi	r25, 0x00	; 0
    2b82:	a0 e0       	ldi	r26, 0x00	; 0
    2b84:	b0 e0       	ldi	r27, 0x00	; 0
    2b86:	84 83       	std	Z+4, r24	; 0x04
    2b88:	95 83       	std	Z+5, r25	; 0x05
    2b8a:	a6 83       	std	Z+6, r26	; 0x06
    2b8c:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    2b8e:	10 8a       	std	Z+16, r1	; 0x10
    2b90:	11 8a       	std	Z+17, r1	; 0x11
    2b92:	12 8a       	std	Z+18, r1	; 0x12
    2b94:	13 8a       	std	Z+19, r1	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    2b96:	14 8a       	std	Z+20, r1	; 0x14
    2b98:	15 8a       	std	Z+21, r1	; 0x15
    2b9a:	16 8a       	std	Z+22, r1	; 0x16
    2b9c:	17 8a       	std	Z+23, r1	; 0x17
    2b9e:	d0 c0       	rjmp	.+416    	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2ba0:	cb 56       	subi	r28, 0x6B	; 107
    2ba2:	df 4f       	sbci	r29, 0xFF	; 255
    2ba4:	81 e0       	ldi	r24, 0x01	; 1
    2ba6:	88 83       	st	Y, r24
    2ba8:	c5 59       	subi	r28, 0x95	; 149
    2baa:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    2bac:	f8 01       	movw	r30, r16
    2bae:	24 85       	ldd	r18, Z+12	; 0x0c
    2bb0:	35 85       	ldd	r19, Z+13	; 0x0d
    2bb2:	46 85       	ldd	r20, Z+14	; 0x0e
    2bb4:	57 85       	ldd	r21, Z+15	; 0x0f

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    2bb6:	85 e0       	ldi	r24, 0x05	; 5
    2bb8:	90 e0       	ldi	r25, 0x00	; 0
    2bba:	a0 e0       	ldi	r26, 0x00	; 0
    2bbc:	b0 e8       	ldi	r27, 0x80	; 128
    2bbe:	8d 8b       	std	Y+21, r24	; 0x15
    2bc0:	9e 8b       	std	Y+22, r25	; 0x16
    2bc2:	af 8b       	std	Y+23, r26	; 0x17
    2bc4:	b8 8f       	std	Y+24, r27	; 0x18
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    2bc6:	80 e1       	ldi	r24, 0x10	; 16
    2bc8:	90 e0       	ldi	r25, 0x00	; 0
    2bca:	a0 e0       	ldi	r26, 0x00	; 0
    2bcc:	b0 e0       	ldi	r27, 0x00	; 0
    2bce:	84 83       	std	Z+4, r24	; 0x04
    2bd0:	95 83       	std	Z+5, r25	; 0x05
    2bd2:	a6 83       	std	Z+6, r26	; 0x06
    2bd4:	b7 83       	std	Z+7, r27	; 0x07
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    2bd6:	84 89       	ldd	r24, Z+20	; 0x14
    2bd8:	95 89       	ldd	r25, Z+21	; 0x15
    2bda:	a6 89       	ldd	r26, Z+22	; 0x16
    2bdc:	b7 89       	ldd	r27, Z+23	; 0x17
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    2bde:	2e 30       	cpi	r18, 0x0E	; 14
    2be0:	f1 e0       	ldi	r31, 0x01	; 1
    2be2:	3f 07       	cpc	r19, r31
    2be4:	f1 e0       	ldi	r31, 0x01	; 1
    2be6:	4f 07       	cpc	r20, r31
    2be8:	f0 e0       	ldi	r31, 0x00	; 0
    2bea:	5f 07       	cpc	r21, r31
    2bec:	51 f0       	breq	.+20     	; 0x2c02 <RNDIS_Device_ProcessControlRequest+0x444>
    2bee:	23 50       	subi	r18, 0x03	; 3
    2bf0:	31 40       	sbci	r19, 0x01	; 1
    2bf2:	41 40       	sbci	r20, 0x01	; 1
    2bf4:	51 40       	sbci	r21, 0x01	; 1
    2bf6:	a9 f0       	breq	.+42     	; 0x2c22 <RNDIS_Device_ProcessControlRequest+0x464>
    2bf8:	8b eb       	ldi	r24, 0xBB	; 187
    2bfa:	90 e0       	ldi	r25, 0x00	; 0
    2bfc:	a0 e0       	ldi	r26, 0x00	; 0
    2bfe:	b0 ec       	ldi	r27, 0xC0	; 192
    2c00:	14 c0       	rjmp	.+40     	; 0x2c2a <RNDIS_Device_ProcessControlRequest+0x46c>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    2c02:	fe 01       	movw	r30, r28
    2c04:	e8 0f       	add	r30, r24
    2c06:	f9 1f       	adc	r31, r25
    2c08:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c0a:	96 8d       	ldd	r25, Z+30	; 0x1e
    2c0c:	a7 8d       	ldd	r26, Z+31	; 0x1f
    2c0e:	b0 a1       	ldd	r27, Z+32	; 0x20
    2c10:	c9 56       	subi	r28, 0x69	; 105
    2c12:	df 4f       	sbci	r29, 0xFF	; 255
    2c14:	88 83       	st	Y, r24
    2c16:	99 83       	std	Y+1, r25	; 0x01
    2c18:	aa 83       	std	Y+2, r26	; 0x02
    2c1a:	bb 83       	std	Y+3, r27	; 0x03
			RNDISInterfaceInfo->State.CurrRNDISState   = le32_to_cpu((RNDISInterfaceInfo->State.CurrPacketFilter) ?
    2c1c:	fe 01       	movw	r30, r28
    2c1e:	82 e0       	ldi	r24, 0x02	; 2
    2c20:	82 93       	st	-Z, r24
    2c22:	80 e0       	ldi	r24, 0x00	; 0
    2c24:	90 e0       	ldi	r25, 0x00	; 0
    2c26:	a0 e0       	ldi	r26, 0x00	; 0
    2c28:	b0 e0       	ldi	r27, 0x00	; 0
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    2c2a:	f8 01       	movw	r30, r16
    2c2c:	84 87       	std	Z+12, r24	; 0x0c
    2c2e:	95 87       	std	Z+13, r25	; 0x0d
    2c30:	a6 87       	std	Z+14, r26	; 0x0e
    2c32:	b7 87       	std	Z+15, r27	; 0x0f
    2c34:	85 c0       	rjmp	.+266    	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2c36:	cb 56       	subi	r28, 0x6B	; 107
    2c38:	df 4f       	sbci	r29, 0xFF	; 255
    2c3a:	81 e0       	ldi	r24, 0x01	; 1
    2c3c:	88 83       	st	Y, r24
    2c3e:	c5 59       	subi	r28, 0x95	; 149
    2c40:	d0 40       	sbci	r29, 0x00	; 0

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    2c42:	86 e0       	ldi	r24, 0x06	; 6
    2c44:	90 e0       	ldi	r25, 0x00	; 0
    2c46:	a0 e0       	ldi	r26, 0x00	; 0
    2c48:	b0 e8       	ldi	r27, 0x80	; 128
    2c4a:	8d 8b       	std	Y+21, r24	; 0x15
    2c4c:	9e 8b       	std	Y+22, r25	; 0x16
    2c4e:	af 8b       	std	Y+23, r26	; 0x17
    2c50:	b8 8f       	std	Y+24, r27	; 0x18
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    2c52:	80 e1       	ldi	r24, 0x10	; 16
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	a0 e0       	ldi	r26, 0x00	; 0
    2c58:	b0 e0       	ldi	r27, 0x00	; 0
    2c5a:	f8 01       	movw	r30, r16
    2c5c:	84 83       	std	Z+4, r24	; 0x04
    2c5e:	95 83       	std	Z+5, r25	; 0x05
    2c60:	a6 83       	std	Z+6, r26	; 0x06
    2c62:	b7 83       	std	Z+7, r27	; 0x07
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2c64:	10 86       	std	Z+8, r1	; 0x08
    2c66:	11 86       	std	Z+9, r1	; 0x09
    2c68:	12 86       	std	Z+10, r1	; 0x0a
    2c6a:	13 86       	std	Z+11, r1	; 0x0b
    2c6c:	17 c0       	rjmp	.+46     	; 0x2c9c <RNDIS_Device_ProcessControlRequest+0x4de>
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    2c6e:	cb 56       	subi	r28, 0x6B	; 107
    2c70:	df 4f       	sbci	r29, 0xFF	; 255
    2c72:	81 e0       	ldi	r24, 0x01	; 1
    2c74:	88 83       	st	Y, r24
    2c76:	c5 59       	subi	r28, 0x95	; 149
    2c78:	d0 40       	sbci	r29, 0x00	; 0
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    2c7a:	88 e0       	ldi	r24, 0x08	; 8
    2c7c:	90 e0       	ldi	r25, 0x00	; 0
    2c7e:	a0 e0       	ldi	r26, 0x00	; 0
    2c80:	b0 e8       	ldi	r27, 0x80	; 128
    2c82:	8d 8b       	std	Y+21, r24	; 0x15
    2c84:	9e 8b       	std	Y+22, r25	; 0x16
    2c86:	af 8b       	std	Y+23, r26	; 0x17
    2c88:	b8 8f       	std	Y+24, r27	; 0x18
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    2c8a:	80 e1       	ldi	r24, 0x10	; 16
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	a0 e0       	ldi	r26, 0x00	; 0
    2c90:	b0 e0       	ldi	r27, 0x00	; 0
    2c92:	f8 01       	movw	r30, r16
    2c94:	84 83       	std	Z+4, r24	; 0x04
    2c96:	95 83       	std	Z+5, r25	; 0x05
    2c98:	a6 83       	std	Z+6, r26	; 0x06
    2c9a:	b7 83       	std	Z+7, r27	; 0x07
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2c9c:	14 86       	std	Z+12, r1	; 0x0c
    2c9e:	15 86       	std	Z+13, r1	; 0x0d
    2ca0:	16 86       	std	Z+14, r1	; 0x0e
    2ca2:	17 86       	std	Z+15, r1	; 0x0f
    2ca4:	4d c0       	rjmp	.+154    	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    2ca6:	80 91 01 14 	lds	r24, 0x1401
    2caa:	81 3a       	cpi	r24, 0xA1	; 161
    2cac:	09 f0       	breq	.+2      	; 0x2cb0 <RNDIS_Device_ProcessControlRequest+0x4f2>
    2cae:	48 c0       	rjmp	.+144    	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
    2cb0:	8e 01       	movw	r16, r28
    2cb2:	0b 5e       	subi	r16, 0xEB	; 235
    2cb4:	1f 4f       	sbci	r17, 0xFF	; 255

				if (!(MessageHeader->MessageLength))
    2cb6:	f8 01       	movw	r30, r16
    2cb8:	84 81       	ldd	r24, Z+4	; 0x04
    2cba:	95 81       	ldd	r25, Z+5	; 0x05
    2cbc:	a6 81       	ldd	r26, Z+6	; 0x06
    2cbe:	b7 81       	ldd	r27, Z+7	; 0x07
    2cc0:	00 97       	sbiw	r24, 0x00	; 0
    2cc2:	a1 05       	cpc	r26, r1
    2cc4:	b1 05       	cpc	r27, r1
    2cc6:	49 f4       	brne	.+18     	; 0x2cda <RNDIS_Device_ProcessControlRequest+0x51c>
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    2cc8:	1d 8a       	std	Y+21, r1	; 0x15
					MessageHeader->MessageLength                    = CPU_TO_LE32(1);
    2cca:	81 e0       	ldi	r24, 0x01	; 1
    2ccc:	90 e0       	ldi	r25, 0x00	; 0
    2cce:	a0 e0       	ldi	r26, 0x00	; 0
    2cd0:	b0 e0       	ldi	r27, 0x00	; 0
    2cd2:	84 83       	std	Z+4, r24	; 0x04
    2cd4:	95 83       	std	Z+5, r25	; 0x05
    2cd6:	a6 83       	std	Z+6, r26	; 0x06
    2cd8:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    2cda:	80 91 e8 00 	lds	r24, 0x00E8
    2cde:	87 7f       	andi	r24, 0xF7	; 247
    2ce0:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    2ce4:	f8 01       	movw	r30, r16
    2ce6:	64 81       	ldd	r22, Z+4	; 0x04
    2ce8:	75 81       	ldd	r23, Z+5	; 0x05
    2cea:	ce 01       	movw	r24, r28
    2cec:	45 96       	adiw	r24, 0x15	; 21
    2cee:	c4 d8       	rcall	.-3704   	; 0x1e78 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    2cf0:	80 91 e8 00 	lds	r24, 0x00E8
    2cf4:	8b 77       	andi	r24, 0x7B	; 123
    2cf6:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    2cfa:	f8 01       	movw	r30, r16
    2cfc:	14 82       	std	Z+4, r1	; 0x04
    2cfe:	15 82       	std	Z+5, r1	; 0x05
    2d00:	16 82       	std	Z+6, r1	; 0x06
    2d02:	17 82       	std	Z+7, r1	; 0x07
    2d04:	1d c0       	rjmp	.+58     	; 0x2d40 <RNDIS_Device_ProcessControlRequest+0x582>
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
			
			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    2d06:	f8 01       	movw	r30, r16
    2d08:	14 86       	std	Z+12, r1	; 0x0c
    2d0a:	15 86       	std	Z+13, r1	; 0x0d
    2d0c:	16 86       	std	Z+14, r1	; 0x0e
    2d0e:	17 86       	std	Z+15, r1	; 0x0f
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    2d10:	68 96       	adiw	r28, 0x18	; 24
    2d12:	ce 01       	movw	r24, r28
    2d14:	a0 e0       	ldi	r26, 0x00	; 0
    2d16:	b0 e0       	ldi	r27, 0x00	; 0
    2d18:	68 97       	sbiw	r28, 0x18	; 24
    2d1a:	84 83       	std	Z+4, r24	; 0x04
    2d1c:	95 83       	std	Z+5, r25	; 0x05
    2d1e:	a6 83       	std	Z+6, r26	; 0x06
    2d20:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    2d22:	ce 01       	movw	r24, r28
    2d24:	a0 e0       	ldi	r26, 0x00	; 0
    2d26:	b0 e0       	ldi	r27, 0x00	; 0
    2d28:	80 8b       	std	Z+16, r24	; 0x10
    2d2a:	91 8b       	std	Z+17, r25	; 0x11
    2d2c:	a2 8b       	std	Z+18, r26	; 0x12
    2d2e:	b3 8b       	std	Z+19, r27	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    2d30:	80 e1       	ldi	r24, 0x10	; 16
    2d32:	90 e0       	ldi	r25, 0x00	; 0
    2d34:	a0 e0       	ldi	r26, 0x00	; 0
    2d36:	b0 e0       	ldi	r27, 0x00	; 0
    2d38:	84 8b       	std	Z+20, r24	; 0x14
    2d3a:	95 8b       	std	Z+21, r25	; 0x15
    2d3c:	a6 8b       	std	Z+22, r26	; 0x16
    2d3e:	b7 8b       	std	Z+23, r27	; 0x17
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    2d40:	df 91       	pop	r29
    2d42:	cf 91       	pop	r28
    2d44:	1f 91       	pop	r17
    2d46:	0f 91       	pop	r16
    2d48:	ff 90       	pop	r15
    2d4a:	ef 90       	pop	r14
    2d4c:	08 95       	ret

00002d4e <Serial_putchar>:

FILE USARTSerialStream;

int Serial_putchar(char DataByte,
                   FILE *Stream)
{
    2d4e:	98 2f       	mov	r25, r24
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_SendByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_SendByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
    2d50:	80 91 c8 00 	lds	r24, 0x00C8
    2d54:	85 ff       	sbrs	r24, 5
    2d56:	fc cf       	rjmp	.-8      	; 0x2d50 <Serial_putchar+0x2>
				UDR1 = DataByte;
    2d58:	90 93 ce 00 	sts	0x00CE, r25
	(void)Stream;

	Serial_SendByte(DataByte);
	return 0;
}
    2d5c:	80 e0       	ldi	r24, 0x00	; 0
    2d5e:	90 e0       	ldi	r25, 0x00	; 0
    2d60:	08 95       	ret

00002d62 <Serial_getchar>:
			 *  \return Boolean \c true if a character has been received, \c false otherwise.
			 */
			static inline bool Serial_IsCharReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Serial_IsCharReceived(void)
			{
				return ((UCSR1A & (1 << RXC1)) ? true : false);
    2d62:	80 91 c8 00 	lds	r24, 0x00C8

int Serial_getchar(FILE *Stream)
{
	(void)Stream;

	if (!(Serial_IsCharReceived()))
    2d66:	87 fd       	sbrc	r24, 7
    2d68:	03 c0       	rjmp	.+6      	; 0x2d70 <Serial_getchar+0xe>
    2d6a:	2e ef       	ldi	r18, 0xFE	; 254
    2d6c:	3f ef       	ldi	r19, 0xFF	; 255
    2d6e:	0b c0       	rjmp	.+22     	; 0x2d86 <Serial_getchar+0x24>
    2d70:	80 91 c8 00 	lds	r24, 0x00C8
			 *  \return Next byte received from the USART, or a negative value if no byte has been received.
			 */
			static inline int16_t Serial_ReceiveByte(void) ATTR_ALWAYS_INLINE;
			static inline int16_t Serial_ReceiveByte(void)
			{
				if (!(Serial_IsCharReceived()))
    2d74:	87 fd       	sbrc	r24, 7
    2d76:	03 c0       	rjmp	.+6      	; 0x2d7e <Serial_getchar+0x1c>
    2d78:	2f ef       	ldi	r18, 0xFF	; 255
    2d7a:	3f ef       	ldi	r19, 0xFF	; 255
    2d7c:	04 c0       	rjmp	.+8      	; 0x2d86 <Serial_getchar+0x24>
				  return -1;
				
				return UDR1;
    2d7e:	80 91 ce 00 	lds	r24, 0x00CE
    2d82:	28 2f       	mov	r18, r24
    2d84:	30 e0       	ldi	r19, 0x00	; 0
	  return _FDEV_EOF;

	return Serial_ReceiveByte();
}
    2d86:	c9 01       	movw	r24, r18
    2d88:	08 95       	ret

00002d8a <memcpy_P>:
    2d8a:	fb 01       	movw	r30, r22
    2d8c:	dc 01       	movw	r26, r24
    2d8e:	02 c0       	rjmp	.+4      	; 0x2d94 <memcpy_P+0xa>
    2d90:	05 90       	lpm	r0, Z+
    2d92:	0d 92       	st	X+, r0
    2d94:	41 50       	subi	r20, 0x01	; 1
    2d96:	50 40       	sbci	r21, 0x00	; 0
    2d98:	d8 f7       	brcc	.-10     	; 0x2d90 <memcpy_P+0x6>
    2d9a:	08 95       	ret

00002d9c <strcpy_P>:
    2d9c:	fb 01       	movw	r30, r22
    2d9e:	dc 01       	movw	r26, r24
    2da0:	05 90       	lpm	r0, Z+
    2da2:	0d 92       	st	X+, r0
    2da4:	00 20       	and	r0, r0
    2da6:	e1 f7       	brne	.-8      	; 0x2da0 <strcpy_P+0x4>
    2da8:	08 95       	ret

00002daa <strlen_P>:
    2daa:	fc 01       	movw	r30, r24
    2dac:	05 90       	lpm	r0, Z+
    2dae:	00 20       	and	r0, r0
    2db0:	e9 f7       	brne	.-6      	; 0x2dac <strlen_P+0x2>
    2db2:	80 95       	com	r24
    2db4:	90 95       	com	r25
    2db6:	8e 0f       	add	r24, r30
    2db8:	9f 1f       	adc	r25, r31
    2dba:	08 95       	ret

00002dbc <strncpy_P>:
    2dbc:	fb 01       	movw	r30, r22
    2dbe:	dc 01       	movw	r26, r24
    2dc0:	41 50       	subi	r20, 0x01	; 1
    2dc2:	50 40       	sbci	r21, 0x00	; 0
    2dc4:	48 f0       	brcs	.+18     	; 0x2dd8 <strncpy_P+0x1c>
    2dc6:	05 90       	lpm	r0, Z+
    2dc8:	0d 92       	st	X+, r0
    2dca:	00 20       	and	r0, r0
    2dcc:	c9 f7       	brne	.-14     	; 0x2dc0 <strncpy_P+0x4>
    2dce:	01 c0       	rjmp	.+2      	; 0x2dd2 <strncpy_P+0x16>
    2dd0:	1d 92       	st	X+, r1
    2dd2:	41 50       	subi	r20, 0x01	; 1
    2dd4:	50 40       	sbci	r21, 0x00	; 0
    2dd6:	e0 f7       	brcc	.-8      	; 0x2dd0 <strncpy_P+0x14>
    2dd8:	08 95       	ret

00002dda <memcmp>:
    2dda:	fb 01       	movw	r30, r22
    2ddc:	dc 01       	movw	r26, r24
    2dde:	04 c0       	rjmp	.+8      	; 0x2de8 <memcmp+0xe>
    2de0:	8d 91       	ld	r24, X+
    2de2:	01 90       	ld	r0, Z+
    2de4:	80 19       	sub	r24, r0
    2de6:	21 f4       	brne	.+8      	; 0x2df0 <memcmp+0x16>
    2de8:	41 50       	subi	r20, 0x01	; 1
    2dea:	50 40       	sbci	r21, 0x00	; 0
    2dec:	c8 f7       	brcc	.-14     	; 0x2de0 <memcmp+0x6>
    2dee:	88 1b       	sub	r24, r24
    2df0:	99 0b       	sbc	r25, r25
    2df2:	08 95       	ret

00002df4 <memcpy>:
    2df4:	fb 01       	movw	r30, r22
    2df6:	dc 01       	movw	r26, r24
    2df8:	02 c0       	rjmp	.+4      	; 0x2dfe <memcpy+0xa>
    2dfa:	01 90       	ld	r0, Z+
    2dfc:	0d 92       	st	X+, r0
    2dfe:	41 50       	subi	r20, 0x01	; 1
    2e00:	50 40       	sbci	r21, 0x00	; 0
    2e02:	d8 f7       	brcc	.-10     	; 0x2dfa <memcpy+0x6>
    2e04:	08 95       	ret

00002e06 <memmove>:
    2e06:	68 17       	cp	r22, r24
    2e08:	79 07       	cpc	r23, r25
    2e0a:	68 f4       	brcc	.+26     	; 0x2e26 <memmove+0x20>
    2e0c:	fb 01       	movw	r30, r22
    2e0e:	dc 01       	movw	r26, r24
    2e10:	e4 0f       	add	r30, r20
    2e12:	f5 1f       	adc	r31, r21
    2e14:	a4 0f       	add	r26, r20
    2e16:	b5 1f       	adc	r27, r21
    2e18:	02 c0       	rjmp	.+4      	; 0x2e1e <memmove+0x18>
    2e1a:	02 90       	ld	r0, -Z
    2e1c:	0e 92       	st	-X, r0
    2e1e:	41 50       	subi	r20, 0x01	; 1
    2e20:	50 40       	sbci	r21, 0x00	; 0
    2e22:	d8 f7       	brcc	.-10     	; 0x2e1a <memmove+0x14>
    2e24:	08 95       	ret
    2e26:	e6 cf       	rjmp	.-52     	; 0x2df4 <memcpy>

00002e28 <strncmp>:
    2e28:	fb 01       	movw	r30, r22
    2e2a:	dc 01       	movw	r26, r24
    2e2c:	41 50       	subi	r20, 0x01	; 1
    2e2e:	50 40       	sbci	r21, 0x00	; 0
    2e30:	30 f0       	brcs	.+12     	; 0x2e3e <strncmp+0x16>
    2e32:	8d 91       	ld	r24, X+
    2e34:	01 90       	ld	r0, Z+
    2e36:	80 19       	sub	r24, r0
    2e38:	19 f4       	brne	.+6      	; 0x2e40 <strncmp+0x18>
    2e3a:	00 20       	and	r0, r0
    2e3c:	b9 f7       	brne	.-18     	; 0x2e2c <strncmp+0x4>
    2e3e:	88 1b       	sub	r24, r24
    2e40:	99 0b       	sbc	r25, r25
    2e42:	08 95       	ret

00002e44 <_exit>:
    2e44:	f8 94       	cli

00002e46 <__stop_program>:
    2e46:	ff cf       	rjmp	.-2      	; 0x2e46 <__stop_program>
